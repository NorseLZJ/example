// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `Collect.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:pbdef.CollectInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CollectInfo {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CollectInfo.img)
    pub img: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CollectInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CollectInfo.count)
    pub count: i32,
    // @@protoc_insertion_point(field:pbdef.CollectInfo.subtype)
    pub subtype: i32,
    // @@protoc_insertion_point(field:pbdef.CollectInfo.id)
    pub id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CollectInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectInfo {
    fn default() -> &'a CollectInfo {
        <CollectInfo as ::protobuf::Message>::default_instance()
    }
}

impl CollectInfo {
    pub fn new() -> CollectInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "img",
            |m: &CollectInfo| { &m.img },
            |m: &mut CollectInfo| { &mut m.img },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CollectInfo| { &m.name },
            |m: &mut CollectInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &CollectInfo| { &m.count },
            |m: &mut CollectInfo| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subtype",
            |m: &CollectInfo| { &m.subtype },
            |m: &mut CollectInfo| { &mut m.subtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CollectInfo| { &m.id },
            |m: &mut CollectInfo| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectInfo>(
            "CollectInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectInfo {
    const NAME: &'static str = "CollectInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.img = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.count = is.read_int32()?;
                },
                32 => {
                    self.subtype = is.read_int32()?;
                },
                40 => {
                    self.id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.img.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.img);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.count);
        }
        if self.subtype != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.subtype);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.img.is_empty() {
            os.write_string(1, &self.img)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.count != 0 {
            os.write_int32(3, self.count)?;
        }
        if self.subtype != 0 {
            os.write_int32(4, self.subtype)?;
        }
        if self.id != 0 {
            os.write_int32(5, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectInfo {
        CollectInfo::new()
    }

    fn clear(&mut self) {
        self.img.clear();
        self.name.clear();
        self.count = 0;
        self.subtype = 0;
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectInfo {
        static instance: CollectInfo = CollectInfo {
            img: ::std::string::String::new(),
            name: ::std::string::String::new(),
            count: 0,
            subtype: 0,
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadCollectReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadCollectReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadCollectReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadCollectReq {
    fn default() -> &'a LoadCollectReq {
        <LoadCollectReq as ::protobuf::Message>::default_instance()
    }
}

impl LoadCollectReq {
    pub fn new() -> LoadCollectReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadCollectReq>(
            "LoadCollectReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadCollectReq {
    const NAME: &'static str = "LoadCollectReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadCollectReq {
        LoadCollectReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadCollectReq {
        static instance: LoadCollectReq = LoadCollectReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadCollectReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadCollectReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadCollectReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCollectReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadCollectRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadCollectRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoadCollectRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.LoadCollectRsp.infos)
    pub infos: ::std::collections::HashMap<u32, CollectInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadCollectRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadCollectRsp {
    fn default() -> &'a LoadCollectRsp {
        <LoadCollectRsp as ::protobuf::Message>::default_instance()
    }
}

impl LoadCollectRsp {
    pub fn new() -> LoadCollectRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &LoadCollectRsp| { &m.ret },
            |m: &mut LoadCollectRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "infos",
            |m: &LoadCollectRsp| { &m.infos },
            |m: &mut LoadCollectRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadCollectRsp>(
            "LoadCollectRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadCollectRsp {
    const NAME: &'static str = "LoadCollectRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_uint32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.infos.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for (k, v) in &self.infos {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for (k, v) in &self.infos {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::uint32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_uint32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadCollectRsp {
        LoadCollectRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadCollectRsp {
        static instance: ::protobuf::rt::Lazy<LoadCollectRsp> = ::protobuf::rt::Lazy::new();
        instance.get(LoadCollectRsp::new)
    }
}

impl ::protobuf::MessageFull for LoadCollectRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadCollectRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadCollectRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCollectRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserGrant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserGrant {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserGrant.id)
    pub id: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.userid)
    pub userid: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.collid)
    pub collid: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.truenumber)
    pub truenumber: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.hashs)
    pub hashs: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.createtime)
    pub createtime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.buyprice)
    pub buyprice: f64,
    // @@protoc_insertion_point(field:pbdef.UserGrant.buytime)
    pub buytime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.endtime)
    pub endtime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.sellprice)
    pub sellprice: f64,
    // @@protoc_insertion_point(field:pbdef.UserGrant.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.oppositeuser)
    pub oppositeuser: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.sjtime)
    pub sjtime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.tokenid)
    pub tokenid: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.paytype)
    pub paytype: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.state)
    pub state: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.classid)
    pub classid: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.yuanyuzhouid)
    pub yuanyuzhouid: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.usage)
    pub usage: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.updateTIME)
    pub updateTIME: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.tradeTIME)
    pub tradeTIME: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.direction)
    pub direction: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.pos)
    pub pos: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.attachID)
    pub attachID: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.img)
    pub img: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserGrant.count)
    pub count: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.subtype)
    pub subtype: i32,
    // @@protoc_insertion_point(field:pbdef.UserGrant.config_id)
    pub config_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserGrant.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserGrant {
    fn default() -> &'a UserGrant {
        <UserGrant as ::protobuf::Message>::default_instance()
    }
}

impl UserGrant {
    pub fn new() -> UserGrant {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(29);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UserGrant| { &m.id },
            |m: &mut UserGrant| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userid",
            |m: &UserGrant| { &m.userid },
            |m: &mut UserGrant| { &mut m.userid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collid",
            |m: &UserGrant| { &m.collid },
            |m: &mut UserGrant| { &mut m.collid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "truenumber",
            |m: &UserGrant| { &m.truenumber },
            |m: &mut UserGrant| { &mut m.truenumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hashs",
            |m: &UserGrant| { &m.hashs },
            |m: &mut UserGrant| { &mut m.hashs },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createtime",
            |m: &UserGrant| { &m.createtime },
            |m: &mut UserGrant| { &mut m.createtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buyprice",
            |m: &UserGrant| { &m.buyprice },
            |m: &mut UserGrant| { &mut m.buyprice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buytime",
            |m: &UserGrant| { &m.buytime },
            |m: &mut UserGrant| { &mut m.buytime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "endtime",
            |m: &UserGrant| { &m.endtime },
            |m: &mut UserGrant| { &mut m.endtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sellprice",
            |m: &UserGrant| { &m.sellprice },
            |m: &mut UserGrant| { &mut m.sellprice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &UserGrant| { &m.type_ },
            |m: &mut UserGrant| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oppositeuser",
            |m: &UserGrant| { &m.oppositeuser },
            |m: &mut UserGrant| { &mut m.oppositeuser },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sjtime",
            |m: &UserGrant| { &m.sjtime },
            |m: &mut UserGrant| { &mut m.sjtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tokenid",
            |m: &UserGrant| { &m.tokenid },
            |m: &mut UserGrant| { &mut m.tokenid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paytype",
            |m: &UserGrant| { &m.paytype },
            |m: &mut UserGrant| { &mut m.paytype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &UserGrant| { &m.state },
            |m: &mut UserGrant| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "classid",
            |m: &UserGrant| { &m.classid },
            |m: &mut UserGrant| { &mut m.classid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "yuanyuzhouid",
            |m: &UserGrant| { &m.yuanyuzhouid },
            |m: &mut UserGrant| { &mut m.yuanyuzhouid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &UserGrant| { &m.usage },
            |m: &mut UserGrant| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updateTIME",
            |m: &UserGrant| { &m.updateTIME },
            |m: &mut UserGrant| { &mut m.updateTIME },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tradeTIME",
            |m: &UserGrant| { &m.tradeTIME },
            |m: &mut UserGrant| { &mut m.tradeTIME },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &UserGrant| { &m.direction },
            |m: &mut UserGrant| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pos",
            |m: &UserGrant| { &m.pos },
            |m: &mut UserGrant| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attachID",
            |m: &UserGrant| { &m.attachID },
            |m: &mut UserGrant| { &mut m.attachID },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "img",
            |m: &UserGrant| { &m.img },
            |m: &mut UserGrant| { &mut m.img },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &UserGrant| { &m.name },
            |m: &mut UserGrant| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &UserGrant| { &m.count },
            |m: &mut UserGrant| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subtype",
            |m: &UserGrant| { &m.subtype },
            |m: &mut UserGrant| { &mut m.subtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "config_id",
            |m: &UserGrant| { &m.config_id },
            |m: &mut UserGrant| { &mut m.config_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserGrant>(
            "UserGrant",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserGrant {
    const NAME: &'static str = "UserGrant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.userid = is.read_int32()?;
                },
                24 => {
                    self.collid = is.read_int32()?;
                },
                34 => {
                    self.truenumber = is.read_string()?;
                },
                42 => {
                    self.hashs = is.read_string()?;
                },
                50 => {
                    self.createtime = is.read_string()?;
                },
                57 => {
                    self.buyprice = is.read_double()?;
                },
                66 => {
                    self.buytime = is.read_string()?;
                },
                74 => {
                    self.endtime = is.read_string()?;
                },
                81 => {
                    self.sellprice = is.read_double()?;
                },
                88 => {
                    self.type_ = is.read_int32()?;
                },
                96 => {
                    self.oppositeuser = is.read_int32()?;
                },
                106 => {
                    self.sjtime = is.read_string()?;
                },
                114 => {
                    self.tokenid = is.read_string()?;
                },
                120 => {
                    self.paytype = is.read_int32()?;
                },
                128 => {
                    self.state = is.read_int32()?;
                },
                138 => {
                    self.classid = is.read_string()?;
                },
                144 => {
                    self.yuanyuzhouid = is.read_int32()?;
                },
                152 => {
                    self.usage = is.read_int32()?;
                },
                162 => {
                    self.updateTIME = is.read_string()?;
                },
                170 => {
                    self.tradeTIME = is.read_string()?;
                },
                178 => {
                    self.direction = is.read_string()?;
                },
                186 => {
                    self.pos = is.read_string()?;
                },
                192 => {
                    self.attachID = is.read_int32()?;
                },
                242 => {
                    self.img = is.read_string()?;
                },
                250 => {
                    self.name = is.read_string()?;
                },
                256 => {
                    self.count = is.read_int32()?;
                },
                264 => {
                    self.subtype = is.read_int32()?;
                },
                272 => {
                    self.config_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.userid != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.userid);
        }
        if self.collid != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.collid);
        }
        if !self.truenumber.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.truenumber);
        }
        if !self.hashs.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.hashs);
        }
        if !self.createtime.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.createtime);
        }
        if self.buyprice != 0. {
            my_size += 1 + 8;
        }
        if !self.buytime.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.buytime);
        }
        if !self.endtime.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.endtime);
        }
        if self.sellprice != 0. {
            my_size += 1 + 8;
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.type_);
        }
        if self.oppositeuser != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.oppositeuser);
        }
        if !self.sjtime.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.sjtime);
        }
        if !self.tokenid.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.tokenid);
        }
        if self.paytype != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.paytype);
        }
        if self.state != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.state);
        }
        if !self.classid.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.classid);
        }
        if self.yuanyuzhouid != 0 {
            my_size += ::protobuf::rt::int32_size(18, self.yuanyuzhouid);
        }
        if self.usage != 0 {
            my_size += ::protobuf::rt::int32_size(19, self.usage);
        }
        if !self.updateTIME.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.updateTIME);
        }
        if !self.tradeTIME.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.tradeTIME);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.direction);
        }
        if !self.pos.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.pos);
        }
        if self.attachID != 0 {
            my_size += ::protobuf::rt::int32_size(24, self.attachID);
        }
        if !self.img.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.img);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.name);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(32, self.count);
        }
        if self.subtype != 0 {
            my_size += ::protobuf::rt::int32_size(33, self.subtype);
        }
        if self.config_id != 0 {
            my_size += ::protobuf::rt::int32_size(34, self.config_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.userid != 0 {
            os.write_int32(2, self.userid)?;
        }
        if self.collid != 0 {
            os.write_int32(3, self.collid)?;
        }
        if !self.truenumber.is_empty() {
            os.write_string(4, &self.truenumber)?;
        }
        if !self.hashs.is_empty() {
            os.write_string(5, &self.hashs)?;
        }
        if !self.createtime.is_empty() {
            os.write_string(6, &self.createtime)?;
        }
        if self.buyprice != 0. {
            os.write_double(7, self.buyprice)?;
        }
        if !self.buytime.is_empty() {
            os.write_string(8, &self.buytime)?;
        }
        if !self.endtime.is_empty() {
            os.write_string(9, &self.endtime)?;
        }
        if self.sellprice != 0. {
            os.write_double(10, self.sellprice)?;
        }
        if self.type_ != 0 {
            os.write_int32(11, self.type_)?;
        }
        if self.oppositeuser != 0 {
            os.write_int32(12, self.oppositeuser)?;
        }
        if !self.sjtime.is_empty() {
            os.write_string(13, &self.sjtime)?;
        }
        if !self.tokenid.is_empty() {
            os.write_string(14, &self.tokenid)?;
        }
        if self.paytype != 0 {
            os.write_int32(15, self.paytype)?;
        }
        if self.state != 0 {
            os.write_int32(16, self.state)?;
        }
        if !self.classid.is_empty() {
            os.write_string(17, &self.classid)?;
        }
        if self.yuanyuzhouid != 0 {
            os.write_int32(18, self.yuanyuzhouid)?;
        }
        if self.usage != 0 {
            os.write_int32(19, self.usage)?;
        }
        if !self.updateTIME.is_empty() {
            os.write_string(20, &self.updateTIME)?;
        }
        if !self.tradeTIME.is_empty() {
            os.write_string(21, &self.tradeTIME)?;
        }
        if !self.direction.is_empty() {
            os.write_string(22, &self.direction)?;
        }
        if !self.pos.is_empty() {
            os.write_string(23, &self.pos)?;
        }
        if self.attachID != 0 {
            os.write_int32(24, self.attachID)?;
        }
        if !self.img.is_empty() {
            os.write_string(30, &self.img)?;
        }
        if !self.name.is_empty() {
            os.write_string(31, &self.name)?;
        }
        if self.count != 0 {
            os.write_int32(32, self.count)?;
        }
        if self.subtype != 0 {
            os.write_int32(33, self.subtype)?;
        }
        if self.config_id != 0 {
            os.write_int32(34, self.config_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserGrant {
        UserGrant::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.userid = 0;
        self.collid = 0;
        self.truenumber.clear();
        self.hashs.clear();
        self.createtime.clear();
        self.buyprice = 0.;
        self.buytime.clear();
        self.endtime.clear();
        self.sellprice = 0.;
        self.type_ = 0;
        self.oppositeuser = 0;
        self.sjtime.clear();
        self.tokenid.clear();
        self.paytype = 0;
        self.state = 0;
        self.classid.clear();
        self.yuanyuzhouid = 0;
        self.usage = 0;
        self.updateTIME.clear();
        self.tradeTIME.clear();
        self.direction.clear();
        self.pos.clear();
        self.attachID = 0;
        self.img.clear();
        self.name.clear();
        self.count = 0;
        self.subtype = 0;
        self.config_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserGrant {
        static instance: UserGrant = UserGrant {
            id: 0,
            userid: 0,
            collid: 0,
            truenumber: ::std::string::String::new(),
            hashs: ::std::string::String::new(),
            createtime: ::std::string::String::new(),
            buyprice: 0.,
            buytime: ::std::string::String::new(),
            endtime: ::std::string::String::new(),
            sellprice: 0.,
            type_: 0,
            oppositeuser: 0,
            sjtime: ::std::string::String::new(),
            tokenid: ::std::string::String::new(),
            paytype: 0,
            state: 0,
            classid: ::std::string::String::new(),
            yuanyuzhouid: 0,
            usage: 0,
            updateTIME: ::std::string::String::new(),
            tradeTIME: ::std::string::String::new(),
            direction: ::std::string::String::new(),
            pos: ::std::string::String::new(),
            attachID: 0,
            img: ::std::string::String::new(),
            name: ::std::string::String::new(),
            count: 0,
            subtype: 0,
            config_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserGrant {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserGrant").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserGrant {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadCollect2Req)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadCollect2Req {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadCollect2Req.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadCollect2Req {
    fn default() -> &'a LoadCollect2Req {
        <LoadCollect2Req as ::protobuf::Message>::default_instance()
    }
}

impl LoadCollect2Req {
    pub fn new() -> LoadCollect2Req {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadCollect2Req>(
            "LoadCollect2Req",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadCollect2Req {
    const NAME: &'static str = "LoadCollect2Req";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadCollect2Req {
        LoadCollect2Req::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadCollect2Req {
        static instance: LoadCollect2Req = LoadCollect2Req {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadCollect2Req {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadCollect2Req").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadCollect2Req {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCollect2Req {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadCollect2Rsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadCollect2Rsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoadCollect2Rsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.LoadCollect2Rsp.infos)
    pub infos: ::std::vec::Vec<UserGrant>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadCollect2Rsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadCollect2Rsp {
    fn default() -> &'a LoadCollect2Rsp {
        <LoadCollect2Rsp as ::protobuf::Message>::default_instance()
    }
}

impl LoadCollect2Rsp {
    pub fn new() -> LoadCollect2Rsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &LoadCollect2Rsp| { &m.ret },
            |m: &mut LoadCollect2Rsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &LoadCollect2Rsp| { &m.infos },
            |m: &mut LoadCollect2Rsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadCollect2Rsp>(
            "LoadCollect2Rsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadCollect2Rsp {
    const NAME: &'static str = "LoadCollect2Rsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadCollect2Rsp {
        LoadCollect2Rsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadCollect2Rsp {
        static instance: LoadCollect2Rsp = LoadCollect2Rsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadCollect2Rsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadCollect2Rsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadCollect2Rsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCollect2Rsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UseCollectInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UseCollectInfo {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UseCollectInfo.id)
    pub id: i32,
    // @@protoc_insertion_point(field:pbdef.UseCollectInfo.pos)
    pub pos: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UseCollectInfo.direction)
    pub direction: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UseCollectInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UseCollectInfo {
    fn default() -> &'a UseCollectInfo {
        <UseCollectInfo as ::protobuf::Message>::default_instance()
    }
}

impl UseCollectInfo {
    pub fn new() -> UseCollectInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UseCollectInfo| { &m.id },
            |m: &mut UseCollectInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pos",
            |m: &UseCollectInfo| { &m.pos },
            |m: &mut UseCollectInfo| { &mut m.pos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &UseCollectInfo| { &m.direction },
            |m: &mut UseCollectInfo| { &mut m.direction },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UseCollectInfo>(
            "UseCollectInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UseCollectInfo {
    const NAME: &'static str = "UseCollectInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.pos = is.read_string()?;
                },
                26 => {
                    self.direction = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.pos.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.pos);
        }
        if !self.direction.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.direction);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.pos.is_empty() {
            os.write_string(2, &self.pos)?;
        }
        if !self.direction.is_empty() {
            os.write_string(3, &self.direction)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UseCollectInfo {
        UseCollectInfo::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.pos.clear();
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UseCollectInfo {
        static instance: UseCollectInfo = UseCollectInfo {
            id: 0,
            pos: ::std::string::String::new(),
            direction: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UseCollectInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UseCollectInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UseCollectInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseCollectInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UseCollectReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UseCollectReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UseCollectReq.infos)
    pub infos: ::std::vec::Vec<UseCollectInfo>,
    // @@protoc_insertion_point(field:pbdef.UseCollectReq.yuanyuzhou)
    pub yuanyuzhou: i32,
    // @@protoc_insertion_point(field:pbdef.UseCollectReq.is_plan)
    pub is_plan: bool,
    // @@protoc_insertion_point(field:pbdef.UseCollectReq.plan_name)
    pub plan_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UseCollectReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UseCollectReq {
    fn default() -> &'a UseCollectReq {
        <UseCollectReq as ::protobuf::Message>::default_instance()
    }
}

impl UseCollectReq {
    pub fn new() -> UseCollectReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &UseCollectReq| { &m.infos },
            |m: &mut UseCollectReq| { &mut m.infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "yuanyuzhou",
            |m: &UseCollectReq| { &m.yuanyuzhou },
            |m: &mut UseCollectReq| { &mut m.yuanyuzhou },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_plan",
            |m: &UseCollectReq| { &m.is_plan },
            |m: &mut UseCollectReq| { &mut m.is_plan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plan_name",
            |m: &UseCollectReq| { &m.plan_name },
            |m: &mut UseCollectReq| { &mut m.plan_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UseCollectReq>(
            "UseCollectReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UseCollectReq {
    const NAME: &'static str = "UseCollectReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.infos.push(is.read_message()?);
                },
                16 => {
                    self.yuanyuzhou = is.read_int32()?;
                },
                24 => {
                    self.is_plan = is.read_bool()?;
                },
                34 => {
                    self.plan_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.yuanyuzhou != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.yuanyuzhou);
        }
        if self.is_plan != false {
            my_size += 1 + 1;
        }
        if !self.plan_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.plan_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.yuanyuzhou != 0 {
            os.write_int32(2, self.yuanyuzhou)?;
        }
        if self.is_plan != false {
            os.write_bool(3, self.is_plan)?;
        }
        if !self.plan_name.is_empty() {
            os.write_string(4, &self.plan_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UseCollectReq {
        UseCollectReq::new()
    }

    fn clear(&mut self) {
        self.infos.clear();
        self.yuanyuzhou = 0;
        self.is_plan = false;
        self.plan_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UseCollectReq {
        static instance: UseCollectReq = UseCollectReq {
            infos: ::std::vec::Vec::new(),
            yuanyuzhou: 0,
            is_plan: false,
            plan_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UseCollectReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UseCollectReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UseCollectReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseCollectReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UseCollectRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UseCollectRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UseCollectRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.UseCollectRsp.infos)
    pub infos: ::std::vec::Vec<UserGrant>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UseCollectRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UseCollectRsp {
    fn default() -> &'a UseCollectRsp {
        <UseCollectRsp as ::protobuf::Message>::default_instance()
    }
}

impl UseCollectRsp {
    pub fn new() -> UseCollectRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UseCollectRsp| { &m.ret },
            |m: &mut UseCollectRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &UseCollectRsp| { &m.infos },
            |m: &mut UseCollectRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UseCollectRsp>(
            "UseCollectRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UseCollectRsp {
    const NAME: &'static str = "UseCollectRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UseCollectRsp {
        UseCollectRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UseCollectRsp {
        static instance: UseCollectRsp = UseCollectRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UseCollectRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UseCollectRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UseCollectRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UseCollectRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserScenePlanListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserScenePlanListReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserScenePlanListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserScenePlanListReq {
    fn default() -> &'a UserScenePlanListReq {
        <UserScenePlanListReq as ::protobuf::Message>::default_instance()
    }
}

impl UserScenePlanListReq {
    pub fn new() -> UserScenePlanListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserScenePlanListReq>(
            "UserScenePlanListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserScenePlanListReq {
    const NAME: &'static str = "UserScenePlanListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserScenePlanListReq {
        UserScenePlanListReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserScenePlanListReq {
        static instance: UserScenePlanListReq = UserScenePlanListReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserScenePlanListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserScenePlanListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserScenePlanListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserScenePlanListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserScenePlan)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserScenePlan {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserScenePlan.id)
    pub id: i32,
    // @@protoc_insertion_point(field:pbdef.UserScenePlan.plan)
    pub plan: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserScenePlan.plan_name)
    pub plan_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserScenePlan.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserScenePlan {
    fn default() -> &'a UserScenePlan {
        <UserScenePlan as ::protobuf::Message>::default_instance()
    }
}

impl UserScenePlan {
    pub fn new() -> UserScenePlan {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &UserScenePlan| { &m.id },
            |m: &mut UserScenePlan| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plan",
            |m: &UserScenePlan| { &m.plan },
            |m: &mut UserScenePlan| { &mut m.plan },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "plan_name",
            |m: &UserScenePlan| { &m.plan_name },
            |m: &mut UserScenePlan| { &mut m.plan_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserScenePlan>(
            "UserScenePlan",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserScenePlan {
    const NAME: &'static str = "UserScenePlan";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.plan = is.read_string()?;
                },
                26 => {
                    self.plan_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.plan.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.plan);
        }
        if !self.plan_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.plan_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.plan.is_empty() {
            os.write_string(2, &self.plan)?;
        }
        if !self.plan_name.is_empty() {
            os.write_string(3, &self.plan_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserScenePlan {
        UserScenePlan::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.plan.clear();
        self.plan_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserScenePlan {
        static instance: UserScenePlan = UserScenePlan {
            id: 0,
            plan: ::std::string::String::new(),
            plan_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserScenePlan {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserScenePlan").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserScenePlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserScenePlan {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserScenePlanListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserScenePlanListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserScenePlanListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.UserScenePlanListRsp.infos)
    pub infos: ::std::vec::Vec<UserScenePlan>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserScenePlanListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserScenePlanListRsp {
    fn default() -> &'a UserScenePlanListRsp {
        <UserScenePlanListRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserScenePlanListRsp {
    pub fn new() -> UserScenePlanListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserScenePlanListRsp| { &m.ret },
            |m: &mut UserScenePlanListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &UserScenePlanListRsp| { &m.infos },
            |m: &mut UserScenePlanListRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserScenePlanListRsp>(
            "UserScenePlanListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserScenePlanListRsp {
    const NAME: &'static str = "UserScenePlanListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserScenePlanListRsp {
        UserScenePlanListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserScenePlanListRsp {
        static instance: UserScenePlanListRsp = UserScenePlanListRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserScenePlanListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserScenePlanListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserScenePlanListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserScenePlanListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.Collection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Collection {
    // message fields
    // @@protoc_insertion_point(field:pbdef.Collection.id)
    pub id: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.img)
    pub img: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.minname)
    pub minname: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.limits)
    pub limits: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.price)
    pub price: f64,
    // @@protoc_insertion_point(field:pbdef.Collection.video)
    pub video: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.img1)
    pub img1: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.details)
    pub details: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.publisher)
    pub publisher: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.creator)
    pub creator: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.creatorimg)
    pub creatorimg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.isdeploy)
    pub isdeploy: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.contractaddress)
    pub contractaddress: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.sold)
    pub sold: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.stockc)
    pub stockc: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.nosetup)
    pub nosetup: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.introduce)
    pub introduce: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.classid)
    pub classid: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.mustcomid)
    pub mustcomid: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.selltime)
    pub selltime: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.sendlocktime)
    pub sendlocktime: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.selltype)
    pub selltype: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.sendtype)
    pub sendtype: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.paytype)
    pub paytype: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.buycard)
    pub buycard: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.buycardsize)
    pub buycardsize: f64,
    // @@protoc_insertion_point(field:pbdef.Collection.link)
    pub link: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.publishquantity)
    pub publishquantity: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.publishtime)
    pub publishtime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.subtype)
    pub subtype: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.usage)
    pub usage: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.updateTIME)
    pub updateTIME: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.Collection.useTYPE)
    pub useTYPE: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.pointsDAYS)
    pub pointsDAYS: i32,
    // @@protoc_insertion_point(field:pbdef.Collection.pointsNUM)
    pub pointsNUM: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.Collection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Collection {
    fn default() -> &'a Collection {
        <Collection as ::protobuf::Message>::default_instance()
    }
}

impl Collection {
    pub fn new() -> Collection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(38);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Collection| { &m.id },
            |m: &mut Collection| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "img",
            |m: &Collection| { &m.img },
            |m: &mut Collection| { &mut m.img },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Collection| { &m.name },
            |m: &mut Collection| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minname",
            |m: &Collection| { &m.minname },
            |m: &mut Collection| { &mut m.minname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limits",
            |m: &Collection| { &m.limits },
            |m: &mut Collection| { &mut m.limits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &Collection| { &m.price },
            |m: &mut Collection| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "video",
            |m: &Collection| { &m.video },
            |m: &mut Collection| { &mut m.video },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "img1",
            |m: &Collection| { &m.img1 },
            |m: &mut Collection| { &mut m.img1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "details",
            |m: &Collection| { &m.details },
            |m: &mut Collection| { &mut m.details },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "publisher",
            |m: &Collection| { &m.publisher },
            |m: &mut Collection| { &mut m.publisher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creator",
            |m: &Collection| { &m.creator },
            |m: &mut Collection| { &mut m.creator },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "creatorimg",
            |m: &Collection| { &m.creatorimg },
            |m: &mut Collection| { &mut m.creatorimg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isdeploy",
            |m: &Collection| { &m.isdeploy },
            |m: &mut Collection| { &mut m.isdeploy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "contractaddress",
            |m: &Collection| { &m.contractaddress },
            |m: &mut Collection| { &mut m.contractaddress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sold",
            |m: &Collection| { &m.sold },
            |m: &mut Collection| { &mut m.sold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stockc",
            |m: &Collection| { &m.stockc },
            |m: &mut Collection| { &mut m.stockc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nosetup",
            |m: &Collection| { &m.nosetup },
            |m: &mut Collection| { &mut m.nosetup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "introduce",
            |m: &Collection| { &m.introduce },
            |m: &mut Collection| { &mut m.introduce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "classid",
            |m: &Collection| { &m.classid },
            |m: &mut Collection| { &mut m.classid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Collection| { &m.type_ },
            |m: &mut Collection| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mustcomid",
            |m: &Collection| { &m.mustcomid },
            |m: &mut Collection| { &mut m.mustcomid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "selltime",
            |m: &Collection| { &m.selltime },
            |m: &mut Collection| { &mut m.selltime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sendlocktime",
            |m: &Collection| { &m.sendlocktime },
            |m: &mut Collection| { &mut m.sendlocktime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "selltype",
            |m: &Collection| { &m.selltype },
            |m: &mut Collection| { &mut m.selltype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sendtype",
            |m: &Collection| { &m.sendtype },
            |m: &mut Collection| { &mut m.sendtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paytype",
            |m: &Collection| { &m.paytype },
            |m: &mut Collection| { &mut m.paytype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buycard",
            |m: &Collection| { &m.buycard },
            |m: &mut Collection| { &mut m.buycard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buycardsize",
            |m: &Collection| { &m.buycardsize },
            |m: &mut Collection| { &mut m.buycardsize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "link",
            |m: &Collection| { &m.link },
            |m: &mut Collection| { &mut m.link },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Collection| { &m.url },
            |m: &mut Collection| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "publishquantity",
            |m: &Collection| { &m.publishquantity },
            |m: &mut Collection| { &mut m.publishquantity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "publishtime",
            |m: &Collection| { &m.publishtime },
            |m: &mut Collection| { &mut m.publishtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subtype",
            |m: &Collection| { &m.subtype },
            |m: &mut Collection| { &mut m.subtype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &Collection| { &m.usage },
            |m: &mut Collection| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updateTIME",
            |m: &Collection| { &m.updateTIME },
            |m: &mut Collection| { &mut m.updateTIME },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "useTYPE",
            |m: &Collection| { &m.useTYPE },
            |m: &mut Collection| { &mut m.useTYPE },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pointsDAYS",
            |m: &Collection| { &m.pointsDAYS },
            |m: &mut Collection| { &mut m.pointsDAYS },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pointsNUM",
            |m: &Collection| { &m.pointsNUM },
            |m: &mut Collection| { &mut m.pointsNUM },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Collection>(
            "Collection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Collection {
    const NAME: &'static str = "Collection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.img = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.minname = is.read_string()?;
                },
                40 => {
                    self.limits = is.read_int32()?;
                },
                49 => {
                    self.price = is.read_double()?;
                },
                58 => {
                    self.video = is.read_string()?;
                },
                66 => {
                    self.img1 = is.read_string()?;
                },
                74 => {
                    self.details = is.read_string()?;
                },
                82 => {
                    self.publisher = is.read_string()?;
                },
                90 => {
                    self.creator = is.read_string()?;
                },
                98 => {
                    self.creatorimg = is.read_string()?;
                },
                104 => {
                    self.isdeploy = is.read_int32()?;
                },
                114 => {
                    self.contractaddress = is.read_string()?;
                },
                120 => {
                    self.sold = is.read_int32()?;
                },
                128 => {
                    self.stockc = is.read_int32()?;
                },
                138 => {
                    self.nosetup = is.read_string()?;
                },
                146 => {
                    self.introduce = is.read_string()?;
                },
                152 => {
                    self.classid = is.read_int32()?;
                },
                160 => {
                    self.type_ = is.read_int32()?;
                },
                168 => {
                    self.mustcomid = is.read_int32()?;
                },
                176 => {
                    self.selltime = is.read_int32()?;
                },
                184 => {
                    self.sendlocktime = is.read_int32()?;
                },
                192 => {
                    self.selltype = is.read_int32()?;
                },
                200 => {
                    self.sendtype = is.read_int32()?;
                },
                210 => {
                    self.paytype = is.read_string()?;
                },
                216 => {
                    self.buycard = is.read_int32()?;
                },
                225 => {
                    self.buycardsize = is.read_double()?;
                },
                234 => {
                    self.link = is.read_string()?;
                },
                242 => {
                    self.url = is.read_string()?;
                },
                248 => {
                    self.publishquantity = is.read_int32()?;
                },
                258 => {
                    self.publishtime = is.read_string()?;
                },
                264 => {
                    self.subtype = is.read_int32()?;
                },
                272 => {
                    self.usage = is.read_int32()?;
                },
                282 => {
                    self.updateTIME = is.read_string()?;
                },
                288 => {
                    self.useTYPE = is.read_int32()?;
                },
                296 => {
                    self.pointsDAYS = is.read_int32()?;
                },
                304 => {
                    self.pointsNUM = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.img.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.img);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.minname.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.minname);
        }
        if self.limits != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.limits);
        }
        if self.price != 0. {
            my_size += 1 + 8;
        }
        if !self.video.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.video);
        }
        if !self.img1.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.img1);
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.details);
        }
        if !self.publisher.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.publisher);
        }
        if !self.creator.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.creator);
        }
        if !self.creatorimg.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.creatorimg);
        }
        if self.isdeploy != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.isdeploy);
        }
        if !self.contractaddress.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.contractaddress);
        }
        if self.sold != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.sold);
        }
        if self.stockc != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.stockc);
        }
        if !self.nosetup.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.nosetup);
        }
        if !self.introduce.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.introduce);
        }
        if self.classid != 0 {
            my_size += ::protobuf::rt::int32_size(19, self.classid);
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(20, self.type_);
        }
        if self.mustcomid != 0 {
            my_size += ::protobuf::rt::int32_size(21, self.mustcomid);
        }
        if self.selltime != 0 {
            my_size += ::protobuf::rt::int32_size(22, self.selltime);
        }
        if self.sendlocktime != 0 {
            my_size += ::protobuf::rt::int32_size(23, self.sendlocktime);
        }
        if self.selltype != 0 {
            my_size += ::protobuf::rt::int32_size(24, self.selltype);
        }
        if self.sendtype != 0 {
            my_size += ::protobuf::rt::int32_size(25, self.sendtype);
        }
        if !self.paytype.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.paytype);
        }
        if self.buycard != 0 {
            my_size += ::protobuf::rt::int32_size(27, self.buycard);
        }
        if self.buycardsize != 0. {
            my_size += 2 + 8;
        }
        if !self.link.is_empty() {
            my_size += ::protobuf::rt::string_size(29, &self.link);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.url);
        }
        if self.publishquantity != 0 {
            my_size += ::protobuf::rt::int32_size(31, self.publishquantity);
        }
        if !self.publishtime.is_empty() {
            my_size += ::protobuf::rt::string_size(32, &self.publishtime);
        }
        if self.subtype != 0 {
            my_size += ::protobuf::rt::int32_size(33, self.subtype);
        }
        if self.usage != 0 {
            my_size += ::protobuf::rt::int32_size(34, self.usage);
        }
        if !self.updateTIME.is_empty() {
            my_size += ::protobuf::rt::string_size(35, &self.updateTIME);
        }
        if self.useTYPE != 0 {
            my_size += ::protobuf::rt::int32_size(36, self.useTYPE);
        }
        if self.pointsDAYS != 0 {
            my_size += ::protobuf::rt::int32_size(37, self.pointsDAYS);
        }
        if self.pointsNUM != 0 {
            my_size += ::protobuf::rt::int32_size(38, self.pointsNUM);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.img.is_empty() {
            os.write_string(2, &self.img)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.minname.is_empty() {
            os.write_string(4, &self.minname)?;
        }
        if self.limits != 0 {
            os.write_int32(5, self.limits)?;
        }
        if self.price != 0. {
            os.write_double(6, self.price)?;
        }
        if !self.video.is_empty() {
            os.write_string(7, &self.video)?;
        }
        if !self.img1.is_empty() {
            os.write_string(8, &self.img1)?;
        }
        if !self.details.is_empty() {
            os.write_string(9, &self.details)?;
        }
        if !self.publisher.is_empty() {
            os.write_string(10, &self.publisher)?;
        }
        if !self.creator.is_empty() {
            os.write_string(11, &self.creator)?;
        }
        if !self.creatorimg.is_empty() {
            os.write_string(12, &self.creatorimg)?;
        }
        if self.isdeploy != 0 {
            os.write_int32(13, self.isdeploy)?;
        }
        if !self.contractaddress.is_empty() {
            os.write_string(14, &self.contractaddress)?;
        }
        if self.sold != 0 {
            os.write_int32(15, self.sold)?;
        }
        if self.stockc != 0 {
            os.write_int32(16, self.stockc)?;
        }
        if !self.nosetup.is_empty() {
            os.write_string(17, &self.nosetup)?;
        }
        if !self.introduce.is_empty() {
            os.write_string(18, &self.introduce)?;
        }
        if self.classid != 0 {
            os.write_int32(19, self.classid)?;
        }
        if self.type_ != 0 {
            os.write_int32(20, self.type_)?;
        }
        if self.mustcomid != 0 {
            os.write_int32(21, self.mustcomid)?;
        }
        if self.selltime != 0 {
            os.write_int32(22, self.selltime)?;
        }
        if self.sendlocktime != 0 {
            os.write_int32(23, self.sendlocktime)?;
        }
        if self.selltype != 0 {
            os.write_int32(24, self.selltype)?;
        }
        if self.sendtype != 0 {
            os.write_int32(25, self.sendtype)?;
        }
        if !self.paytype.is_empty() {
            os.write_string(26, &self.paytype)?;
        }
        if self.buycard != 0 {
            os.write_int32(27, self.buycard)?;
        }
        if self.buycardsize != 0. {
            os.write_double(28, self.buycardsize)?;
        }
        if !self.link.is_empty() {
            os.write_string(29, &self.link)?;
        }
        if !self.url.is_empty() {
            os.write_string(30, &self.url)?;
        }
        if self.publishquantity != 0 {
            os.write_int32(31, self.publishquantity)?;
        }
        if !self.publishtime.is_empty() {
            os.write_string(32, &self.publishtime)?;
        }
        if self.subtype != 0 {
            os.write_int32(33, self.subtype)?;
        }
        if self.usage != 0 {
            os.write_int32(34, self.usage)?;
        }
        if !self.updateTIME.is_empty() {
            os.write_string(35, &self.updateTIME)?;
        }
        if self.useTYPE != 0 {
            os.write_int32(36, self.useTYPE)?;
        }
        if self.pointsDAYS != 0 {
            os.write_int32(37, self.pointsDAYS)?;
        }
        if self.pointsNUM != 0 {
            os.write_int32(38, self.pointsNUM)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Collection {
        Collection::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.img.clear();
        self.name.clear();
        self.minname.clear();
        self.limits = 0;
        self.price = 0.;
        self.video.clear();
        self.img1.clear();
        self.details.clear();
        self.publisher.clear();
        self.creator.clear();
        self.creatorimg.clear();
        self.isdeploy = 0;
        self.contractaddress.clear();
        self.sold = 0;
        self.stockc = 0;
        self.nosetup.clear();
        self.introduce.clear();
        self.classid = 0;
        self.type_ = 0;
        self.mustcomid = 0;
        self.selltime = 0;
        self.sendlocktime = 0;
        self.selltype = 0;
        self.sendtype = 0;
        self.paytype.clear();
        self.buycard = 0;
        self.buycardsize = 0.;
        self.link.clear();
        self.url.clear();
        self.publishquantity = 0;
        self.publishtime.clear();
        self.subtype = 0;
        self.usage = 0;
        self.updateTIME.clear();
        self.useTYPE = 0;
        self.pointsDAYS = 0;
        self.pointsNUM = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Collection {
        static instance: Collection = Collection {
            id: 0,
            img: ::std::string::String::new(),
            name: ::std::string::String::new(),
            minname: ::std::string::String::new(),
            limits: 0,
            price: 0.,
            video: ::std::string::String::new(),
            img1: ::std::string::String::new(),
            details: ::std::string::String::new(),
            publisher: ::std::string::String::new(),
            creator: ::std::string::String::new(),
            creatorimg: ::std::string::String::new(),
            isdeploy: 0,
            contractaddress: ::std::string::String::new(),
            sold: 0,
            stockc: 0,
            nosetup: ::std::string::String::new(),
            introduce: ::std::string::String::new(),
            classid: 0,
            type_: 0,
            mustcomid: 0,
            selltime: 0,
            sendlocktime: 0,
            selltype: 0,
            sendtype: 0,
            paytype: ::std::string::String::new(),
            buycard: 0,
            buycardsize: 0.,
            link: ::std::string::String::new(),
            url: ::std::string::String::new(),
            publishquantity: 0,
            publishtime: ::std::string::String::new(),
            subtype: 0,
            usage: 0,
            updateTIME: ::std::string::String::new(),
            useTYPE: 0,
            pointsDAYS: 0,
            pointsNUM: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Collection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Collection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Collection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadCollectConfigReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadCollectConfigReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoadCollectConfigReq.ids)
    pub ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadCollectConfigReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadCollectConfigReq {
    fn default() -> &'a LoadCollectConfigReq {
        <LoadCollectConfigReq as ::protobuf::Message>::default_instance()
    }
}

impl LoadCollectConfigReq {
    pub fn new() -> LoadCollectConfigReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &LoadCollectConfigReq| { &m.ids },
            |m: &mut LoadCollectConfigReq| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadCollectConfigReq>(
            "LoadCollectConfigReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadCollectConfigReq {
    const NAME: &'static str = "LoadCollectConfigReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.ids)?;
                },
                8 => {
                    self.ids.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadCollectConfigReq {
        LoadCollectConfigReq::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadCollectConfigReq {
        static instance: LoadCollectConfigReq = LoadCollectConfigReq {
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadCollectConfigReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadCollectConfigReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadCollectConfigReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCollectConfigReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadCollectConfigRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadCollectConfigRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoadCollectConfigRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.LoadCollectConfigRsp.infos)
    pub infos: ::std::vec::Vec<Collection>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadCollectConfigRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadCollectConfigRsp {
    fn default() -> &'a LoadCollectConfigRsp {
        <LoadCollectConfigRsp as ::protobuf::Message>::default_instance()
    }
}

impl LoadCollectConfigRsp {
    pub fn new() -> LoadCollectConfigRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &LoadCollectConfigRsp| { &m.ret },
            |m: &mut LoadCollectConfigRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &LoadCollectConfigRsp| { &m.infos },
            |m: &mut LoadCollectConfigRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadCollectConfigRsp>(
            "LoadCollectConfigRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadCollectConfigRsp {
    const NAME: &'static str = "LoadCollectConfigRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadCollectConfigRsp {
        LoadCollectConfigRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadCollectConfigRsp {
        static instance: LoadCollectConfigRsp = LoadCollectConfigRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadCollectConfigRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadCollectConfigRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadCollectConfigRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadCollectConfigRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CollectRecoveryReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CollectRecoveryReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CollectRecoveryReq.ids)
    pub ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CollectRecoveryReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectRecoveryReq {
    fn default() -> &'a CollectRecoveryReq {
        <CollectRecoveryReq as ::protobuf::Message>::default_instance()
    }
}

impl CollectRecoveryReq {
    pub fn new() -> CollectRecoveryReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ids",
            |m: &CollectRecoveryReq| { &m.ids },
            |m: &mut CollectRecoveryReq| { &mut m.ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectRecoveryReq>(
            "CollectRecoveryReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectRecoveryReq {
    const NAME: &'static str = "CollectRecoveryReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.ids)?;
                },
                8 => {
                    self.ids.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ids {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectRecoveryReq {
        CollectRecoveryReq::new()
    }

    fn clear(&mut self) {
        self.ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectRecoveryReq {
        static instance: CollectRecoveryReq = CollectRecoveryReq {
            ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectRecoveryReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectRecoveryReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectRecoveryReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectRecoveryReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CollectRecoveryRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CollectRecoveryRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CollectRecoveryRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CollectRecoveryRsp.infos)
    pub infos: ::std::vec::Vec<UserGrant>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CollectRecoveryRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectRecoveryRsp {
    fn default() -> &'a CollectRecoveryRsp {
        <CollectRecoveryRsp as ::protobuf::Message>::default_instance()
    }
}

impl CollectRecoveryRsp {
    pub fn new() -> CollectRecoveryRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CollectRecoveryRsp| { &m.ret },
            |m: &mut CollectRecoveryRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &CollectRecoveryRsp| { &m.infos },
            |m: &mut CollectRecoveryRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectRecoveryRsp>(
            "CollectRecoveryRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectRecoveryRsp {
    const NAME: &'static str = "CollectRecoveryRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectRecoveryRsp {
        CollectRecoveryRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectRecoveryRsp {
        static instance: CollectRecoveryRsp = CollectRecoveryRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectRecoveryRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectRecoveryRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectRecoveryRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectRecoveryRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rCollect.proto\x12\x05pbdef\x1a\x10BaseDefine.proto\x1a\x0eUserData.p\
    rotoP\0P\x01\"s\n\x0bCollectInfo\x12\x10\n\x03img\x18\x01\x20\x01(\tR\
    \x03img\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x14\n\x05count\
    \x18\x03\x20\x01(\x05R\x05count\x12\x18\n\x07subtype\x18\x04\x20\x01(\
    \x05R\x07subtype\x12\x0e\n\x02id\x18\x05\x20\x01(\x05R\x02id\"\x10\n\x0e\
    LoadCollectReq\"\xa8\x01\n\x0eLoadCollectRsp\x12\x10\n\x03ret\x18\x01\
    \x20\x01(\x05R\x03ret\x126\n\x05infos\x18\x02\x20\x03(\x0b2\x20.pbdef.Lo\
    adCollectRsp.InfosEntryR\x05infos\x1aL\n\nInfosEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\rR\x03key\x12(\n\x05value\x18\x02\x20\x01(\x0b2\x12.pb\
    def.CollectInfoR\x05value:\x028\x01\"\xfa\x05\n\tUserGrant\x12\x0e\n\x02\
    id\x18\x01\x20\x01(\x05R\x02id\x12\x16\n\x06userid\x18\x02\x20\x01(\x05R\
    \x06userid\x12\x16\n\x06collid\x18\x03\x20\x01(\x05R\x06collid\x12\x1e\n\
    \ntruenumber\x18\x04\x20\x01(\tR\ntruenumber\x12\x14\n\x05hashs\x18\x05\
    \x20\x01(\tR\x05hashs\x12\x1e\n\ncreatetime\x18\x06\x20\x01(\tR\ncreatet\
    ime\x12\x1a\n\x08buyprice\x18\x07\x20\x01(\x01R\x08buyprice\x12\x18\n\
    \x07buytime\x18\x08\x20\x01(\tR\x07buytime\x12\x18\n\x07endtime\x18\t\
    \x20\x01(\tR\x07endtime\x12\x1c\n\tsellprice\x18\n\x20\x01(\x01R\tsellpr\
    ice\x12\x12\n\x04type\x18\x0b\x20\x01(\x05R\x04type\x12\"\n\x0coppositeu\
    ser\x18\x0c\x20\x01(\x05R\x0coppositeuser\x12\x16\n\x06sjtime\x18\r\x20\
    \x01(\tR\x06sjtime\x12\x18\n\x07tokenid\x18\x0e\x20\x01(\tR\x07tokenid\
    \x12\x18\n\x07paytype\x18\x0f\x20\x01(\x05R\x07paytype\x12\x14\n\x05stat\
    e\x18\x10\x20\x01(\x05R\x05state\x12\x18\n\x07classid\x18\x11\x20\x01(\t\
    R\x07classid\x12\"\n\x0cyuanyuzhouid\x18\x12\x20\x01(\x05R\x0cyuanyuzhou\
    id\x12\x14\n\x05usage\x18\x13\x20\x01(\x05R\x05usage\x12\x1e\n\nupdateTI\
    ME\x18\x14\x20\x01(\tR\nupdateTIME\x12\x1c\n\ttradeTIME\x18\x15\x20\x01(\
    \tR\ttradeTIME\x12\x1c\n\tdirection\x18\x16\x20\x01(\tR\tdirection\x12\
    \x10\n\x03pos\x18\x17\x20\x01(\tR\x03pos\x12\x1a\n\x08attachID\x18\x18\
    \x20\x01(\x05R\x08attachID\x12\x10\n\x03img\x18\x1e\x20\x01(\tR\x03img\
    \x12\x12\n\x04name\x18\x1f\x20\x01(\tR\x04name\x12\x14\n\x05count\x18\
    \x20\x20\x01(\x05R\x05count\x12\x18\n\x07subtype\x18!\x20\x01(\x05R\x07s\
    ubtype\x12\x1b\n\tconfig_id\x18\"\x20\x01(\x05R\x08configId\"\x11\n\x0fL\
    oadCollect2Req\"K\n\x0fLoadCollect2Rsp\x12\x10\n\x03ret\x18\x01\x20\x01(\
    \x05R\x03ret\x12&\n\x05infos\x18\x02\x20\x03(\x0b2\x10.pbdef.UserGrantR\
    \x05infos\"P\n\x0eUseCollectInfo\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\
    \x02id\x12\x10\n\x03pos\x18\x02\x20\x01(\tR\x03pos\x12\x1c\n\tdirection\
    \x18\x03\x20\x01(\tR\tdirection\"\x92\x01\n\rUseCollectReq\x12+\n\x05inf\
    os\x18\x01\x20\x03(\x0b2\x15.pbdef.UseCollectInfoR\x05infos\x12\x1e\n\ny\
    uanyuzhou\x18\x02\x20\x01(\x05R\nyuanyuzhou\x12\x17\n\x07is_plan\x18\x03\
    \x20\x01(\x08R\x06isPlan\x12\x1b\n\tplan_name\x18\x04\x20\x01(\tR\x08pla\
    nName\"I\n\rUseCollectRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\
    \x12&\n\x05infos\x18\x02\x20\x03(\x0b2\x10.pbdef.UserGrantR\x05infos\"\
    \x16\n\x14UserScenePlanListReq\"P\n\rUserScenePlan\x12\x0e\n\x02id\x18\
    \x01\x20\x01(\x05R\x02id\x12\x12\n\x04plan\x18\x02\x20\x01(\tR\x04plan\
    \x12\x1b\n\tplan_name\x18\x03\x20\x01(\tR\x08planName\"T\n\x14UserSceneP\
    lanListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12*\n\x05infos\
    \x18\x02\x20\x03(\x0b2\x14.pbdef.UserScenePlanR\x05infos\"\x84\x08\n\nCo\
    llection\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x10\n\x03img\
    \x18\x02\x20\x01(\tR\x03img\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04nam\
    e\x12\x18\n\x07minname\x18\x04\x20\x01(\tR\x07minname\x12\x16\n\x06limit\
    s\x18\x05\x20\x01(\x05R\x06limits\x12\x14\n\x05price\x18\x06\x20\x01(\
    \x01R\x05price\x12\x14\n\x05video\x18\x07\x20\x01(\tR\x05video\x12\x12\n\
    \x04img1\x18\x08\x20\x01(\tR\x04img1\x12\x18\n\x07details\x18\t\x20\x01(\
    \tR\x07details\x12\x1c\n\tpublisher\x18\n\x20\x01(\tR\tpublisher\x12\x18\
    \n\x07creator\x18\x0b\x20\x01(\tR\x07creator\x12\x1e\n\ncreatorimg\x18\
    \x0c\x20\x01(\tR\ncreatorimg\x12\x1a\n\x08isdeploy\x18\r\x20\x01(\x05R\
    \x08isdeploy\x12(\n\x0fcontractaddress\x18\x0e\x20\x01(\tR\x0fcontractad\
    dress\x12\x12\n\x04sold\x18\x0f\x20\x01(\x05R\x04sold\x12\x16\n\x06stock\
    c\x18\x10\x20\x01(\x05R\x06stockc\x12\x18\n\x07nosetup\x18\x11\x20\x01(\
    \tR\x07nosetup\x12\x1c\n\tintroduce\x18\x12\x20\x01(\tR\tintroduce\x12\
    \x18\n\x07classid\x18\x13\x20\x01(\x05R\x07classid\x12\x12\n\x04type\x18\
    \x14\x20\x01(\x05R\x04type\x12\x1c\n\tmustcomid\x18\x15\x20\x01(\x05R\tm\
    ustcomid\x12\x1a\n\x08selltime\x18\x16\x20\x01(\x05R\x08selltime\x12\"\n\
    \x0csendlocktime\x18\x17\x20\x01(\x05R\x0csendlocktime\x12\x1a\n\x08sell\
    type\x18\x18\x20\x01(\x05R\x08selltype\x12\x1a\n\x08sendtype\x18\x19\x20\
    \x01(\x05R\x08sendtype\x12\x18\n\x07paytype\x18\x1a\x20\x01(\tR\x07payty\
    pe\x12\x18\n\x07buycard\x18\x1b\x20\x01(\x05R\x07buycard\x12\x20\n\x0bbu\
    ycardsize\x18\x1c\x20\x01(\x01R\x0bbuycardsize\x12\x12\n\x04link\x18\x1d\
    \x20\x01(\tR\x04link\x12\x10\n\x03url\x18\x1e\x20\x01(\tR\x03url\x12(\n\
    \x0fpublishquantity\x18\x1f\x20\x01(\x05R\x0fpublishquantity\x12\x20\n\
    \x0bpublishtime\x18\x20\x20\x01(\tR\x0bpublishtime\x12\x18\n\x07subtype\
    \x18!\x20\x01(\x05R\x07subtype\x12\x14\n\x05usage\x18\"\x20\x01(\x05R\
    \x05usage\x12\x1e\n\nupdateTIME\x18#\x20\x01(\tR\nupdateTIME\x12\x18\n\
    \x07useTYPE\x18$\x20\x01(\x05R\x07useTYPE\x12\x1e\n\npointsDAYS\x18%\x20\
    \x01(\x05R\npointsDAYS\x12\x1c\n\tpointsNUM\x18&\x20\x01(\x05R\tpointsNU\
    M\"(\n\x14LoadCollectConfigReq\x12\x10\n\x03ids\x18\x01\x20\x03(\x05R\
    \x03ids\"Q\n\x14LoadCollectConfigRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\
    \x05R\x03ret\x12'\n\x05infos\x18\x02\x20\x03(\x0b2\x11.pbdef.CollectionR\
    \x05infos\"&\n\x12CollectRecoveryReq\x12\x10\n\x03ids\x18\x01\x20\x03(\
    \x05R\x03ids\"N\n\x12CollectRecoveryRsp\x12\x10\n\x03ret\x18\x01\x20\x01\
    (\x05R\x03ret\x12&\n\x05infos\x18\x02\x20\x03(\x0b2\x10.pbdef.UserGrantR\
    \x05infosb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::BaseDefine::file_descriptor().clone());
            deps.push(super::UserData::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(CollectInfo::generated_message_descriptor_data());
            messages.push(LoadCollectReq::generated_message_descriptor_data());
            messages.push(LoadCollectRsp::generated_message_descriptor_data());
            messages.push(UserGrant::generated_message_descriptor_data());
            messages.push(LoadCollect2Req::generated_message_descriptor_data());
            messages.push(LoadCollect2Rsp::generated_message_descriptor_data());
            messages.push(UseCollectInfo::generated_message_descriptor_data());
            messages.push(UseCollectReq::generated_message_descriptor_data());
            messages.push(UseCollectRsp::generated_message_descriptor_data());
            messages.push(UserScenePlanListReq::generated_message_descriptor_data());
            messages.push(UserScenePlan::generated_message_descriptor_data());
            messages.push(UserScenePlanListRsp::generated_message_descriptor_data());
            messages.push(Collection::generated_message_descriptor_data());
            messages.push(LoadCollectConfigReq::generated_message_descriptor_data());
            messages.push(LoadCollectConfigRsp::generated_message_descriptor_data());
            messages.push(CollectRecoveryReq::generated_message_descriptor_data());
            messages.push(CollectRecoveryRsp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
