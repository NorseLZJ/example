// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `Merchant.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:pbdef.PlaceontainerReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaceontainerReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.collectionId)
    pub collectionId: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.mapId)
    pub mapId: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.position)
    pub position: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.shopId)
    pub shopId: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.usage)
    pub usage: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.userCollectionId)
    pub userCollectionId: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerReq.userId)
    pub userId: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.PlaceontainerReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaceontainerReq {
    fn default() -> &'a PlaceontainerReq {
        <PlaceontainerReq as ::protobuf::Message>::default_instance()
    }
}

impl PlaceontainerReq {
    pub fn new() -> PlaceontainerReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collectionId",
            |m: &PlaceontainerReq| { &m.collectionId },
            |m: &mut PlaceontainerReq| { &mut m.collectionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mapId",
            |m: &PlaceontainerReq| { &m.mapId },
            |m: &mut PlaceontainerReq| { &mut m.mapId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &PlaceontainerReq| { &m.position },
            |m: &mut PlaceontainerReq| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "shopId",
            |m: &PlaceontainerReq| { &m.shopId },
            |m: &mut PlaceontainerReq| { &mut m.shopId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &PlaceontainerReq| { &m.usage },
            |m: &mut PlaceontainerReq| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userCollectionId",
            |m: &PlaceontainerReq| { &m.userCollectionId },
            |m: &mut PlaceontainerReq| { &mut m.userCollectionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &PlaceontainerReq| { &m.userId },
            |m: &mut PlaceontainerReq| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaceontainerReq>(
            "PlaceontainerReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaceontainerReq {
    const NAME: &'static str = "PlaceontainerReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.collectionId = is.read_int32()?;
                },
                16 => {
                    self.mapId = is.read_int32()?;
                },
                24 => {
                    self.position = is.read_int32()?;
                },
                32 => {
                    self.shopId = is.read_int32()?;
                },
                40 => {
                    self.usage = is.read_int32()?;
                },
                48 => {
                    self.userCollectionId = is.read_int32()?;
                },
                56 => {
                    self.userId = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.collectionId != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.collectionId);
        }
        if self.mapId != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.mapId);
        }
        if self.position != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.position);
        }
        if self.shopId != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.shopId);
        }
        if self.usage != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.usage);
        }
        if self.userCollectionId != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.userCollectionId);
        }
        if self.userId != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.userId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.collectionId != 0 {
            os.write_int32(1, self.collectionId)?;
        }
        if self.mapId != 0 {
            os.write_int32(2, self.mapId)?;
        }
        if self.position != 0 {
            os.write_int32(3, self.position)?;
        }
        if self.shopId != 0 {
            os.write_int32(4, self.shopId)?;
        }
        if self.usage != 0 {
            os.write_int32(5, self.usage)?;
        }
        if self.userCollectionId != 0 {
            os.write_int32(6, self.userCollectionId)?;
        }
        if self.userId != 0 {
            os.write_int32(7, self.userId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaceontainerReq {
        PlaceontainerReq::new()
    }

    fn clear(&mut self) {
        self.collectionId = 0;
        self.mapId = 0;
        self.position = 0;
        self.shopId = 0;
        self.usage = 0;
        self.userCollectionId = 0;
        self.userId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaceontainerReq {
        static instance: PlaceontainerReq = PlaceontainerReq {
            collectionId: 0,
            mapId: 0,
            position: 0,
            shopId: 0,
            usage: 0,
            userCollectionId: 0,
            userId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlaceontainerReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaceontainerReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaceontainerReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaceontainerReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.PlaceontainerRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PlaceontainerRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.PlaceontainerRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.PlaceontainerRsp.message)
    pub message: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.PlaceontainerRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlaceontainerRsp {
    fn default() -> &'a PlaceontainerRsp {
        <PlaceontainerRsp as ::protobuf::Message>::default_instance()
    }
}

impl PlaceontainerRsp {
    pub fn new() -> PlaceontainerRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &PlaceontainerRsp| { &m.ret },
            |m: &mut PlaceontainerRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &PlaceontainerRsp| { &m.message },
            |m: &mut PlaceontainerRsp| { &mut m.message },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlaceontainerRsp>(
            "PlaceontainerRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlaceontainerRsp {
    const NAME: &'static str = "PlaceontainerRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlaceontainerRsp {
        PlaceontainerRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.message.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlaceontainerRsp {
        static instance: PlaceontainerRsp = PlaceontainerRsp {
            ret: 0,
            message: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlaceontainerRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlaceontainerRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlaceontainerRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlaceontainerRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LstMallReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LstMallReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LstMallReq.land_id)
    pub land_id: u64,
    // @@protoc_insertion_point(field:pbdef.LstMallReq.page)
    pub page: u32,
    // @@protoc_insertion_point(field:pbdef.LstMallReq.limit)
    pub limit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LstMallReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LstMallReq {
    fn default() -> &'a LstMallReq {
        <LstMallReq as ::protobuf::Message>::default_instance()
    }
}

impl LstMallReq {
    pub fn new() -> LstMallReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "land_id",
            |m: &LstMallReq| { &m.land_id },
            |m: &mut LstMallReq| { &mut m.land_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &LstMallReq| { &m.page },
            |m: &mut LstMallReq| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &LstMallReq| { &m.limit },
            |m: &mut LstMallReq| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LstMallReq>(
            "LstMallReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LstMallReq {
    const NAME: &'static str = "LstMallReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.land_id = is.read_uint64()?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.limit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.land_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.land_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.land_id != 0 {
            os.write_uint64(1, self.land_id)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.limit != 0 {
            os.write_uint32(3, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LstMallReq {
        LstMallReq::new()
    }

    fn clear(&mut self) {
        self.land_id = 0;
        self.page = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LstMallReq {
        static instance: LstMallReq = LstMallReq {
            land_id: 0,
            page: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LstMallReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LstMallReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LstMallReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LstMallReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LstMallRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LstMallRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LstMallRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.LstMallRsp.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.LstMallRsp.data)
    pub data: ::protobuf::MessageField<LstMallData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LstMallRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LstMallRsp {
    fn default() -> &'a LstMallRsp {
        <LstMallRsp as ::protobuf::Message>::default_instance()
    }
}

impl LstMallRsp {
    pub fn new() -> LstMallRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &LstMallRsp| { &m.ret },
            |m: &mut LstMallRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &LstMallRsp| { &m.message },
            |m: &mut LstMallRsp| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LstMallData>(
            "data",
            |m: &LstMallRsp| { &m.data },
            |m: &mut LstMallRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LstMallRsp>(
            "LstMallRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LstMallRsp {
    const NAME: &'static str = "LstMallRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LstMallRsp {
        LstMallRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.message.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LstMallRsp {
        static instance: LstMallRsp = LstMallRsp {
            ret: 0,
            message: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LstMallRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LstMallRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LstMallRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LstMallRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LstMallData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LstMallData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LstMallData.count)
    pub count: i32,
    // @@protoc_insertion_point(field:pbdef.LstMallData.LstMallItemLists)
    pub LstMallItemLists: ::std::vec::Vec<LstMallItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LstMallData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LstMallData {
    fn default() -> &'a LstMallData {
        <LstMallData as ::protobuf::Message>::default_instance()
    }
}

impl LstMallData {
    pub fn new() -> LstMallData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &LstMallData| { &m.count },
            |m: &mut LstMallData| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "LstMallItemLists",
            |m: &LstMallData| { &m.LstMallItemLists },
            |m: &mut LstMallData| { &mut m.LstMallItemLists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LstMallData>(
            "LstMallData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LstMallData {
    const NAME: &'static str = "LstMallData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = is.read_int32()?;
                },
                18 => {
                    self.LstMallItemLists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.count);
        }
        for value in &self.LstMallItemLists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_int32(1, self.count)?;
        }
        for v in &self.LstMallItemLists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LstMallData {
        LstMallData::new()
    }

    fn clear(&mut self) {
        self.count = 0;
        self.LstMallItemLists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LstMallData {
        static instance: LstMallData = LstMallData {
            count: 0,
            LstMallItemLists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LstMallData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LstMallData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LstMallData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LstMallData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LstMallItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LstMallItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LstMallItem.care_count)
    pub care_count: i32,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.is_trader)
    pub is_trader: i32,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.type_id)
    pub type_id: i32,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.mer_id)
    pub mer_id: i32,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.mer_banner)
    pub mer_banner: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.mini_banner)
    pub mini_banner: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.mer_name)
    pub mer_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.mer_avatar)
    pub mer_avatar: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.CollectionsInfoLists)
    pub CollectionsInfoLists: ::std::vec::Vec<CollectionsInfo>,
    // @@protoc_insertion_point(field:pbdef.LstMallItem.type_name)
    pub type_name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LstMallItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LstMallItem {
    fn default() -> &'a LstMallItem {
        <LstMallItem as ::protobuf::Message>::default_instance()
    }
}

impl LstMallItem {
    pub fn new() -> LstMallItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "care_count",
            |m: &LstMallItem| { &m.care_count },
            |m: &mut LstMallItem| { &mut m.care_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_trader",
            |m: &LstMallItem| { &m.is_trader },
            |m: &mut LstMallItem| { &mut m.is_trader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &LstMallItem| { &m.type_id },
            |m: &mut LstMallItem| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &LstMallItem| { &m.mer_id },
            |m: &mut LstMallItem| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_banner",
            |m: &LstMallItem| { &m.mer_banner },
            |m: &mut LstMallItem| { &mut m.mer_banner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mini_banner",
            |m: &LstMallItem| { &m.mini_banner },
            |m: &mut LstMallItem| { &mut m.mini_banner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_name",
            |m: &LstMallItem| { &m.mer_name },
            |m: &mut LstMallItem| { &mut m.mer_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_avatar",
            |m: &LstMallItem| { &m.mer_avatar },
            |m: &mut LstMallItem| { &mut m.mer_avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "CollectionsInfoLists",
            |m: &LstMallItem| { &m.CollectionsInfoLists },
            |m: &mut LstMallItem| { &mut m.CollectionsInfoLists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_name",
            |m: &LstMallItem| { &m.type_name },
            |m: &mut LstMallItem| { &mut m.type_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LstMallItem>(
            "LstMallItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LstMallItem {
    const NAME: &'static str = "LstMallItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.care_count = is.read_int32()?;
                },
                16 => {
                    self.is_trader = is.read_int32()?;
                },
                24 => {
                    self.type_id = is.read_int32()?;
                },
                32 => {
                    self.mer_id = is.read_int32()?;
                },
                42 => {
                    self.mer_banner = is.read_string()?;
                },
                50 => {
                    self.mini_banner = is.read_string()?;
                },
                58 => {
                    self.mer_name = is.read_string()?;
                },
                66 => {
                    self.mer_avatar = is.read_string()?;
                },
                74 => {
                    self.CollectionsInfoLists.push(is.read_message()?);
                },
                82 => {
                    self.type_name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.care_count != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.care_count);
        }
        if self.is_trader != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.is_trader);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.type_id);
        }
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.mer_id);
        }
        if !self.mer_banner.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mer_banner);
        }
        if !self.mini_banner.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mini_banner);
        }
        if !self.mer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.mer_name);
        }
        if !self.mer_avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.mer_avatar);
        }
        for value in &self.CollectionsInfoLists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.type_name.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.type_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.care_count != 0 {
            os.write_int32(1, self.care_count)?;
        }
        if self.is_trader != 0 {
            os.write_int32(2, self.is_trader)?;
        }
        if self.type_id != 0 {
            os.write_int32(3, self.type_id)?;
        }
        if self.mer_id != 0 {
            os.write_int32(4, self.mer_id)?;
        }
        if !self.mer_banner.is_empty() {
            os.write_string(5, &self.mer_banner)?;
        }
        if !self.mini_banner.is_empty() {
            os.write_string(6, &self.mini_banner)?;
        }
        if !self.mer_name.is_empty() {
            os.write_string(7, &self.mer_name)?;
        }
        if !self.mer_avatar.is_empty() {
            os.write_string(8, &self.mer_avatar)?;
        }
        for v in &self.CollectionsInfoLists {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if !self.type_name.is_empty() {
            os.write_string(10, &self.type_name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LstMallItem {
        LstMallItem::new()
    }

    fn clear(&mut self) {
        self.care_count = 0;
        self.is_trader = 0;
        self.type_id = 0;
        self.mer_id = 0;
        self.mer_banner.clear();
        self.mini_banner.clear();
        self.mer_name.clear();
        self.mer_avatar.clear();
        self.CollectionsInfoLists.clear();
        self.type_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LstMallItem {
        static instance: LstMallItem = LstMallItem {
            care_count: 0,
            is_trader: 0,
            type_id: 0,
            mer_id: 0,
            mer_banner: ::std::string::String::new(),
            mini_banner: ::std::string::String::new(),
            mer_name: ::std::string::String::new(),
            mer_avatar: ::std::string::String::new(),
            CollectionsInfoLists: ::std::vec::Vec::new(),
            type_name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LstMallItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LstMallItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LstMallItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LstMallItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CollectionsInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CollectionsInfo {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CollectionsInfo.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CollectionsInfo.position)
    pub position: i32,
    // @@protoc_insertion_point(field:pbdef.CollectionsInfo.usage)
    pub usage: i32,
    // @@protoc_insertion_point(field:pbdef.CollectionsInfo.userCollectionId)
    pub userCollectionId: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CollectionsInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectionsInfo {
    fn default() -> &'a CollectionsInfo {
        <CollectionsInfo as ::protobuf::Message>::default_instance()
    }
}

impl CollectionsInfo {
    pub fn new() -> CollectionsInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CollectionsInfo| { &m.id },
            |m: &mut CollectionsInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &CollectionsInfo| { &m.position },
            |m: &mut CollectionsInfo| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "usage",
            |m: &CollectionsInfo| { &m.usage },
            |m: &mut CollectionsInfo| { &mut m.usage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userCollectionId",
            |m: &CollectionsInfo| { &m.userCollectionId },
            |m: &mut CollectionsInfo| { &mut m.userCollectionId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectionsInfo>(
            "CollectionsInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectionsInfo {
    const NAME: &'static str = "CollectionsInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                16 => {
                    self.position = is.read_int32()?;
                },
                24 => {
                    self.usage = is.read_int32()?;
                },
                32 => {
                    self.userCollectionId = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if self.position != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.position);
        }
        if self.usage != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.usage);
        }
        if self.userCollectionId != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.userCollectionId);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if self.position != 0 {
            os.write_int32(2, self.position)?;
        }
        if self.usage != 0 {
            os.write_int32(3, self.usage)?;
        }
        if self.userCollectionId != 0 {
            os.write_int32(4, self.userCollectionId)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectionsInfo {
        CollectionsInfo::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.position = 0;
        self.usage = 0;
        self.userCollectionId = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectionsInfo {
        static instance: CollectionsInfo = CollectionsInfo {
            id: ::std::string::String::new(),
            position: 0,
            usage: 0,
            userCollectionId: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectionsInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectionsInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectionsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionsInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MerDetailReq.mer_id)
    pub mer_id: u32,
    // @@protoc_insertion_point(field:pbdef.MerDetailReq.php_uid)
    pub php_uid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerDetailReq {
    fn default() -> &'a MerDetailReq {
        <MerDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl MerDetailReq {
    pub fn new() -> MerDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &MerDetailReq| { &m.mer_id },
            |m: &mut MerDetailReq| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_uid",
            |m: &MerDetailReq| { &m.php_uid },
            |m: &mut MerDetailReq| { &mut m.php_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerDetailReq>(
            "MerDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerDetailReq {
    const NAME: &'static str = "MerDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mer_id = is.read_uint32()?;
                },
                16 => {
                    self.php_uid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.mer_id);
        }
        if self.php_uid != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.php_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mer_id != 0 {
            os.write_uint32(1, self.mer_id)?;
        }
        if self.php_uid != 0 {
            os.write_int32(2, self.php_uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerDetailReq {
        MerDetailReq::new()
    }

    fn clear(&mut self) {
        self.mer_id = 0;
        self.php_uid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerDetailReq {
        static instance: MerDetailReq = MerDetailReq {
            mer_id: 0,
            php_uid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MerDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailRsp.message)
    pub message: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailRsp.data)
    pub data: ::protobuf::MessageField<MerDetailData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerDetailRsp {
    fn default() -> &'a MerDetailRsp {
        <MerDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl MerDetailRsp {
    pub fn new() -> MerDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &MerDetailRsp| { &m.ret },
            |m: &mut MerDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &MerDetailRsp| { &m.message },
            |m: &mut MerDetailRsp| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MerDetailData>(
            "data",
            |m: &MerDetailRsp| { &m.data },
            |m: &mut MerDetailRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerDetailRsp>(
            "MerDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerDetailRsp {
    const NAME: &'static str = "MerDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.message = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerDetailRsp {
        MerDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.message.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerDetailRsp {
        static instance: MerDetailRsp = MerDetailRsp {
            ret: 0,
            message: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerDetailData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerDetailData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_id)
    pub mer_id: u32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.category_id)
    pub category_id: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.type_id)
    pub type_id: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_name)
    pub mer_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_adress)
    pub mer_adress: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_keyword)
    pub mer_keyword: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_avatar)
    pub mer_avatar: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_banner)
    pub mer_banner: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mini_banner)
    pub mini_banner: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.sales)
    pub sales: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.product_score)
    pub product_score: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.service_score)
    pub service_score: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.postage_score)
    pub postage_score: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mark)
    pub mark: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.status)
    pub status: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.commission_rate)
    pub commission_rate: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.long)
    pub long: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.lat)
    pub lat: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.is_bro_room)
    pub is_bro_room: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.is_bro_goods)
    pub is_bro_goods: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.is_trader)
    pub is_trader: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_info)
    pub mer_info: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.service_phone)
    pub service_phone: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.create_time)
    pub create_time: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.care_count)
    pub care_count: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.copy_product_num)
    pub copy_product_num: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.export_dump_num)
    pub export_dump_num: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_money)
    pub mer_money: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.sub_mchid)
    pub sub_mchid: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.delivery_way)
    pub delivery_way: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.margin)
    pub margin: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.is_margin)
    pub is_margin: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.delivery_balance)
    pub delivery_balance: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.ot_margin)
    pub ot_margin: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.service_time)
    pub service_time: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.system_city_id)
    pub system_city_id: i32,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.care)
    pub care: bool,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_take_address)
    pub mer_take_address: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.province_name)
    pub province_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.city_name)
    pub city_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.type_name)
    pub type_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.services_type)
    pub services_type: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerDetailData.mer_certificate)
    pub mer_certificate: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerDetailData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerDetailData {
    fn default() -> &'a MerDetailData {
        <MerDetailData as ::protobuf::Message>::default_instance()
    }
}

impl MerDetailData {
    pub fn new() -> MerDetailData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(43);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &MerDetailData| { &m.mer_id },
            |m: &mut MerDetailData| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "category_id",
            |m: &MerDetailData| { &m.category_id },
            |m: &mut MerDetailData| { &mut m.category_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &MerDetailData| { &m.type_id },
            |m: &mut MerDetailData| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_name",
            |m: &MerDetailData| { &m.mer_name },
            |m: &mut MerDetailData| { &mut m.mer_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_adress",
            |m: &MerDetailData| { &m.mer_adress },
            |m: &mut MerDetailData| { &mut m.mer_adress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_keyword",
            |m: &MerDetailData| { &m.mer_keyword },
            |m: &mut MerDetailData| { &mut m.mer_keyword },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_avatar",
            |m: &MerDetailData| { &m.mer_avatar },
            |m: &mut MerDetailData| { &mut m.mer_avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_banner",
            |m: &MerDetailData| { &m.mer_banner },
            |m: &mut MerDetailData| { &mut m.mer_banner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mini_banner",
            |m: &MerDetailData| { &m.mini_banner },
            |m: &mut MerDetailData| { &mut m.mini_banner },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sales",
            |m: &MerDetailData| { &m.sales },
            |m: &mut MerDetailData| { &mut m.sales },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_score",
            |m: &MerDetailData| { &m.product_score },
            |m: &mut MerDetailData| { &mut m.product_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_score",
            |m: &MerDetailData| { &m.service_score },
            |m: &mut MerDetailData| { &mut m.service_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "postage_score",
            |m: &MerDetailData| { &m.postage_score },
            |m: &mut MerDetailData| { &mut m.postage_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mark",
            |m: &MerDetailData| { &m.mark },
            |m: &mut MerDetailData| { &mut m.mark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "status",
            |m: &MerDetailData| { &m.status },
            |m: &mut MerDetailData| { &mut m.status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "commission_rate",
            |m: &MerDetailData| { &m.commission_rate },
            |m: &mut MerDetailData| { &mut m.commission_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "long",
            |m: &MerDetailData| { &m.long },
            |m: &mut MerDetailData| { &mut m.long },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lat",
            |m: &MerDetailData| { &m.lat },
            |m: &mut MerDetailData| { &mut m.lat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bro_room",
            |m: &MerDetailData| { &m.is_bro_room },
            |m: &mut MerDetailData| { &mut m.is_bro_room },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_bro_goods",
            |m: &MerDetailData| { &m.is_bro_goods },
            |m: &mut MerDetailData| { &mut m.is_bro_goods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_trader",
            |m: &MerDetailData| { &m.is_trader },
            |m: &mut MerDetailData| { &mut m.is_trader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_info",
            |m: &MerDetailData| { &m.mer_info },
            |m: &mut MerDetailData| { &mut m.mer_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_phone",
            |m: &MerDetailData| { &m.service_phone },
            |m: &mut MerDetailData| { &mut m.service_phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &MerDetailData| { &m.create_time },
            |m: &mut MerDetailData| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "care_count",
            |m: &MerDetailData| { &m.care_count },
            |m: &mut MerDetailData| { &mut m.care_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "copy_product_num",
            |m: &MerDetailData| { &m.copy_product_num },
            |m: &mut MerDetailData| { &mut m.copy_product_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "export_dump_num",
            |m: &MerDetailData| { &m.export_dump_num },
            |m: &mut MerDetailData| { &mut m.export_dump_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_money",
            |m: &MerDetailData| { &m.mer_money },
            |m: &mut MerDetailData| { &mut m.mer_money },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sub_mchid",
            |m: &MerDetailData| { &m.sub_mchid },
            |m: &mut MerDetailData| { &mut m.sub_mchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delivery_way",
            |m: &MerDetailData| { &m.delivery_way },
            |m: &mut MerDetailData| { &mut m.delivery_way },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "margin",
            |m: &MerDetailData| { &m.margin },
            |m: &mut MerDetailData| { &mut m.margin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_margin",
            |m: &MerDetailData| { &m.is_margin },
            |m: &mut MerDetailData| { &mut m.is_margin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delivery_balance",
            |m: &MerDetailData| { &m.delivery_balance },
            |m: &mut MerDetailData| { &mut m.delivery_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ot_margin",
            |m: &MerDetailData| { &m.ot_margin },
            |m: &mut MerDetailData| { &mut m.ot_margin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_time",
            |m: &MerDetailData| { &m.service_time },
            |m: &mut MerDetailData| { &mut m.service_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "system_city_id",
            |m: &MerDetailData| { &m.system_city_id },
            |m: &mut MerDetailData| { &mut m.system_city_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "care",
            |m: &MerDetailData| { &m.care },
            |m: &mut MerDetailData| { &mut m.care },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_take_address",
            |m: &MerDetailData| { &m.mer_take_address },
            |m: &mut MerDetailData| { &mut m.mer_take_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "province_name",
            |m: &MerDetailData| { &m.province_name },
            |m: &mut MerDetailData| { &mut m.province_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "city_name",
            |m: &MerDetailData| { &m.city_name },
            |m: &mut MerDetailData| { &mut m.city_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_name",
            |m: &MerDetailData| { &m.type_name },
            |m: &mut MerDetailData| { &mut m.type_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "services_type",
            |m: &MerDetailData| { &m.services_type },
            |m: &mut MerDetailData| { &mut m.services_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_certificate",
            |m: &MerDetailData| { &m.mer_certificate },
            |m: &mut MerDetailData| { &mut m.mer_certificate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerDetailData>(
            "MerDetailData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerDetailData {
    const NAME: &'static str = "MerDetailData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mer_id = is.read_uint32()?;
                },
                16 => {
                    self.category_id = is.read_int32()?;
                },
                24 => {
                    self.type_id = is.read_int32()?;
                },
                34 => {
                    self.mer_name = is.read_string()?;
                },
                42 => {
                    self.mer_adress = is.read_string()?;
                },
                50 => {
                    self.mer_keyword = is.read_string()?;
                },
                58 => {
                    self.mer_avatar = is.read_string()?;
                },
                66 => {
                    self.mer_banner = is.read_string()?;
                },
                74 => {
                    self.mini_banner = is.read_string()?;
                },
                80 => {
                    self.sales = is.read_int32()?;
                },
                90 => {
                    self.product_score = is.read_string()?;
                },
                98 => {
                    self.service_score = is.read_string()?;
                },
                106 => {
                    self.postage_score = is.read_string()?;
                },
                114 => {
                    self.mark = is.read_string()?;
                },
                120 => {
                    self.status = is.read_int32()?;
                },
                130 => {
                    self.commission_rate = is.read_string()?;
                },
                138 => {
                    self.long = is.read_string()?;
                },
                146 => {
                    self.lat = is.read_string()?;
                },
                152 => {
                    self.is_bro_room = is.read_int32()?;
                },
                160 => {
                    self.is_bro_goods = is.read_int32()?;
                },
                168 => {
                    self.is_trader = is.read_int32()?;
                },
                178 => {
                    self.mer_info = is.read_string()?;
                },
                186 => {
                    self.service_phone = is.read_string()?;
                },
                194 => {
                    self.create_time = is.read_string()?;
                },
                200 => {
                    self.care_count = is.read_int32()?;
                },
                208 => {
                    self.copy_product_num = is.read_int32()?;
                },
                216 => {
                    self.export_dump_num = is.read_int32()?;
                },
                226 => {
                    self.mer_money = is.read_string()?;
                },
                234 => {
                    self.sub_mchid = is.read_string()?;
                },
                242 => {
                    self.delivery_way = is.read_string()?;
                },
                250 => {
                    self.margin = is.read_string()?;
                },
                256 => {
                    self.is_margin = is.read_int32()?;
                },
                266 => {
                    self.delivery_balance = is.read_string()?;
                },
                274 => {
                    self.ot_margin = is.read_string()?;
                },
                282 => {
                    self.service_time = is.read_string()?;
                },
                288 => {
                    self.system_city_id = is.read_int32()?;
                },
                296 => {
                    self.care = is.read_bool()?;
                },
                306 => {
                    self.mer_take_address = is.read_string()?;
                },
                314 => {
                    self.province_name = is.read_string()?;
                },
                322 => {
                    self.city_name = is.read_string()?;
                },
                330 => {
                    self.type_name = is.read_string()?;
                },
                346 => {
                    self.services_type = is.read_string()?;
                },
                354 => {
                    self.mer_certificate = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.mer_id);
        }
        if self.category_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.category_id);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.type_id);
        }
        if !self.mer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mer_name);
        }
        if !self.mer_adress.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mer_adress);
        }
        if !self.mer_keyword.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.mer_keyword);
        }
        if !self.mer_avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.mer_avatar);
        }
        if !self.mer_banner.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.mer_banner);
        }
        if !self.mini_banner.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.mini_banner);
        }
        if self.sales != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.sales);
        }
        if !self.product_score.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.product_score);
        }
        if !self.service_score.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.service_score);
        }
        if !self.postage_score.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.postage_score);
        }
        if !self.mark.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.mark);
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::int32_size(15, self.status);
        }
        if !self.commission_rate.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.commission_rate);
        }
        if !self.long.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.long);
        }
        if !self.lat.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.lat);
        }
        if self.is_bro_room != 0 {
            my_size += ::protobuf::rt::int32_size(19, self.is_bro_room);
        }
        if self.is_bro_goods != 0 {
            my_size += ::protobuf::rt::int32_size(20, self.is_bro_goods);
        }
        if self.is_trader != 0 {
            my_size += ::protobuf::rt::int32_size(21, self.is_trader);
        }
        if !self.mer_info.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.mer_info);
        }
        if !self.service_phone.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.service_phone);
        }
        if !self.create_time.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.create_time);
        }
        if self.care_count != 0 {
            my_size += ::protobuf::rt::int32_size(25, self.care_count);
        }
        if self.copy_product_num != 0 {
            my_size += ::protobuf::rt::int32_size(26, self.copy_product_num);
        }
        if self.export_dump_num != 0 {
            my_size += ::protobuf::rt::int32_size(27, self.export_dump_num);
        }
        if !self.mer_money.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.mer_money);
        }
        if !self.sub_mchid.is_empty() {
            my_size += ::protobuf::rt::string_size(29, &self.sub_mchid);
        }
        if !self.delivery_way.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.delivery_way);
        }
        if !self.margin.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.margin);
        }
        if self.is_margin != 0 {
            my_size += ::protobuf::rt::int32_size(32, self.is_margin);
        }
        if !self.delivery_balance.is_empty() {
            my_size += ::protobuf::rt::string_size(33, &self.delivery_balance);
        }
        if !self.ot_margin.is_empty() {
            my_size += ::protobuf::rt::string_size(34, &self.ot_margin);
        }
        if !self.service_time.is_empty() {
            my_size += ::protobuf::rt::string_size(35, &self.service_time);
        }
        if self.system_city_id != 0 {
            my_size += ::protobuf::rt::int32_size(36, self.system_city_id);
        }
        if self.care != false {
            my_size += 2 + 1;
        }
        if !self.mer_take_address.is_empty() {
            my_size += ::protobuf::rt::string_size(38, &self.mer_take_address);
        }
        if !self.province_name.is_empty() {
            my_size += ::protobuf::rt::string_size(39, &self.province_name);
        }
        if !self.city_name.is_empty() {
            my_size += ::protobuf::rt::string_size(40, &self.city_name);
        }
        if !self.type_name.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.type_name);
        }
        if !self.services_type.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.services_type);
        }
        if !self.mer_certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(44, &self.mer_certificate);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mer_id != 0 {
            os.write_uint32(1, self.mer_id)?;
        }
        if self.category_id != 0 {
            os.write_int32(2, self.category_id)?;
        }
        if self.type_id != 0 {
            os.write_int32(3, self.type_id)?;
        }
        if !self.mer_name.is_empty() {
            os.write_string(4, &self.mer_name)?;
        }
        if !self.mer_adress.is_empty() {
            os.write_string(5, &self.mer_adress)?;
        }
        if !self.mer_keyword.is_empty() {
            os.write_string(6, &self.mer_keyword)?;
        }
        if !self.mer_avatar.is_empty() {
            os.write_string(7, &self.mer_avatar)?;
        }
        if !self.mer_banner.is_empty() {
            os.write_string(8, &self.mer_banner)?;
        }
        if !self.mini_banner.is_empty() {
            os.write_string(9, &self.mini_banner)?;
        }
        if self.sales != 0 {
            os.write_int32(10, self.sales)?;
        }
        if !self.product_score.is_empty() {
            os.write_string(11, &self.product_score)?;
        }
        if !self.service_score.is_empty() {
            os.write_string(12, &self.service_score)?;
        }
        if !self.postage_score.is_empty() {
            os.write_string(13, &self.postage_score)?;
        }
        if !self.mark.is_empty() {
            os.write_string(14, &self.mark)?;
        }
        if self.status != 0 {
            os.write_int32(15, self.status)?;
        }
        if !self.commission_rate.is_empty() {
            os.write_string(16, &self.commission_rate)?;
        }
        if !self.long.is_empty() {
            os.write_string(17, &self.long)?;
        }
        if !self.lat.is_empty() {
            os.write_string(18, &self.lat)?;
        }
        if self.is_bro_room != 0 {
            os.write_int32(19, self.is_bro_room)?;
        }
        if self.is_bro_goods != 0 {
            os.write_int32(20, self.is_bro_goods)?;
        }
        if self.is_trader != 0 {
            os.write_int32(21, self.is_trader)?;
        }
        if !self.mer_info.is_empty() {
            os.write_string(22, &self.mer_info)?;
        }
        if !self.service_phone.is_empty() {
            os.write_string(23, &self.service_phone)?;
        }
        if !self.create_time.is_empty() {
            os.write_string(24, &self.create_time)?;
        }
        if self.care_count != 0 {
            os.write_int32(25, self.care_count)?;
        }
        if self.copy_product_num != 0 {
            os.write_int32(26, self.copy_product_num)?;
        }
        if self.export_dump_num != 0 {
            os.write_int32(27, self.export_dump_num)?;
        }
        if !self.mer_money.is_empty() {
            os.write_string(28, &self.mer_money)?;
        }
        if !self.sub_mchid.is_empty() {
            os.write_string(29, &self.sub_mchid)?;
        }
        if !self.delivery_way.is_empty() {
            os.write_string(30, &self.delivery_way)?;
        }
        if !self.margin.is_empty() {
            os.write_string(31, &self.margin)?;
        }
        if self.is_margin != 0 {
            os.write_int32(32, self.is_margin)?;
        }
        if !self.delivery_balance.is_empty() {
            os.write_string(33, &self.delivery_balance)?;
        }
        if !self.ot_margin.is_empty() {
            os.write_string(34, &self.ot_margin)?;
        }
        if !self.service_time.is_empty() {
            os.write_string(35, &self.service_time)?;
        }
        if self.system_city_id != 0 {
            os.write_int32(36, self.system_city_id)?;
        }
        if self.care != false {
            os.write_bool(37, self.care)?;
        }
        if !self.mer_take_address.is_empty() {
            os.write_string(38, &self.mer_take_address)?;
        }
        if !self.province_name.is_empty() {
            os.write_string(39, &self.province_name)?;
        }
        if !self.city_name.is_empty() {
            os.write_string(40, &self.city_name)?;
        }
        if !self.type_name.is_empty() {
            os.write_string(41, &self.type_name)?;
        }
        if !self.services_type.is_empty() {
            os.write_string(43, &self.services_type)?;
        }
        if !self.mer_certificate.is_empty() {
            os.write_string(44, &self.mer_certificate)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerDetailData {
        MerDetailData::new()
    }

    fn clear(&mut self) {
        self.mer_id = 0;
        self.category_id = 0;
        self.type_id = 0;
        self.mer_name.clear();
        self.mer_adress.clear();
        self.mer_keyword.clear();
        self.mer_avatar.clear();
        self.mer_banner.clear();
        self.mini_banner.clear();
        self.sales = 0;
        self.product_score.clear();
        self.service_score.clear();
        self.postage_score.clear();
        self.mark.clear();
        self.status = 0;
        self.commission_rate.clear();
        self.long.clear();
        self.lat.clear();
        self.is_bro_room = 0;
        self.is_bro_goods = 0;
        self.is_trader = 0;
        self.mer_info.clear();
        self.service_phone.clear();
        self.create_time.clear();
        self.care_count = 0;
        self.copy_product_num = 0;
        self.export_dump_num = 0;
        self.mer_money.clear();
        self.sub_mchid.clear();
        self.delivery_way.clear();
        self.margin.clear();
        self.is_margin = 0;
        self.delivery_balance.clear();
        self.ot_margin.clear();
        self.service_time.clear();
        self.system_city_id = 0;
        self.care = false;
        self.mer_take_address.clear();
        self.province_name.clear();
        self.city_name.clear();
        self.type_name.clear();
        self.services_type.clear();
        self.mer_certificate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerDetailData {
        static instance: MerDetailData = MerDetailData {
            mer_id: 0,
            category_id: 0,
            type_id: 0,
            mer_name: ::std::string::String::new(),
            mer_adress: ::std::string::String::new(),
            mer_keyword: ::std::string::String::new(),
            mer_avatar: ::std::string::String::new(),
            mer_banner: ::std::string::String::new(),
            mini_banner: ::std::string::String::new(),
            sales: 0,
            product_score: ::std::string::String::new(),
            service_score: ::std::string::String::new(),
            postage_score: ::std::string::String::new(),
            mark: ::std::string::String::new(),
            status: 0,
            commission_rate: ::std::string::String::new(),
            long: ::std::string::String::new(),
            lat: ::std::string::String::new(),
            is_bro_room: 0,
            is_bro_goods: 0,
            is_trader: 0,
            mer_info: ::std::string::String::new(),
            service_phone: ::std::string::String::new(),
            create_time: ::std::string::String::new(),
            care_count: 0,
            copy_product_num: 0,
            export_dump_num: 0,
            mer_money: ::std::string::String::new(),
            sub_mchid: ::std::string::String::new(),
            delivery_way: ::std::string::String::new(),
            margin: ::std::string::String::new(),
            is_margin: 0,
            delivery_balance: ::std::string::String::new(),
            ot_margin: ::std::string::String::new(),
            service_time: ::std::string::String::new(),
            system_city_id: 0,
            care: false,
            mer_take_address: ::std::string::String::new(),
            province_name: ::std::string::String::new(),
            city_name: ::std::string::String::new(),
            type_name: ::std::string::String::new(),
            services_type: ::std::string::String::new(),
            mer_certificate: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerDetailData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerDetailData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerDetailData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerDetailData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CategoryListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CategoryListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CategoryListReq.mer_id)
    pub mer_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CategoryListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CategoryListReq {
    fn default() -> &'a CategoryListReq {
        <CategoryListReq as ::protobuf::Message>::default_instance()
    }
}

impl CategoryListReq {
    pub fn new() -> CategoryListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &CategoryListReq| { &m.mer_id },
            |m: &mut CategoryListReq| { &mut m.mer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryListReq>(
            "CategoryListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CategoryListReq {
    const NAME: &'static str = "CategoryListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mer_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.mer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mer_id != 0 {
            os.write_int32(1, self.mer_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CategoryListReq {
        CategoryListReq::new()
    }

    fn clear(&mut self) {
        self.mer_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CategoryListReq {
        static instance: CategoryListReq = CategoryListReq {
            mer_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CategoryListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CategoryListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CategoryListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CategoryListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CategoryListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CategoryListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CategoryListRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CategoryListRsp.data)
    pub data: ::std::vec::Vec<CategoryData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CategoryListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CategoryListRsp {
    fn default() -> &'a CategoryListRsp {
        <CategoryListRsp as ::protobuf::Message>::default_instance()
    }
}

impl CategoryListRsp {
    pub fn new() -> CategoryListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CategoryListRsp| { &m.ret },
            |m: &mut CategoryListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &CategoryListRsp| { &m.msg },
            |m: &mut CategoryListRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &CategoryListRsp| { &m.data },
            |m: &mut CategoryListRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryListRsp>(
            "CategoryListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CategoryListRsp {
    const NAME: &'static str = "CategoryListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CategoryListRsp {
        CategoryListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CategoryListRsp {
        static instance: CategoryListRsp = CategoryListRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CategoryListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CategoryListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CategoryListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CategoryData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CategoryData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CategoryData.store_category_id)
    pub store_category_id: i32,
    // @@protoc_insertion_point(field:pbdef.CategoryData.cate_name)
    pub cate_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CategoryData.data)
    pub data: ::std::vec::Vec<CategoryData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CategoryData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CategoryData {
    fn default() -> &'a CategoryData {
        <CategoryData as ::protobuf::Message>::default_instance()
    }
}

impl CategoryData {
    pub fn new() -> CategoryData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "store_category_id",
            |m: &CategoryData| { &m.store_category_id },
            |m: &mut CategoryData| { &mut m.store_category_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cate_name",
            |m: &CategoryData| { &m.cate_name },
            |m: &mut CategoryData| { &mut m.cate_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &CategoryData| { &m.data },
            |m: &mut CategoryData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryData>(
            "CategoryData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CategoryData {
    const NAME: &'static str = "CategoryData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.store_category_id = is.read_int32()?;
                },
                18 => {
                    self.cate_name = is.read_string()?;
                },
                26 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.store_category_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.store_category_id);
        }
        if !self.cate_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cate_name);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.store_category_id != 0 {
            os.write_int32(1, self.store_category_id)?;
        }
        if !self.cate_name.is_empty() {
            os.write_string(2, &self.cate_name)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CategoryData {
        CategoryData::new()
    }

    fn clear(&mut self) {
        self.store_category_id = 0;
        self.cate_name.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CategoryData {
        static instance: CategoryData = CategoryData {
            store_category_id: 0,
            cate_name: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CategoryData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CategoryData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CategoryData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CategoryDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CategoryDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CategoryDetailReq.mer_id)
    pub mer_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CategoryDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CategoryDetailReq {
    fn default() -> &'a CategoryDetailReq {
        <CategoryDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl CategoryDetailReq {
    pub fn new() -> CategoryDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &CategoryDetailReq| { &m.mer_id },
            |m: &mut CategoryDetailReq| { &mut m.mer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryDetailReq>(
            "CategoryDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CategoryDetailReq {
    const NAME: &'static str = "CategoryDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mer_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.mer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mer_id != 0 {
            os.write_uint32(1, self.mer_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CategoryDetailReq {
        CategoryDetailReq::new()
    }

    fn clear(&mut self) {
        self.mer_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CategoryDetailReq {
        static instance: CategoryDetailReq = CategoryDetailReq {
            mer_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CategoryDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CategoryDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CategoryDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CategoryDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CategoryDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CategoryDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CategoryDetailRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CategoryDetailRsp.data)
    pub data: ::protobuf::MessageField<CateDetailData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CategoryDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CategoryDetailRsp {
    fn default() -> &'a CategoryDetailRsp {
        <CategoryDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl CategoryDetailRsp {
    pub fn new() -> CategoryDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CategoryDetailRsp| { &m.ret },
            |m: &mut CategoryDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &CategoryDetailRsp| { &m.msg },
            |m: &mut CategoryDetailRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CateDetailData>(
            "data",
            |m: &CategoryDetailRsp| { &m.data },
            |m: &mut CategoryDetailRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CategoryDetailRsp>(
            "CategoryDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CategoryDetailRsp {
    const NAME: &'static str = "CategoryDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CategoryDetailRsp {
        CategoryDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CategoryDetailRsp {
        static instance: CategoryDetailRsp = CategoryDetailRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CategoryDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CategoryDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CategoryDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoryDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CateDetailData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CateDetailData {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CateDetailData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CateDetailData {
    fn default() -> &'a CateDetailData {
        <CateDetailData as ::protobuf::Message>::default_instance()
    }
}

impl CateDetailData {
    pub fn new() -> CateDetailData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CateDetailData>(
            "CateDetailData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CateDetailData {
    const NAME: &'static str = "CateDetailData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CateDetailData {
        CateDetailData::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CateDetailData {
        static instance: CateDetailData = CateDetailData {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CateDetailData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CateDetailData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CateDetailData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CateDetailData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductListReq.mer_id)
    pub mer_id: u32,
    // @@protoc_insertion_point(field:pbdef.ProductListReq.order)
    pub order: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductListReq.mer_cate_id)
    pub mer_cate_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductListReq.page)
    pub page: i32,
    // @@protoc_insertion_point(field:pbdef.ProductListReq.limit)
    pub limit: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductListReq {
    fn default() -> &'a ProductListReq {
        <ProductListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProductListReq {
    pub fn new() -> ProductListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &ProductListReq| { &m.mer_id },
            |m: &mut ProductListReq| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order",
            |m: &ProductListReq| { &m.order },
            |m: &mut ProductListReq| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_cate_id",
            |m: &ProductListReq| { &m.mer_cate_id },
            |m: &mut ProductListReq| { &mut m.mer_cate_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &ProductListReq| { &m.page },
            |m: &mut ProductListReq| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ProductListReq| { &m.limit },
            |m: &mut ProductListReq| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductListReq>(
            "ProductListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductListReq {
    const NAME: &'static str = "ProductListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mer_id = is.read_uint32()?;
                },
                18 => {
                    self.order = is.read_string()?;
                },
                24 => {
                    self.mer_cate_id = is.read_int32()?;
                },
                32 => {
                    self.page = is.read_int32()?;
                },
                40 => {
                    self.limit = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.mer_id);
        }
        if !self.order.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order);
        }
        if self.mer_cate_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.mer_cate_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.page);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mer_id != 0 {
            os.write_uint32(1, self.mer_id)?;
        }
        if !self.order.is_empty() {
            os.write_string(2, &self.order)?;
        }
        if self.mer_cate_id != 0 {
            os.write_int32(3, self.mer_cate_id)?;
        }
        if self.page != 0 {
            os.write_int32(4, self.page)?;
        }
        if self.limit != 0 {
            os.write_int32(5, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductListReq {
        ProductListReq::new()
    }

    fn clear(&mut self) {
        self.mer_id = 0;
        self.order.clear();
        self.mer_cate_id = 0;
        self.page = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductListReq {
        static instance: ProductListReq = ProductListReq {
            mer_id: 0,
            order: ::std::string::String::new(),
            mer_cate_id: 0,
            page: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.ProductListRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductListRsp.data)
    pub data: ::protobuf::MessageField<ProductData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductListRsp {
    fn default() -> &'a ProductListRsp {
        <ProductListRsp as ::protobuf::Message>::default_instance()
    }
}

impl ProductListRsp {
    pub fn new() -> ProductListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ProductListRsp| { &m.ret },
            |m: &mut ProductListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &ProductListRsp| { &m.msg },
            |m: &mut ProductListRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductData>(
            "data",
            |m: &ProductListRsp| { &m.data },
            |m: &mut ProductListRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductListRsp>(
            "ProductListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductListRsp {
    const NAME: &'static str = "ProductListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductListRsp {
        ProductListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductListRsp {
        static instance: ProductListRsp = ProductListRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductData.count)
    pub count: i32,
    // @@protoc_insertion_point(field:pbdef.ProductData.list)
    pub list: ::std::vec::Vec<ProductItem>,
    // @@protoc_insertion_point(field:pbdef.ProductData.mer_chant_info)
    pub mer_chant_info: ::protobuf::MessageField<MerChantSimpleData>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductData {
    fn default() -> &'a ProductData {
        <ProductData as ::protobuf::Message>::default_instance()
    }
}

impl ProductData {
    pub fn new() -> ProductData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &ProductData| { &m.count },
            |m: &mut ProductData| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "list",
            |m: &ProductData| { &m.list },
            |m: &mut ProductData| { &mut m.list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MerChantSimpleData>(
            "mer_chant_info",
            |m: &ProductData| { &m.mer_chant_info },
            |m: &mut ProductData| { &mut m.mer_chant_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductData>(
            "ProductData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductData {
    const NAME: &'static str = "ProductData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = is.read_int32()?;
                },
                18 => {
                    self.list.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mer_chant_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.count);
        }
        for value in &self.list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.mer_chant_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_int32(1, self.count)?;
        }
        for v in &self.list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.mer_chant_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductData {
        ProductData::new()
    }

    fn clear(&mut self) {
        self.count = 0;
        self.list.clear();
        self.mer_chant_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductData {
        static instance: ProductData = ProductData {
            count: 0,
            list: ::std::vec::Vec::new(),
            mer_chant_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerChantSimpleData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerChantSimpleData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.is_trader)
    pub is_trader: i32,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.type_id)
    pub type_id: i32,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.mer_id)
    pub mer_id: i32,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.mer_name)
    pub mer_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.mer_avatar)
    pub mer_avatar: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.product_score)
    pub product_score: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.service_score)
    pub service_score: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.postage_score)
    pub postage_score: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.service_phone)
    pub service_phone: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerChantSimpleData.care_count)
    pub care_count: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerChantSimpleData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerChantSimpleData {
    fn default() -> &'a MerChantSimpleData {
        <MerChantSimpleData as ::protobuf::Message>::default_instance()
    }
}

impl MerChantSimpleData {
    pub fn new() -> MerChantSimpleData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_trader",
            |m: &MerChantSimpleData| { &m.is_trader },
            |m: &mut MerChantSimpleData| { &mut m.is_trader },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &MerChantSimpleData| { &m.type_id },
            |m: &mut MerChantSimpleData| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &MerChantSimpleData| { &m.mer_id },
            |m: &mut MerChantSimpleData| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_name",
            |m: &MerChantSimpleData| { &m.mer_name },
            |m: &mut MerChantSimpleData| { &mut m.mer_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_avatar",
            |m: &MerChantSimpleData| { &m.mer_avatar },
            |m: &mut MerChantSimpleData| { &mut m.mer_avatar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_score",
            |m: &MerChantSimpleData| { &m.product_score },
            |m: &mut MerChantSimpleData| { &mut m.product_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_score",
            |m: &MerChantSimpleData| { &m.service_score },
            |m: &mut MerChantSimpleData| { &mut m.service_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "postage_score",
            |m: &MerChantSimpleData| { &m.postage_score },
            |m: &mut MerChantSimpleData| { &mut m.postage_score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service_phone",
            |m: &MerChantSimpleData| { &m.service_phone },
            |m: &mut MerChantSimpleData| { &mut m.service_phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "care_count",
            |m: &MerChantSimpleData| { &m.care_count },
            |m: &mut MerChantSimpleData| { &mut m.care_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerChantSimpleData>(
            "MerChantSimpleData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerChantSimpleData {
    const NAME: &'static str = "MerChantSimpleData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_trader = is.read_int32()?;
                },
                16 => {
                    self.type_id = is.read_int32()?;
                },
                24 => {
                    self.mer_id = is.read_int32()?;
                },
                34 => {
                    self.mer_name = is.read_string()?;
                },
                42 => {
                    self.mer_avatar = is.read_string()?;
                },
                50 => {
                    self.product_score = is.read_string()?;
                },
                58 => {
                    self.service_score = is.read_string()?;
                },
                66 => {
                    self.postage_score = is.read_string()?;
                },
                74 => {
                    self.service_phone = is.read_string()?;
                },
                80 => {
                    self.care_count = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.is_trader != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.is_trader);
        }
        if self.type_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.type_id);
        }
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.mer_id);
        }
        if !self.mer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.mer_name);
        }
        if !self.mer_avatar.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.mer_avatar);
        }
        if !self.product_score.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.product_score);
        }
        if !self.service_score.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.service_score);
        }
        if !self.postage_score.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.postage_score);
        }
        if !self.service_phone.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.service_phone);
        }
        if self.care_count != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.care_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.is_trader != 0 {
            os.write_int32(1, self.is_trader)?;
        }
        if self.type_id != 0 {
            os.write_int32(2, self.type_id)?;
        }
        if self.mer_id != 0 {
            os.write_int32(3, self.mer_id)?;
        }
        if !self.mer_name.is_empty() {
            os.write_string(4, &self.mer_name)?;
        }
        if !self.mer_avatar.is_empty() {
            os.write_string(5, &self.mer_avatar)?;
        }
        if !self.product_score.is_empty() {
            os.write_string(6, &self.product_score)?;
        }
        if !self.service_score.is_empty() {
            os.write_string(7, &self.service_score)?;
        }
        if !self.postage_score.is_empty() {
            os.write_string(8, &self.postage_score)?;
        }
        if !self.service_phone.is_empty() {
            os.write_string(9, &self.service_phone)?;
        }
        if self.care_count != 0 {
            os.write_int32(10, self.care_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerChantSimpleData {
        MerChantSimpleData::new()
    }

    fn clear(&mut self) {
        self.is_trader = 0;
        self.type_id = 0;
        self.mer_id = 0;
        self.mer_name.clear();
        self.mer_avatar.clear();
        self.product_score.clear();
        self.service_score.clear();
        self.postage_score.clear();
        self.service_phone.clear();
        self.care_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerChantSimpleData {
        static instance: MerChantSimpleData = MerChantSimpleData {
            is_trader: 0,
            type_id: 0,
            mer_id: 0,
            mer_name: ::std::string::String::new(),
            mer_avatar: ::std::string::String::new(),
            product_score: ::std::string::String::new(),
            service_score: ::std::string::String::new(),
            postage_score: ::std::string::String::new(),
            service_phone: ::std::string::String::new(),
            care_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerChantSimpleData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerChantSimpleData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerChantSimpleData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerChantSimpleData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductItem.expiration_time)
    pub expiration_time: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.product_id)
    pub product_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.mer_id)
    pub mer_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.brand_id)
    pub brand_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.spec_type)
    pub spec_type: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.unit_name)
    pub unit_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.mer_status)
    pub mer_status: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.rate)
    pub rate: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.reply_count)
    pub reply_count: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.store_info)
    pub store_info: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.cate_id)
    pub cate_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.iamge)
    pub iamge: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.slider_image)
    pub slider_image: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.store_name)
    pub store_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.sales)
    pub sales: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.price)
    pub price: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductItem.stock)
    pub stock: i32,
    // @@protoc_insertion_point(field:pbdef.ProductItem.product_type)
    pub product_type: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductItem {
    fn default() -> &'a ProductItem {
        <ProductItem as ::protobuf::Message>::default_instance()
    }
}

impl ProductItem {
    pub fn new() -> ProductItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expiration_time",
            |m: &ProductItem| { &m.expiration_time },
            |m: &mut ProductItem| { &mut m.expiration_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_id",
            |m: &ProductItem| { &m.product_id },
            |m: &mut ProductItem| { &mut m.product_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &ProductItem| { &m.mer_id },
            |m: &mut ProductItem| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brand_id",
            |m: &ProductItem| { &m.brand_id },
            |m: &mut ProductItem| { &mut m.brand_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ProductItem| { &m.type_ },
            |m: &mut ProductItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spec_type",
            |m: &ProductItem| { &m.spec_type },
            |m: &mut ProductItem| { &mut m.spec_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_name",
            |m: &ProductItem| { &m.unit_name },
            |m: &mut ProductItem| { &mut m.unit_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_status",
            |m: &ProductItem| { &m.mer_status },
            |m: &mut ProductItem| { &mut m.mer_status },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rate",
            |m: &ProductItem| { &m.rate },
            |m: &mut ProductItem| { &mut m.rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reply_count",
            |m: &ProductItem| { &m.reply_count },
            |m: &mut ProductItem| { &mut m.reply_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "store_info",
            |m: &ProductItem| { &m.store_info },
            |m: &mut ProductItem| { &mut m.store_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cate_id",
            |m: &ProductItem| { &m.cate_id },
            |m: &mut ProductItem| { &mut m.cate_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iamge",
            |m: &ProductItem| { &m.iamge },
            |m: &mut ProductItem| { &mut m.iamge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "slider_image",
            |m: &ProductItem| { &m.slider_image },
            |m: &mut ProductItem| { &mut m.slider_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "store_name",
            |m: &ProductItem| { &m.store_name },
            |m: &mut ProductItem| { &mut m.store_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sales",
            |m: &ProductItem| { &m.sales },
            |m: &mut ProductItem| { &mut m.sales },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &ProductItem| { &m.price },
            |m: &mut ProductItem| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stock",
            |m: &ProductItem| { &m.stock },
            |m: &mut ProductItem| { &mut m.stock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_type",
            |m: &ProductItem| { &m.product_type },
            |m: &mut ProductItem| { &mut m.product_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductItem>(
            "ProductItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductItem {
    const NAME: &'static str = "ProductItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.expiration_time = is.read_int32()?;
                },
                16 => {
                    self.product_id = is.read_int32()?;
                },
                24 => {
                    self.mer_id = is.read_int32()?;
                },
                32 => {
                    self.brand_id = is.read_int32()?;
                },
                40 => {
                    self.type_ = is.read_int32()?;
                },
                48 => {
                    self.spec_type = is.read_int32()?;
                },
                58 => {
                    self.unit_name = is.read_string()?;
                },
                64 => {
                    self.mer_status = is.read_int32()?;
                },
                74 => {
                    self.rate = is.read_string()?;
                },
                80 => {
                    self.reply_count = is.read_int32()?;
                },
                90 => {
                    self.store_info = is.read_string()?;
                },
                96 => {
                    self.cate_id = is.read_int32()?;
                },
                106 => {
                    self.iamge = is.read_string()?;
                },
                114 => {
                    self.slider_image = is.read_string()?;
                },
                122 => {
                    self.store_name = is.read_string()?;
                },
                128 => {
                    self.sales = is.read_int32()?;
                },
                138 => {
                    self.price = is.read_string()?;
                },
                144 => {
                    self.stock = is.read_int32()?;
                },
                152 => {
                    self.product_type = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.expiration_time != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.expiration_time);
        }
        if self.product_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.product_id);
        }
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.mer_id);
        }
        if self.brand_id != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.brand_id);
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.type_);
        }
        if self.spec_type != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.spec_type);
        }
        if !self.unit_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.unit_name);
        }
        if self.mer_status != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.mer_status);
        }
        if !self.rate.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.rate);
        }
        if self.reply_count != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.reply_count);
        }
        if !self.store_info.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.store_info);
        }
        if self.cate_id != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.cate_id);
        }
        if !self.iamge.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.iamge);
        }
        if !self.slider_image.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.slider_image);
        }
        if !self.store_name.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.store_name);
        }
        if self.sales != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.sales);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.price);
        }
        if self.stock != 0 {
            my_size += ::protobuf::rt::int32_size(18, self.stock);
        }
        if self.product_type != 0 {
            my_size += ::protobuf::rt::int32_size(19, self.product_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.expiration_time != 0 {
            os.write_int32(1, self.expiration_time)?;
        }
        if self.product_id != 0 {
            os.write_int32(2, self.product_id)?;
        }
        if self.mer_id != 0 {
            os.write_int32(3, self.mer_id)?;
        }
        if self.brand_id != 0 {
            os.write_int32(4, self.brand_id)?;
        }
        if self.type_ != 0 {
            os.write_int32(5, self.type_)?;
        }
        if self.spec_type != 0 {
            os.write_int32(6, self.spec_type)?;
        }
        if !self.unit_name.is_empty() {
            os.write_string(7, &self.unit_name)?;
        }
        if self.mer_status != 0 {
            os.write_int32(8, self.mer_status)?;
        }
        if !self.rate.is_empty() {
            os.write_string(9, &self.rate)?;
        }
        if self.reply_count != 0 {
            os.write_int32(10, self.reply_count)?;
        }
        if !self.store_info.is_empty() {
            os.write_string(11, &self.store_info)?;
        }
        if self.cate_id != 0 {
            os.write_int32(12, self.cate_id)?;
        }
        if !self.iamge.is_empty() {
            os.write_string(13, &self.iamge)?;
        }
        if !self.slider_image.is_empty() {
            os.write_string(14, &self.slider_image)?;
        }
        if !self.store_name.is_empty() {
            os.write_string(15, &self.store_name)?;
        }
        if self.sales != 0 {
            os.write_int32(16, self.sales)?;
        }
        if !self.price.is_empty() {
            os.write_string(17, &self.price)?;
        }
        if self.stock != 0 {
            os.write_int32(18, self.stock)?;
        }
        if self.product_type != 0 {
            os.write_int32(19, self.product_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductItem {
        ProductItem::new()
    }

    fn clear(&mut self) {
        self.expiration_time = 0;
        self.product_id = 0;
        self.mer_id = 0;
        self.brand_id = 0;
        self.type_ = 0;
        self.spec_type = 0;
        self.unit_name.clear();
        self.mer_status = 0;
        self.rate.clear();
        self.reply_count = 0;
        self.store_info.clear();
        self.cate_id = 0;
        self.iamge.clear();
        self.slider_image.clear();
        self.store_name.clear();
        self.sales = 0;
        self.price.clear();
        self.stock = 0;
        self.product_type = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductItem {
        static instance: ProductItem = ProductItem {
            expiration_time: 0,
            product_id: 0,
            mer_id: 0,
            brand_id: 0,
            type_: 0,
            spec_type: 0,
            unit_name: ::std::string::String::new(),
            mer_status: 0,
            rate: ::std::string::String::new(),
            reply_count: 0,
            store_info: ::std::string::String::new(),
            cate_id: 0,
            iamge: ::std::string::String::new(),
            slider_image: ::std::string::String::new(),
            store_name: ::std::string::String::new(),
            sales: 0,
            price: ::std::string::String::new(),
            stock: 0,
            product_type: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductDetailReq.pro_id)
    pub pro_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductDetailReq {
    fn default() -> &'a ProductDetailReq {
        <ProductDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl ProductDetailReq {
    pub fn new() -> ProductDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pro_id",
            |m: &ProductDetailReq| { &m.pro_id },
            |m: &mut ProductDetailReq| { &mut m.pro_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductDetailReq>(
            "ProductDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductDetailReq {
    const NAME: &'static str = "ProductDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pro_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pro_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.pro_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pro_id != 0 {
            os.write_int32(1, self.pro_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductDetailReq {
        ProductDetailReq::new()
    }

    fn clear(&mut self) {
        self.pro_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductDetailReq {
        static instance: ProductDetailReq = ProductDetailReq {
            pro_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.ProductDetailRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductDetailRsp.data)
    pub data: ::protobuf::MessageField<ProductItem>,
    // @@protoc_insertion_point(field:pbdef.ProductDetailRsp.sku_list)
    pub sku_list: ::std::vec::Vec<ProductSkuAttrItem>,
    // @@protoc_insertion_point(field:pbdef.ProductDetailRsp.content)
    pub content: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductDetailRsp {
    fn default() -> &'a ProductDetailRsp {
        <ProductDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl ProductDetailRsp {
    pub fn new() -> ProductDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ProductDetailRsp| { &m.ret },
            |m: &mut ProductDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &ProductDetailRsp| { &m.msg },
            |m: &mut ProductDetailRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductItem>(
            "data",
            |m: &ProductDetailRsp| { &m.data },
            |m: &mut ProductDetailRsp| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sku_list",
            |m: &ProductDetailRsp| { &m.sku_list },
            |m: &mut ProductDetailRsp| { &mut m.sku_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &ProductDetailRsp| { &m.content },
            |m: &mut ProductDetailRsp| { &mut m.content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductDetailRsp>(
            "ProductDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductDetailRsp {
    const NAME: &'static str = "ProductDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                34 => {
                    self.sku_list.push(is.read_message()?);
                },
                42 => {
                    self.content = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.sku_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.sku_list {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if !self.content.is_empty() {
            os.write_string(5, &self.content)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductDetailRsp {
        ProductDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.data.clear();
        self.sku_list.clear();
        self.content.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductDetailRsp {
        static instance: ProductDetailRsp = ProductDetailRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            data: ::protobuf::MessageField::none(),
            sku_list: ::std::vec::Vec::new(),
            content: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductSkuListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductSkuListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductSkuListReq.pro_id)
    pub pro_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductSkuListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSkuListReq {
    fn default() -> &'a ProductSkuListReq {
        <ProductSkuListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProductSkuListReq {
    pub fn new() -> ProductSkuListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pro_id",
            |m: &ProductSkuListReq| { &m.pro_id },
            |m: &mut ProductSkuListReq| { &mut m.pro_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSkuListReq>(
            "ProductSkuListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSkuListReq {
    const NAME: &'static str = "ProductSkuListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pro_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pro_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.pro_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pro_id != 0 {
            os.write_int32(1, self.pro_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSkuListReq {
        ProductSkuListReq::new()
    }

    fn clear(&mut self) {
        self.pro_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSkuListReq {
        static instance: ProductSkuListReq = ProductSkuListReq {
            pro_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSkuListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSkuListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSkuListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSkuListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductSkuListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductSkuListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductSkuListRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductSkuListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSkuListRsp {
    fn default() -> &'a ProductSkuListRsp {
        <ProductSkuListRsp as ::protobuf::Message>::default_instance()
    }
}

impl ProductSkuListRsp {
    pub fn new() -> ProductSkuListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ProductSkuListRsp| { &m.ret },
            |m: &mut ProductSkuListRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSkuListRsp>(
            "ProductSkuListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSkuListRsp {
    const NAME: &'static str = "ProductSkuListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSkuListRsp {
        ProductSkuListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSkuListRsp {
        static instance: ProductSkuListRsp = ProductSkuListRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSkuListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSkuListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSkuListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSkuListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductSkuAttrItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductSkuAttrItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductSkuAttrItem.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductSkuAttrItem.attr)
    pub attr: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductSkuAttrItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSkuAttrItem {
    fn default() -> &'a ProductSkuAttrItem {
        <ProductSkuAttrItem as ::protobuf::Message>::default_instance()
    }
}

impl ProductSkuAttrItem {
    pub fn new() -> ProductSkuAttrItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ProductSkuAttrItem| { &m.name },
            |m: &mut ProductSkuAttrItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "attr",
            |m: &ProductSkuAttrItem| { &m.attr },
            |m: &mut ProductSkuAttrItem| { &mut m.attr },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSkuAttrItem>(
            "ProductSkuAttrItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSkuAttrItem {
    const NAME: &'static str = "ProductSkuAttrItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.attr.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.attr {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.attr {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSkuAttrItem {
        ProductSkuAttrItem::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.attr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSkuAttrItem {
        static instance: ProductSkuAttrItem = ProductSkuAttrItem {
            name: ::std::string::String::new(),
            attr: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSkuAttrItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSkuAttrItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSkuAttrItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSkuAttrItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductContentReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductContentReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductContentReq.pro_id)
    pub pro_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductContentReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductContentReq {
    fn default() -> &'a ProductContentReq {
        <ProductContentReq as ::protobuf::Message>::default_instance()
    }
}

impl ProductContentReq {
    pub fn new() -> ProductContentReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pro_id",
            |m: &ProductContentReq| { &m.pro_id },
            |m: &mut ProductContentReq| { &mut m.pro_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductContentReq>(
            "ProductContentReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductContentReq {
    const NAME: &'static str = "ProductContentReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pro_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pro_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.pro_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pro_id != 0 {
            os.write_int32(1, self.pro_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductContentReq {
        ProductContentReq::new()
    }

    fn clear(&mut self) {
        self.pro_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductContentReq {
        static instance: ProductContentReq = ProductContentReq {
            pro_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductContentReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductContentReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductContentReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductContentReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductContentRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductContentRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductContentRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.ProductContentRsp.content)
    pub content: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductContentRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductContentRsp {
    fn default() -> &'a ProductContentRsp {
        <ProductContentRsp as ::protobuf::Message>::default_instance()
    }
}

impl ProductContentRsp {
    pub fn new() -> ProductContentRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ProductContentRsp| { &m.ret },
            |m: &mut ProductContentRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &ProductContentRsp| { &m.content },
            |m: &mut ProductContentRsp| { &mut m.content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductContentRsp>(
            "ProductContentRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductContentRsp {
    const NAME: &'static str = "ProductContentRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.content = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductContentRsp {
        ProductContentRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.content.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductContentRsp {
        static instance: ProductContentRsp = ProductContentRsp {
            ret: 0,
            content: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductContentRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductContentRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductContentRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductContentRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductSkuDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductSkuDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductSkuDetailReq.pro_id)
    pub pro_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuDetailReq.sku)
    pub sku: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductSkuDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSkuDetailReq {
    fn default() -> &'a ProductSkuDetailReq {
        <ProductSkuDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl ProductSkuDetailReq {
    pub fn new() -> ProductSkuDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pro_id",
            |m: &ProductSkuDetailReq| { &m.pro_id },
            |m: &mut ProductSkuDetailReq| { &mut m.pro_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sku",
            |m: &ProductSkuDetailReq| { &m.sku },
            |m: &mut ProductSkuDetailReq| { &mut m.sku },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSkuDetailReq>(
            "ProductSkuDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSkuDetailReq {
    const NAME: &'static str = "ProductSkuDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pro_id = is.read_int32()?;
                },
                18 => {
                    self.sku = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.pro_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.pro_id);
        }
        if !self.sku.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.sku);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.pro_id != 0 {
            os.write_int32(1, self.pro_id)?;
        }
        if !self.sku.is_empty() {
            os.write_string(2, &self.sku)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSkuDetailReq {
        ProductSkuDetailReq::new()
    }

    fn clear(&mut self) {
        self.pro_id = 0;
        self.sku.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSkuDetailReq {
        static instance: ProductSkuDetailReq = ProductSkuDetailReq {
            pro_id: 0,
            sku: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSkuDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSkuDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSkuDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSkuDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductSkuDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductSkuDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductSkuDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuDetailRsp.sku_data)
    pub sku_data: ::protobuf::MessageField<ProductSkuItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductSkuDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSkuDetailRsp {
    fn default() -> &'a ProductSkuDetailRsp {
        <ProductSkuDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl ProductSkuDetailRsp {
    pub fn new() -> ProductSkuDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ProductSkuDetailRsp| { &m.ret },
            |m: &mut ProductSkuDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductSkuItem>(
            "sku_data",
            |m: &ProductSkuDetailRsp| { &m.sku_data },
            |m: &mut ProductSkuDetailRsp| { &mut m.sku_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSkuDetailRsp>(
            "ProductSkuDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSkuDetailRsp {
    const NAME: &'static str = "ProductSkuDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sku_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.sku_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.sku_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSkuDetailRsp {
        ProductSkuDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.sku_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSkuDetailRsp {
        static instance: ProductSkuDetailRsp = ProductSkuDetailRsp {
            ret: 0,
            sku_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSkuDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSkuDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSkuDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSkuDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductSkuItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductSkuItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.product_id)
    pub product_id: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.imgage)
    pub imgage: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.integral)
    pub integral: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.ot_price)
    pub ot_price: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.price)
    pub price: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.stock)
    pub stock: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.sales)
    pub sales: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.ProductSkuItem.unique)
    pub unique: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductSkuItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductSkuItem {
    fn default() -> &'a ProductSkuItem {
        <ProductSkuItem as ::protobuf::Message>::default_instance()
    }
}

impl ProductSkuItem {
    pub fn new() -> ProductSkuItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_id",
            |m: &ProductSkuItem| { &m.product_id },
            |m: &mut ProductSkuItem| { &mut m.product_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "imgage",
            |m: &ProductSkuItem| { &m.imgage },
            |m: &mut ProductSkuItem| { &mut m.imgage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "integral",
            |m: &ProductSkuItem| { &m.integral },
            |m: &mut ProductSkuItem| { &mut m.integral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ot_price",
            |m: &ProductSkuItem| { &m.ot_price },
            |m: &mut ProductSkuItem| { &mut m.ot_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &ProductSkuItem| { &m.price },
            |m: &mut ProductSkuItem| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stock",
            |m: &ProductSkuItem| { &m.stock },
            |m: &mut ProductSkuItem| { &mut m.stock },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sales",
            |m: &ProductSkuItem| { &m.sales },
            |m: &mut ProductSkuItem| { &mut m.sales },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ProductSkuItem| { &m.type_ },
            |m: &mut ProductSkuItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique",
            |m: &ProductSkuItem| { &m.unique },
            |m: &mut ProductSkuItem| { &mut m.unique },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductSkuItem>(
            "ProductSkuItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductSkuItem {
    const NAME: &'static str = "ProductSkuItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.product_id = is.read_int32()?;
                },
                18 => {
                    self.imgage = is.read_string()?;
                },
                32 => {
                    self.integral = is.read_int32()?;
                },
                42 => {
                    self.ot_price = is.read_string()?;
                },
                50 => {
                    self.price = is.read_string()?;
                },
                56 => {
                    self.stock = is.read_int32()?;
                },
                64 => {
                    self.sales = is.read_int32()?;
                },
                72 => {
                    self.type_ = is.read_int32()?;
                },
                82 => {
                    self.unique = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.product_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.product_id);
        }
        if !self.imgage.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.imgage);
        }
        if self.integral != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.integral);
        }
        if !self.ot_price.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.ot_price);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.price);
        }
        if self.stock != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.stock);
        }
        if self.sales != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.sales);
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.type_);
        }
        if !self.unique.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.unique);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.product_id != 0 {
            os.write_int32(1, self.product_id)?;
        }
        if !self.imgage.is_empty() {
            os.write_string(2, &self.imgage)?;
        }
        if self.integral != 0 {
            os.write_int32(4, self.integral)?;
        }
        if !self.ot_price.is_empty() {
            os.write_string(5, &self.ot_price)?;
        }
        if !self.price.is_empty() {
            os.write_string(6, &self.price)?;
        }
        if self.stock != 0 {
            os.write_int32(7, self.stock)?;
        }
        if self.sales != 0 {
            os.write_int32(8, self.sales)?;
        }
        if self.type_ != 0 {
            os.write_int32(9, self.type_)?;
        }
        if !self.unique.is_empty() {
            os.write_string(10, &self.unique)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductSkuItem {
        ProductSkuItem::new()
    }

    fn clear(&mut self) {
        self.product_id = 0;
        self.imgage.clear();
        self.integral = 0;
        self.ot_price.clear();
        self.price.clear();
        self.stock = 0;
        self.sales = 0;
        self.type_ = 0;
        self.unique.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductSkuItem {
        static instance: ProductSkuItem = ProductSkuItem {
            product_id: 0,
            imgage: ::std::string::String::new(),
            integral: 0,
            ot_price: ::std::string::String::new(),
            price: ::std::string::String::new(),
            stock: 0,
            sales: 0,
            type_: 0,
            unique: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductSkuItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductSkuItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductSkuItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductSkuItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartListReq.limit)
    pub limit: i32,
    // @@protoc_insertion_point(field:pbdef.CartListReq.page)
    pub page: i32,
    // @@protoc_insertion_point(field:pbdef.CartListReq.php_uid)
    pub php_uid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartListReq {
    fn default() -> &'a CartListReq {
        <CartListReq as ::protobuf::Message>::default_instance()
    }
}

impl CartListReq {
    pub fn new() -> CartListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &CartListReq| { &m.limit },
            |m: &mut CartListReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &CartListReq| { &m.page },
            |m: &mut CartListReq| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_uid",
            |m: &CartListReq| { &m.php_uid },
            |m: &mut CartListReq| { &mut m.php_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartListReq>(
            "CartListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartListReq {
    const NAME: &'static str = "CartListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = is.read_int32()?;
                },
                16 => {
                    self.page = is.read_int32()?;
                },
                24 => {
                    self.php_uid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.limit);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.page);
        }
        if self.php_uid != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.php_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.limit != 0 {
            os.write_int32(1, self.limit)?;
        }
        if self.page != 0 {
            os.write_int32(2, self.page)?;
        }
        if self.php_uid != 0 {
            os.write_int32(3, self.php_uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartListReq {
        CartListReq::new()
    }

    fn clear(&mut self) {
        self.limit = 0;
        self.page = 0;
        self.php_uid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartListReq {
        static instance: CartListReq = CartListReq {
            limit: 0,
            page: 0,
            php_uid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CartListRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CartListRsp.data)
    pub data: ::std::vec::Vec<CartItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartListRsp {
    fn default() -> &'a CartListRsp {
        <CartListRsp as ::protobuf::Message>::default_instance()
    }
}

impl CartListRsp {
    pub fn new() -> CartListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CartListRsp| { &m.ret },
            |m: &mut CartListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &CartListRsp| { &m.msg },
            |m: &mut CartListRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &CartListRsp| { &m.data },
            |m: &mut CartListRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartListRsp>(
            "CartListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartListRsp {
    const NAME: &'static str = "CartListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartListRsp {
        CartListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartListRsp {
        static instance: CartListRsp = CartListRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartItem.mer_id)
    pub mer_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartItem.product_id)
    pub product_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartItem.cart_num)
    pub cart_num: i32,
    // @@protoc_insertion_point(field:pbdef.CartItem.create_time)
    pub create_time: u32,
    // @@protoc_insertion_point(field:pbdef.CartItem.product_attr_unique)
    pub product_attr_unique: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CartItem.pro_info)
    pub pro_info: ::protobuf::MessageField<ProductItem>,
    // @@protoc_insertion_point(field:pbdef.CartItem.sku_info)
    pub sku_info: ::protobuf::MessageField<ProductSkuItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartItem {
    fn default() -> &'a CartItem {
        <CartItem as ::protobuf::Message>::default_instance()
    }
}

impl CartItem {
    pub fn new() -> CartItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &CartItem| { &m.mer_id },
            |m: &mut CartItem| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_id",
            |m: &CartItem| { &m.product_id },
            |m: &mut CartItem| { &mut m.product_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_num",
            |m: &CartItem| { &m.cart_num },
            |m: &mut CartItem| { &mut m.cart_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &CartItem| { &m.create_time },
            |m: &mut CartItem| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_attr_unique",
            |m: &CartItem| { &m.product_attr_unique },
            |m: &mut CartItem| { &mut m.product_attr_unique },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductItem>(
            "pro_info",
            |m: &CartItem| { &m.pro_info },
            |m: &mut CartItem| { &mut m.pro_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProductSkuItem>(
            "sku_info",
            |m: &CartItem| { &m.sku_info },
            |m: &mut CartItem| { &mut m.sku_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartItem>(
            "CartItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartItem {
    const NAME: &'static str = "CartItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mer_id = is.read_int32()?;
                },
                16 => {
                    self.product_id = is.read_int32()?;
                },
                24 => {
                    self.cart_num = is.read_int32()?;
                },
                32 => {
                    self.create_time = is.read_uint32()?;
                },
                42 => {
                    self.product_attr_unique = is.read_string()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pro_info)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.sku_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.mer_id);
        }
        if self.product_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.product_id);
        }
        if self.cart_num != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.cart_num);
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.create_time);
        }
        if !self.product_attr_unique.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.product_attr_unique);
        }
        if let Some(v) = self.pro_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.sku_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mer_id != 0 {
            os.write_int32(1, self.mer_id)?;
        }
        if self.product_id != 0 {
            os.write_int32(2, self.product_id)?;
        }
        if self.cart_num != 0 {
            os.write_int32(3, self.cart_num)?;
        }
        if self.create_time != 0 {
            os.write_uint32(4, self.create_time)?;
        }
        if !self.product_attr_unique.is_empty() {
            os.write_string(5, &self.product_attr_unique)?;
        }
        if let Some(v) = self.pro_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.sku_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartItem {
        CartItem::new()
    }

    fn clear(&mut self) {
        self.mer_id = 0;
        self.product_id = 0;
        self.cart_num = 0;
        self.create_time = 0;
        self.product_attr_unique.clear();
        self.pro_info.clear();
        self.sku_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartItem {
        static instance: CartItem = CartItem {
            mer_id: 0,
            product_id: 0,
            cart_num: 0,
            create_time: 0,
            product_attr_unique: ::std::string::String::new(),
            pro_info: ::protobuf::MessageField::none(),
            sku_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartCreateReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartCreateReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.product_type)
    pub product_type: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.mer_id)
    pub mer_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.product_id)
    pub product_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.product_attr_unique)
    pub product_attr_unique: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.cart_num)
    pub cart_num: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.is_new)
    pub is_new: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.spread_id)
    pub spread_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.group_buying_id)
    pub group_buying_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateReq.phpUid)
    pub phpUid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartCreateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartCreateReq {
    fn default() -> &'a CartCreateReq {
        <CartCreateReq as ::protobuf::Message>::default_instance()
    }
}

impl CartCreateReq {
    pub fn new() -> CartCreateReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_type",
            |m: &CartCreateReq| { &m.product_type },
            |m: &mut CartCreateReq| { &mut m.product_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &CartCreateReq| { &m.mer_id },
            |m: &mut CartCreateReq| { &mut m.mer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_id",
            |m: &CartCreateReq| { &m.product_id },
            |m: &mut CartCreateReq| { &mut m.product_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_attr_unique",
            |m: &CartCreateReq| { &m.product_attr_unique },
            |m: &mut CartCreateReq| { &mut m.product_attr_unique },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_num",
            |m: &CartCreateReq| { &m.cart_num },
            |m: &mut CartCreateReq| { &mut m.cart_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_new",
            |m: &CartCreateReq| { &m.is_new },
            |m: &mut CartCreateReq| { &mut m.is_new },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "spread_id",
            |m: &CartCreateReq| { &m.spread_id },
            |m: &mut CartCreateReq| { &mut m.spread_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_buying_id",
            |m: &CartCreateReq| { &m.group_buying_id },
            |m: &mut CartCreateReq| { &mut m.group_buying_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &CartCreateReq| { &m.phpUid },
            |m: &mut CartCreateReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartCreateReq>(
            "CartCreateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartCreateReq {
    const NAME: &'static str = "CartCreateReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.product_type = is.read_int32()?;
                },
                16 => {
                    self.mer_id = is.read_int32()?;
                },
                24 => {
                    self.product_id = is.read_int32()?;
                },
                34 => {
                    self.product_attr_unique = is.read_string()?;
                },
                40 => {
                    self.cart_num = is.read_int32()?;
                },
                48 => {
                    self.is_new = is.read_int32()?;
                },
                56 => {
                    self.spread_id = is.read_int32()?;
                },
                64 => {
                    self.group_buying_id = is.read_int32()?;
                },
                72 => {
                    self.phpUid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.product_type != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.product_type);
        }
        if self.mer_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.mer_id);
        }
        if self.product_id != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.product_id);
        }
        if !self.product_attr_unique.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.product_attr_unique);
        }
        if self.cart_num != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.cart_num);
        }
        if self.is_new != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.is_new);
        }
        if self.spread_id != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.spread_id);
        }
        if self.group_buying_id != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.group_buying_id);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.product_type != 0 {
            os.write_int32(1, self.product_type)?;
        }
        if self.mer_id != 0 {
            os.write_int32(2, self.mer_id)?;
        }
        if self.product_id != 0 {
            os.write_int32(3, self.product_id)?;
        }
        if !self.product_attr_unique.is_empty() {
            os.write_string(4, &self.product_attr_unique)?;
        }
        if self.cart_num != 0 {
            os.write_int32(5, self.cart_num)?;
        }
        if self.is_new != 0 {
            os.write_int32(6, self.is_new)?;
        }
        if self.spread_id != 0 {
            os.write_int32(7, self.spread_id)?;
        }
        if self.group_buying_id != 0 {
            os.write_int32(8, self.group_buying_id)?;
        }
        if self.phpUid != 0 {
            os.write_int32(9, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartCreateReq {
        CartCreateReq::new()
    }

    fn clear(&mut self) {
        self.product_type = 0;
        self.mer_id = 0;
        self.product_id = 0;
        self.product_attr_unique.clear();
        self.cart_num = 0;
        self.is_new = 0;
        self.spread_id = 0;
        self.group_buying_id = 0;
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartCreateReq {
        static instance: CartCreateReq = CartCreateReq {
            product_type: 0,
            mer_id: 0,
            product_id: 0,
            product_attr_unique: ::std::string::String::new(),
            cart_num: 0,
            is_new: 0,
            spread_id: 0,
            group_buying_id: 0,
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartCreateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartCreateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartCreateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartCreateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartCreateRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartCreateRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartCreateRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CartCreateRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CartCreateRsp.car_id)
    pub car_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartCreateRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartCreateRsp {
    fn default() -> &'a CartCreateRsp {
        <CartCreateRsp as ::protobuf::Message>::default_instance()
    }
}

impl CartCreateRsp {
    pub fn new() -> CartCreateRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CartCreateRsp| { &m.ret },
            |m: &mut CartCreateRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &CartCreateRsp| { &m.msg },
            |m: &mut CartCreateRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "car_id",
            |m: &CartCreateRsp| { &m.car_id },
            |m: &mut CartCreateRsp| { &mut m.car_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartCreateRsp>(
            "CartCreateRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartCreateRsp {
    const NAME: &'static str = "CartCreateRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    self.car_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        if !self.car_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.car_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        if !self.car_id.is_empty() {
            os.write_string(3, &self.car_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartCreateRsp {
        CartCreateRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.car_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartCreateRsp {
        static instance: CartCreateRsp = CartCreateRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            car_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartCreateRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartCreateRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartCreateRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartCreateRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartChangeReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartChangeReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartChangeReq.cart_id)
    pub cart_id: i32,
    // @@protoc_insertion_point(field:pbdef.CartChangeReq.cart_num)
    pub cart_num: i32,
    // @@protoc_insertion_point(field:pbdef.CartChangeReq.product_attr_unique)
    pub product_attr_unique: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CartChangeReq.phpUid)
    pub phpUid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartChangeReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartChangeReq {
    fn default() -> &'a CartChangeReq {
        <CartChangeReq as ::protobuf::Message>::default_instance()
    }
}

impl CartChangeReq {
    pub fn new() -> CartChangeReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_id",
            |m: &CartChangeReq| { &m.cart_id },
            |m: &mut CartChangeReq| { &mut m.cart_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_num",
            |m: &CartChangeReq| { &m.cart_num },
            |m: &mut CartChangeReq| { &mut m.cart_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_attr_unique",
            |m: &CartChangeReq| { &m.product_attr_unique },
            |m: &mut CartChangeReq| { &mut m.product_attr_unique },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &CartChangeReq| { &m.phpUid },
            |m: &mut CartChangeReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartChangeReq>(
            "CartChangeReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartChangeReq {
    const NAME: &'static str = "CartChangeReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cart_id = is.read_int32()?;
                },
                16 => {
                    self.cart_num = is.read_int32()?;
                },
                26 => {
                    self.product_attr_unique = is.read_string()?;
                },
                32 => {
                    self.phpUid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.cart_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.cart_id);
        }
        if self.cart_num != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.cart_num);
        }
        if !self.product_attr_unique.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.product_attr_unique);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.cart_id != 0 {
            os.write_int32(1, self.cart_id)?;
        }
        if self.cart_num != 0 {
            os.write_int32(2, self.cart_num)?;
        }
        if !self.product_attr_unique.is_empty() {
            os.write_string(3, &self.product_attr_unique)?;
        }
        if self.phpUid != 0 {
            os.write_int32(4, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartChangeReq {
        CartChangeReq::new()
    }

    fn clear(&mut self) {
        self.cart_id = 0;
        self.cart_num = 0;
        self.product_attr_unique.clear();
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartChangeReq {
        static instance: CartChangeReq = CartChangeReq {
            cart_id: 0,
            cart_num: 0,
            product_attr_unique: ::std::string::String::new(),
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartChangeReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartChangeReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartChangeReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartChangeReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartChangeRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartChangeRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartChangeRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CartChangeRsp.msg)
    pub msg: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartChangeRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartChangeRsp {
    fn default() -> &'a CartChangeRsp {
        <CartChangeRsp as ::protobuf::Message>::default_instance()
    }
}

impl CartChangeRsp {
    pub fn new() -> CartChangeRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CartChangeRsp| { &m.ret },
            |m: &mut CartChangeRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &CartChangeRsp| { &m.msg },
            |m: &mut CartChangeRsp| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartChangeRsp>(
            "CartChangeRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartChangeRsp {
    const NAME: &'static str = "CartChangeRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartChangeRsp {
        CartChangeRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartChangeRsp {
        static instance: CartChangeRsp = CartChangeRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartChangeRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartChangeRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartChangeRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartChangeRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartDeleteReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartDeleteReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartDeleteReq.cart_ids)
    pub cart_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:pbdef.CartDeleteReq.phpUid)
    pub phpUid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartDeleteReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartDeleteReq {
    fn default() -> &'a CartDeleteReq {
        <CartDeleteReq as ::protobuf::Message>::default_instance()
    }
}

impl CartDeleteReq {
    pub fn new() -> CartDeleteReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "cart_ids",
            |m: &CartDeleteReq| { &m.cart_ids },
            |m: &mut CartDeleteReq| { &mut m.cart_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &CartDeleteReq| { &m.phpUid },
            |m: &mut CartDeleteReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartDeleteReq>(
            "CartDeleteReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartDeleteReq {
    const NAME: &'static str = "CartDeleteReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.cart_ids)?;
                },
                8 => {
                    self.cart_ids.push(is.read_int32()?);
                },
                16 => {
                    self.phpUid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cart_ids {
            my_size += ::protobuf::rt::int32_size(1, *value);
        };
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.cart_ids {
            os.write_int32(1, *v)?;
        };
        if self.phpUid != 0 {
            os.write_int32(2, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartDeleteReq {
        CartDeleteReq::new()
    }

    fn clear(&mut self) {
        self.cart_ids.clear();
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartDeleteReq {
        static instance: CartDeleteReq = CartDeleteReq {
            cart_ids: ::std::vec::Vec::new(),
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartDeleteReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartDeleteReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartDeleteReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartDeleteReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CartDeleteRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CartDeleteRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CartDeleteRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CartDeleteRsp.msg)
    pub msg: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CartDeleteRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CartDeleteRsp {
    fn default() -> &'a CartDeleteRsp {
        <CartDeleteRsp as ::protobuf::Message>::default_instance()
    }
}

impl CartDeleteRsp {
    pub fn new() -> CartDeleteRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CartDeleteRsp| { &m.ret },
            |m: &mut CartDeleteRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &CartDeleteRsp| { &m.msg },
            |m: &mut CartDeleteRsp| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CartDeleteRsp>(
            "CartDeleteRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CartDeleteRsp {
    const NAME: &'static str = "CartDeleteRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CartDeleteRsp {
        CartDeleteRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CartDeleteRsp {
        static instance: CartDeleteRsp = CartDeleteRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CartDeleteRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CartDeleteRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CartDeleteRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CartDeleteRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationCerateReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationCerateReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationCerateReq.type_id)
    pub type_id: i32,
    // @@protoc_insertion_point(field:pbdef.RelationCerateReq.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.RelationCerateReq.phpUid)
    pub phpUid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationCerateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationCerateReq {
    fn default() -> &'a RelationCerateReq {
        <RelationCerateReq as ::protobuf::Message>::default_instance()
    }
}

impl RelationCerateReq {
    pub fn new() -> RelationCerateReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &RelationCerateReq| { &m.type_id },
            |m: &mut RelationCerateReq| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &RelationCerateReq| { &m.type_ },
            |m: &mut RelationCerateReq| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &RelationCerateReq| { &m.phpUid },
            |m: &mut RelationCerateReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationCerateReq>(
            "RelationCerateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationCerateReq {
    const NAME: &'static str = "RelationCerateReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_id = is.read_int32()?;
                },
                16 => {
                    self.type_ = is.read_int32()?;
                },
                24 => {
                    self.phpUid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.type_id);
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.type_);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_id != 0 {
            os.write_int32(1, self.type_id)?;
        }
        if self.type_ != 0 {
            os.write_int32(2, self.type_)?;
        }
        if self.phpUid != 0 {
            os.write_int32(3, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationCerateReq {
        RelationCerateReq::new()
    }

    fn clear(&mut self) {
        self.type_id = 0;
        self.type_ = 0;
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationCerateReq {
        static instance: RelationCerateReq = RelationCerateReq {
            type_id: 0,
            type_: 0,
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationCerateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationCerateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationCerateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationCerateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationCerateRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationCerateRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationCerateRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationCerateRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationCerateRsp {
    fn default() -> &'a RelationCerateRsp {
        <RelationCerateRsp as ::protobuf::Message>::default_instance()
    }
}

impl RelationCerateRsp {
    pub fn new() -> RelationCerateRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &RelationCerateRsp| { &m.ret },
            |m: &mut RelationCerateRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationCerateRsp>(
            "RelationCerateRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationCerateRsp {
    const NAME: &'static str = "RelationCerateRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationCerateRsp {
        RelationCerateRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationCerateRsp {
        static instance: RelationCerateRsp = RelationCerateRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationCerateRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationCerateRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationCerateRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationCerateRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationItem.type_id)
    pub type_id: i32,
    // @@protoc_insertion_point(field:pbdef.RelationItem.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.RelationItem.phpUid)
    pub phpUid: i32,
    // @@protoc_insertion_point(field:pbdef.RelationItem.createTime)
    pub createTime: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationItem {
    fn default() -> &'a RelationItem {
        <RelationItem as ::protobuf::Message>::default_instance()
    }
}

impl RelationItem {
    pub fn new() -> RelationItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &RelationItem| { &m.type_id },
            |m: &mut RelationItem| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &RelationItem| { &m.type_ },
            |m: &mut RelationItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &RelationItem| { &m.phpUid },
            |m: &mut RelationItem| { &mut m.phpUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createTime",
            |m: &RelationItem| { &m.createTime },
            |m: &mut RelationItem| { &mut m.createTime },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationItem>(
            "RelationItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationItem {
    const NAME: &'static str = "RelationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_id = is.read_int32()?;
                },
                16 => {
                    self.type_ = is.read_int32()?;
                },
                24 => {
                    self.phpUid = is.read_int32()?;
                },
                34 => {
                    self.createTime = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.type_id);
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.type_);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.phpUid);
        }
        if !self.createTime.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.createTime);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_id != 0 {
            os.write_int32(1, self.type_id)?;
        }
        if self.type_ != 0 {
            os.write_int32(2, self.type_)?;
        }
        if self.phpUid != 0 {
            os.write_int32(3, self.phpUid)?;
        }
        if !self.createTime.is_empty() {
            os.write_string(4, &self.createTime)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationItem {
        RelationItem::new()
    }

    fn clear(&mut self) {
        self.type_id = 0;
        self.type_ = 0;
        self.phpUid = 0;
        self.createTime.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationItem {
        static instance: RelationItem = RelationItem {
            type_id: 0,
            type_: 0,
            phpUid: 0,
            createTime: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationProductListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationProductListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationProductListReq.phpUid)
    pub phpUid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationProductListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationProductListReq {
    fn default() -> &'a RelationProductListReq {
        <RelationProductListReq as ::protobuf::Message>::default_instance()
    }
}

impl RelationProductListReq {
    pub fn new() -> RelationProductListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &RelationProductListReq| { &m.phpUid },
            |m: &mut RelationProductListReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationProductListReq>(
            "RelationProductListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationProductListReq {
    const NAME: &'static str = "RelationProductListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.phpUid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.phpUid != 0 {
            os.write_int32(1, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationProductListReq {
        RelationProductListReq::new()
    }

    fn clear(&mut self) {
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationProductListReq {
        static instance: RelationProductListReq = RelationProductListReq {
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationProductListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationProductListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationProductListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationProductListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationProductListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationProductListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationProductListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.RelationProductListRsp.lists)
    pub lists: ::std::vec::Vec<RelationItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationProductListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationProductListRsp {
    fn default() -> &'a RelationProductListRsp {
        <RelationProductListRsp as ::protobuf::Message>::default_instance()
    }
}

impl RelationProductListRsp {
    pub fn new() -> RelationProductListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &RelationProductListRsp| { &m.ret },
            |m: &mut RelationProductListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &RelationProductListRsp| { &m.lists },
            |m: &mut RelationProductListRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationProductListRsp>(
            "RelationProductListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationProductListRsp {
    const NAME: &'static str = "RelationProductListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationProductListRsp {
        RelationProductListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationProductListRsp {
        static instance: RelationProductListRsp = RelationProductListRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationProductListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationProductListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationProductListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationProductListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationProductDelReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationProductDelReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationProductDelReq.type_id)
    pub type_id: i32,
    // @@protoc_insertion_point(field:pbdef.RelationProductDelReq.type)
    pub type_: i32,
    // @@protoc_insertion_point(field:pbdef.RelationProductDelReq.phpUid)
    pub phpUid: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationProductDelReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationProductDelReq {
    fn default() -> &'a RelationProductDelReq {
        <RelationProductDelReq as ::protobuf::Message>::default_instance()
    }
}

impl RelationProductDelReq {
    pub fn new() -> RelationProductDelReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type_id",
            |m: &RelationProductDelReq| { &m.type_id },
            |m: &mut RelationProductDelReq| { &mut m.type_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &RelationProductDelReq| { &m.type_ },
            |m: &mut RelationProductDelReq| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &RelationProductDelReq| { &m.phpUid },
            |m: &mut RelationProductDelReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationProductDelReq>(
            "RelationProductDelReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationProductDelReq {
    const NAME: &'static str = "RelationProductDelReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_id = is.read_int32()?;
                },
                16 => {
                    self.type_ = is.read_int32()?;
                },
                24 => {
                    self.phpUid = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.type_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.type_id);
        }
        if self.type_ != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.type_);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.type_id != 0 {
            os.write_int32(1, self.type_id)?;
        }
        if self.type_ != 0 {
            os.write_int32(2, self.type_)?;
        }
        if self.phpUid != 0 {
            os.write_int32(3, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationProductDelReq {
        RelationProductDelReq::new()
    }

    fn clear(&mut self) {
        self.type_id = 0;
        self.type_ = 0;
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationProductDelReq {
        static instance: RelationProductDelReq = RelationProductDelReq {
            type_id: 0,
            type_: 0,
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationProductDelReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationProductDelReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationProductDelReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationProductDelReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RelationProductDelRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RelationProductDelRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RelationProductDelRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RelationProductDelRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RelationProductDelRsp {
    fn default() -> &'a RelationProductDelRsp {
        <RelationProductDelRsp as ::protobuf::Message>::default_instance()
    }
}

impl RelationProductDelRsp {
    pub fn new() -> RelationProductDelRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &RelationProductDelRsp| { &m.ret },
            |m: &mut RelationProductDelRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RelationProductDelRsp>(
            "RelationProductDelRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RelationProductDelRsp {
    const NAME: &'static str = "RelationProductDelRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RelationProductDelRsp {
        RelationProductDelRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RelationProductDelRsp {
        static instance: RelationProductDelRsp = RelationProductDelRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RelationProductDelRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RelationProductDelRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RelationProductDelRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RelationProductDelRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderListReq.php_uid)
    pub php_uid: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderListReq.limit)
    pub limit: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderListReq.page)
    pub page: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderListReq {
    fn default() -> &'a UserOrderListReq {
        <UserOrderListReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderListReq {
    pub fn new() -> UserOrderListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_uid",
            |m: &UserOrderListReq| { &m.php_uid },
            |m: &mut UserOrderListReq| { &mut m.php_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &UserOrderListReq| { &m.limit },
            |m: &mut UserOrderListReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &UserOrderListReq| { &m.page },
            |m: &mut UserOrderListReq| { &mut m.page },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderListReq>(
            "UserOrderListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderListReq {
    const NAME: &'static str = "UserOrderListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.php_uid = is.read_int32()?;
                },
                16 => {
                    self.limit = is.read_int32()?;
                },
                24 => {
                    self.page = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.php_uid != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.php_uid);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.limit);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.page);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.php_uid != 0 {
            os.write_int32(1, self.php_uid)?;
        }
        if self.limit != 0 {
            os.write_int32(2, self.limit)?;
        }
        if self.page != 0 {
            os.write_int32(3, self.page)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderListReq {
        UserOrderListReq::new()
    }

    fn clear(&mut self) {
        self.php_uid = 0;
        self.limit = 0;
        self.page = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderListReq {
        static instance: UserOrderListReq = UserOrderListReq {
            php_uid: 0,
            limit: 0,
            page: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderListRsp.lists)
    pub lists: ::std::vec::Vec<UserOrderItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderListRsp {
    fn default() -> &'a UserOrderListRsp {
        <UserOrderListRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderListRsp {
    pub fn new() -> UserOrderListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderListRsp| { &m.ret },
            |m: &mut UserOrderListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &UserOrderListRsp| { &m.lists },
            |m: &mut UserOrderListRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderListRsp>(
            "UserOrderListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderListRsp {
    const NAME: &'static str = "UserOrderListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderListRsp {
        UserOrderListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderListRsp {
        static instance: UserOrderListRsp = UserOrderListRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.order_id)
    pub order_id: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.order_sn)
    pub order_sn: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.realName)
    pub realName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.user_phone)
    pub user_phone: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.user_address)
    pub user_address: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.total_price)
    pub total_price: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.pay_price)
    pub pay_price: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.give_integral)
    pub give_integral: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.create_time)
    pub create_time: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.product_image)
    pub product_image: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.product_name)
    pub product_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.product_attr)
    pub product_attr: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.delivery_name)
    pub delivery_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.delivery_id)
    pub delivery_id: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderItem.delivery_type)
    pub delivery_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderItem {
    fn default() -> &'a UserOrderItem {
        <UserOrderItem as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderItem {
    pub fn new() -> UserOrderItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderItem| { &m.order_id },
            |m: &mut UserOrderItem| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_sn",
            |m: &UserOrderItem| { &m.order_sn },
            |m: &mut UserOrderItem| { &mut m.order_sn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realName",
            |m: &UserOrderItem| { &m.realName },
            |m: &mut UserOrderItem| { &mut m.realName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_phone",
            |m: &UserOrderItem| { &m.user_phone },
            |m: &mut UserOrderItem| { &mut m.user_phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_address",
            |m: &UserOrderItem| { &m.user_address },
            |m: &mut UserOrderItem| { &mut m.user_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_price",
            |m: &UserOrderItem| { &m.total_price },
            |m: &mut UserOrderItem| { &mut m.total_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pay_price",
            |m: &UserOrderItem| { &m.pay_price },
            |m: &mut UserOrderItem| { &mut m.pay_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "give_integral",
            |m: &UserOrderItem| { &m.give_integral },
            |m: &mut UserOrderItem| { &mut m.give_integral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &UserOrderItem| { &m.create_time },
            |m: &mut UserOrderItem| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_image",
            |m: &UserOrderItem| { &m.product_image },
            |m: &mut UserOrderItem| { &mut m.product_image },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_name",
            |m: &UserOrderItem| { &m.product_name },
            |m: &mut UserOrderItem| { &mut m.product_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "product_attr",
            |m: &UserOrderItem| { &m.product_attr },
            |m: &mut UserOrderItem| { &mut m.product_attr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delivery_name",
            |m: &UserOrderItem| { &m.delivery_name },
            |m: &mut UserOrderItem| { &mut m.delivery_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delivery_id",
            |m: &UserOrderItem| { &m.delivery_id },
            |m: &mut UserOrderItem| { &mut m.delivery_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delivery_type",
            |m: &UserOrderItem| { &m.delivery_type },
            |m: &mut UserOrderItem| { &mut m.delivery_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderItem>(
            "UserOrderItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderItem {
    const NAME: &'static str = "UserOrderItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = is.read_int32()?;
                },
                18 => {
                    self.order_sn = is.read_string()?;
                },
                26 => {
                    self.realName = is.read_string()?;
                },
                34 => {
                    self.user_phone = is.read_string()?;
                },
                42 => {
                    self.user_address = is.read_string()?;
                },
                50 => {
                    self.total_price = is.read_string()?;
                },
                58 => {
                    self.pay_price = is.read_string()?;
                },
                64 => {
                    self.give_integral = is.read_int32()?;
                },
                82 => {
                    self.create_time = is.read_string()?;
                },
                90 => {
                    self.product_image = is.read_string()?;
                },
                98 => {
                    self.product_name = is.read_string()?;
                },
                106 => {
                    self.product_attr = is.read_string()?;
                },
                114 => {
                    self.delivery_name = is.read_string()?;
                },
                122 => {
                    self.delivery_id = is.read_string()?;
                },
                130 => {
                    self.delivery_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.order_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.order_id);
        }
        if !self.order_sn.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_sn);
        }
        if !self.realName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.realName);
        }
        if !self.user_phone.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_phone);
        }
        if !self.user_address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.user_address);
        }
        if !self.total_price.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.total_price);
        }
        if !self.pay_price.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.pay_price);
        }
        if self.give_integral != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.give_integral);
        }
        if !self.create_time.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.create_time);
        }
        if !self.product_image.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.product_image);
        }
        if !self.product_name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.product_name);
        }
        if !self.product_attr.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.product_attr);
        }
        if !self.delivery_name.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.delivery_name);
        }
        if !self.delivery_id.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.delivery_id);
        }
        if !self.delivery_type.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.delivery_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.order_id != 0 {
            os.write_int32(1, self.order_id)?;
        }
        if !self.order_sn.is_empty() {
            os.write_string(2, &self.order_sn)?;
        }
        if !self.realName.is_empty() {
            os.write_string(3, &self.realName)?;
        }
        if !self.user_phone.is_empty() {
            os.write_string(4, &self.user_phone)?;
        }
        if !self.user_address.is_empty() {
            os.write_string(5, &self.user_address)?;
        }
        if !self.total_price.is_empty() {
            os.write_string(6, &self.total_price)?;
        }
        if !self.pay_price.is_empty() {
            os.write_string(7, &self.pay_price)?;
        }
        if self.give_integral != 0 {
            os.write_int32(8, self.give_integral)?;
        }
        if !self.create_time.is_empty() {
            os.write_string(10, &self.create_time)?;
        }
        if !self.product_image.is_empty() {
            os.write_string(11, &self.product_image)?;
        }
        if !self.product_name.is_empty() {
            os.write_string(12, &self.product_name)?;
        }
        if !self.product_attr.is_empty() {
            os.write_string(13, &self.product_attr)?;
        }
        if !self.delivery_name.is_empty() {
            os.write_string(14, &self.delivery_name)?;
        }
        if !self.delivery_id.is_empty() {
            os.write_string(15, &self.delivery_id)?;
        }
        if !self.delivery_type.is_empty() {
            os.write_string(16, &self.delivery_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderItem {
        UserOrderItem::new()
    }

    fn clear(&mut self) {
        self.order_id = 0;
        self.order_sn.clear();
        self.realName.clear();
        self.user_phone.clear();
        self.user_address.clear();
        self.total_price.clear();
        self.pay_price.clear();
        self.give_integral = 0;
        self.create_time.clear();
        self.product_image.clear();
        self.product_name.clear();
        self.product_attr.clear();
        self.delivery_name.clear();
        self.delivery_id.clear();
        self.delivery_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderItem {
        static instance: UserOrderItem = UserOrderItem {
            order_id: 0,
            order_sn: ::std::string::String::new(),
            realName: ::std::string::String::new(),
            user_phone: ::std::string::String::new(),
            user_address: ::std::string::String::new(),
            total_price: ::std::string::String::new(),
            pay_price: ::std::string::String::new(),
            give_integral: 0,
            create_time: ::std::string::String::new(),
            product_image: ::std::string::String::new(),
            product_name: ::std::string::String::new(),
            product_attr: ::std::string::String::new(),
            delivery_name: ::std::string::String::new(),
            delivery_id: ::std::string::String::new(),
            delivery_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderDetailReq.order_id)
    pub order_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderDetailReq {
    fn default() -> &'a UserOrderDetailReq {
        <UserOrderDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderDetailReq {
    pub fn new() -> UserOrderDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderDetailReq| { &m.order_id },
            |m: &mut UserOrderDetailReq| { &mut m.order_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderDetailReq>(
            "UserOrderDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderDetailReq {
    const NAME: &'static str = "UserOrderDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.order_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.order_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.order_id != 0 {
            os.write_int32(1, self.order_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderDetailReq {
        UserOrderDetailReq::new()
    }

    fn clear(&mut self) {
        self.order_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderDetailReq {
        static instance: UserOrderDetailReq = UserOrderDetailReq {
            order_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderDetailRsp.detail)
    pub detail: ::protobuf::MessageField<UserOrderItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderDetailRsp {
    fn default() -> &'a UserOrderDetailRsp {
        <UserOrderDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderDetailRsp {
    pub fn new() -> UserOrderDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderDetailRsp| { &m.ret },
            |m: &mut UserOrderDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserOrderItem>(
            "detail",
            |m: &UserOrderDetailRsp| { &m.detail },
            |m: &mut UserOrderDetailRsp| { &mut m.detail },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderDetailRsp>(
            "UserOrderDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderDetailRsp {
    const NAME: &'static str = "UserOrderDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.detail)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.detail.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.detail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderDetailRsp {
        UserOrderDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.detail.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderDetailRsp {
        static instance: UserOrderDetailRsp = UserOrderDetailRsp {
            ret: 0,
            detail: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderCreateReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderCreateReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.cart_id)
    pub cart_id: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.address_id)
    pub address_id: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.use_coupon)
    pub use_coupon: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.takes)
    pub takes: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.use_integral)
    pub use_integral: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.receipt_data)
    pub receipt_data: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.extend)
    pub extend: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.mark)
    pub mark: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.pay_type)
    pub pay_type: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.user_phone)
    pub user_phone: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.order_type)
    pub order_type: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.php_uid)
    pub php_uid: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateReq.access_token)
    pub access_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderCreateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderCreateReq {
    fn default() -> &'a UserOrderCreateReq {
        <UserOrderCreateReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderCreateReq {
    pub fn new() -> UserOrderCreateReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_id",
            |m: &UserOrderCreateReq| { &m.cart_id },
            |m: &mut UserOrderCreateReq| { &mut m.cart_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address_id",
            |m: &UserOrderCreateReq| { &m.address_id },
            |m: &mut UserOrderCreateReq| { &mut m.address_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_coupon",
            |m: &UserOrderCreateReq| { &m.use_coupon },
            |m: &mut UserOrderCreateReq| { &mut m.use_coupon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "takes",
            |m: &UserOrderCreateReq| { &m.takes },
            |m: &mut UserOrderCreateReq| { &mut m.takes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_integral",
            |m: &UserOrderCreateReq| { &m.use_integral },
            |m: &mut UserOrderCreateReq| { &mut m.use_integral },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "receipt_data",
            |m: &UserOrderCreateReq| { &m.receipt_data },
            |m: &mut UserOrderCreateReq| { &mut m.receipt_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "extend",
            |m: &UserOrderCreateReq| { &m.extend },
            |m: &mut UserOrderCreateReq| { &mut m.extend },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mark",
            |m: &UserOrderCreateReq| { &m.mark },
            |m: &mut UserOrderCreateReq| { &mut m.mark },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pay_type",
            |m: &UserOrderCreateReq| { &m.pay_type },
            |m: &mut UserOrderCreateReq| { &mut m.pay_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_phone",
            |m: &UserOrderCreateReq| { &m.user_phone },
            |m: &mut UserOrderCreateReq| { &mut m.user_phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_type",
            |m: &UserOrderCreateReq| { &m.order_type },
            |m: &mut UserOrderCreateReq| { &mut m.order_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_uid",
            |m: &UserOrderCreateReq| { &m.php_uid },
            |m: &mut UserOrderCreateReq| { &mut m.php_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &UserOrderCreateReq| { &m.access_token },
            |m: &mut UserOrderCreateReq| { &mut m.access_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderCreateReq>(
            "UserOrderCreateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderCreateReq {
    const NAME: &'static str = "UserOrderCreateReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cart_id = is.read_string()?;
                },
                16 => {
                    self.address_id = is.read_int32()?;
                },
                26 => {
                    self.use_coupon = is.read_string()?;
                },
                34 => {
                    self.takes = is.read_string()?;
                },
                40 => {
                    self.use_integral = is.read_int32()?;
                },
                50 => {
                    self.receipt_data = is.read_string()?;
                },
                58 => {
                    self.extend = is.read_string()?;
                },
                66 => {
                    self.mark = is.read_string()?;
                },
                74 => {
                    self.pay_type = is.read_string()?;
                },
                82 => {
                    self.user_phone = is.read_string()?;
                },
                88 => {
                    self.order_type = is.read_int32()?;
                },
                96 => {
                    self.php_uid = is.read_int32()?;
                },
                106 => {
                    self.access_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.cart_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cart_id);
        }
        if self.address_id != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.address_id);
        }
        if !self.use_coupon.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.use_coupon);
        }
        if !self.takes.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.takes);
        }
        if self.use_integral != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.use_integral);
        }
        if !self.receipt_data.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.receipt_data);
        }
        if !self.extend.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.extend);
        }
        if !self.mark.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.mark);
        }
        if !self.pay_type.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.pay_type);
        }
        if !self.user_phone.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.user_phone);
        }
        if self.order_type != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.order_type);
        }
        if self.php_uid != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.php_uid);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.cart_id.is_empty() {
            os.write_string(1, &self.cart_id)?;
        }
        if self.address_id != 0 {
            os.write_int32(2, self.address_id)?;
        }
        if !self.use_coupon.is_empty() {
            os.write_string(3, &self.use_coupon)?;
        }
        if !self.takes.is_empty() {
            os.write_string(4, &self.takes)?;
        }
        if self.use_integral != 0 {
            os.write_int32(5, self.use_integral)?;
        }
        if !self.receipt_data.is_empty() {
            os.write_string(6, &self.receipt_data)?;
        }
        if !self.extend.is_empty() {
            os.write_string(7, &self.extend)?;
        }
        if !self.mark.is_empty() {
            os.write_string(8, &self.mark)?;
        }
        if !self.pay_type.is_empty() {
            os.write_string(9, &self.pay_type)?;
        }
        if !self.user_phone.is_empty() {
            os.write_string(10, &self.user_phone)?;
        }
        if self.order_type != 0 {
            os.write_int32(11, self.order_type)?;
        }
        if self.php_uid != 0 {
            os.write_int32(12, self.php_uid)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(13, &self.access_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderCreateReq {
        UserOrderCreateReq::new()
    }

    fn clear(&mut self) {
        self.cart_id.clear();
        self.address_id = 0;
        self.use_coupon.clear();
        self.takes.clear();
        self.use_integral = 0;
        self.receipt_data.clear();
        self.extend.clear();
        self.mark.clear();
        self.pay_type.clear();
        self.user_phone.clear();
        self.order_type = 0;
        self.php_uid = 0;
        self.access_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderCreateReq {
        static instance: UserOrderCreateReq = UserOrderCreateReq {
            cart_id: ::std::string::String::new(),
            address_id: 0,
            use_coupon: ::std::string::String::new(),
            takes: ::std::string::String::new(),
            use_integral: 0,
            receipt_data: ::std::string::String::new(),
            extend: ::std::string::String::new(),
            mark: ::std::string::String::new(),
            pay_type: ::std::string::String::new(),
            user_phone: ::std::string::String::new(),
            order_type: 0,
            php_uid: 0,
            access_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderCreateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderCreateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderCreateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderCreateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderCreateRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderCreateRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateRsp.order_id)
    pub order_id: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCreateRsp.payment_url)
    pub payment_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderCreateRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderCreateRsp {
    fn default() -> &'a UserOrderCreateRsp {
        <UserOrderCreateRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderCreateRsp {
    pub fn new() -> UserOrderCreateRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderCreateRsp| { &m.ret },
            |m: &mut UserOrderCreateRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderCreateRsp| { &m.order_id },
            |m: &mut UserOrderCreateRsp| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payment_url",
            |m: &UserOrderCreateRsp| { &m.payment_url },
            |m: &mut UserOrderCreateRsp| { &mut m.payment_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderCreateRsp>(
            "UserOrderCreateRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderCreateRsp {
    const NAME: &'static str = "UserOrderCreateRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.order_id = is.read_string()?;
                },
                26 => {
                    self.payment_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_id);
        }
        if !self.payment_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.payment_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.order_id.is_empty() {
            os.write_string(2, &self.order_id)?;
        }
        if !self.payment_url.is_empty() {
            os.write_string(3, &self.payment_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderCreateRsp {
        UserOrderCreateRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.order_id.clear();
        self.payment_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderCreateRsp {
        static instance: UserOrderCreateRsp = UserOrderCreateRsp {
            ret: 0,
            order_id: ::std::string::String::new(),
            payment_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderCreateRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderCreateRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderCreateRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderCreateRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderCheckReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderCheckReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderCheckReq.cart_id)
    pub cart_id: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCheckReq.addressId)
    pub addressId: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCheckReq.use_coupon)
    pub use_coupon: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCheckReq.takes)
    pub takes: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderCheckReq.access_token)
    pub access_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderCheckReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderCheckReq {
    fn default() -> &'a UserOrderCheckReq {
        <UserOrderCheckReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderCheckReq {
    pub fn new() -> UserOrderCheckReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_id",
            |m: &UserOrderCheckReq| { &m.cart_id },
            |m: &mut UserOrderCheckReq| { &mut m.cart_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addressId",
            |m: &UserOrderCheckReq| { &m.addressId },
            |m: &mut UserOrderCheckReq| { &mut m.addressId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_coupon",
            |m: &UserOrderCheckReq| { &m.use_coupon },
            |m: &mut UserOrderCheckReq| { &mut m.use_coupon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "takes",
            |m: &UserOrderCheckReq| { &m.takes },
            |m: &mut UserOrderCheckReq| { &mut m.takes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &UserOrderCheckReq| { &m.access_token },
            |m: &mut UserOrderCheckReq| { &mut m.access_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderCheckReq>(
            "UserOrderCheckReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderCheckReq {
    const NAME: &'static str = "UserOrderCheckReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cart_id = is.read_string()?;
                },
                18 => {
                    self.addressId = is.read_string()?;
                },
                26 => {
                    self.use_coupon = is.read_string()?;
                },
                34 => {
                    self.takes = is.read_string()?;
                },
                42 => {
                    self.access_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.cart_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cart_id);
        }
        if !self.addressId.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.addressId);
        }
        if !self.use_coupon.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.use_coupon);
        }
        if !self.takes.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.takes);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.cart_id.is_empty() {
            os.write_string(1, &self.cart_id)?;
        }
        if !self.addressId.is_empty() {
            os.write_string(2, &self.addressId)?;
        }
        if !self.use_coupon.is_empty() {
            os.write_string(3, &self.use_coupon)?;
        }
        if !self.takes.is_empty() {
            os.write_string(4, &self.takes)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(5, &self.access_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderCheckReq {
        UserOrderCheckReq::new()
    }

    fn clear(&mut self) {
        self.cart_id.clear();
        self.addressId.clear();
        self.use_coupon.clear();
        self.takes.clear();
        self.access_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderCheckReq {
        static instance: UserOrderCheckReq = UserOrderCheckReq {
            cart_id: ::std::string::String::new(),
            addressId: ::std::string::String::new(),
            use_coupon: ::std::string::String::new(),
            takes: ::std::string::String::new(),
            access_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderCheckReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderCheckReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderCheckReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderCheckReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderCheckRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderCheckRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderCheckRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderCheckRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderCheckRsp {
    fn default() -> &'a UserOrderCheckRsp {
        <UserOrderCheckRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderCheckRsp {
    pub fn new() -> UserOrderCheckRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderCheckRsp| { &m.ret },
            |m: &mut UserOrderCheckRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderCheckRsp>(
            "UserOrderCheckRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderCheckRsp {
    const NAME: &'static str = "UserOrderCheckRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderCheckRsp {
        UserOrderCheckRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderCheckRsp {
        static instance: UserOrderCheckRsp = UserOrderCheckRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderCheckRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderCheckRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderCheckRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderCheckRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderDelReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderDelReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderDelReq.order_id)
    pub order_id: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderDelReq.access_token)
    pub access_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderDelReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderDelReq {
    fn default() -> &'a UserOrderDelReq {
        <UserOrderDelReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderDelReq {
    pub fn new() -> UserOrderDelReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderDelReq| { &m.order_id },
            |m: &mut UserOrderDelReq| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &UserOrderDelReq| { &m.access_token },
            |m: &mut UserOrderDelReq| { &mut m.access_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderDelReq>(
            "UserOrderDelReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderDelReq {
    const NAME: &'static str = "UserOrderDelReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = is.read_int32()?;
                },
                18 => {
                    self.access_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.order_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.order_id);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.order_id != 0 {
            os.write_int32(1, self.order_id)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(2, &self.access_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderDelReq {
        UserOrderDelReq::new()
    }

    fn clear(&mut self) {
        self.order_id = 0;
        self.access_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderDelReq {
        static instance: UserOrderDelReq = UserOrderDelReq {
            order_id: 0,
            access_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderDelReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderDelReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderDelReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderDelReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderDelRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderDelRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderDelRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderDelRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderDelRsp {
    fn default() -> &'a UserOrderDelRsp {
        <UserOrderDelRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderDelRsp {
    pub fn new() -> UserOrderDelRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderDelRsp| { &m.ret },
            |m: &mut UserOrderDelRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderDelRsp>(
            "UserOrderDelRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderDelRsp {
    const NAME: &'static str = "UserOrderDelRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderDelRsp {
        UserOrderDelRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderDelRsp {
        static instance: UserOrderDelRsp = UserOrderDelRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderDelRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderDelRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderDelRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderDelRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderPayReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderPayReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderPayReq.order_id)
    pub order_id: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderPayReq.cart_ids)
    pub cart_ids: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserOrderPayReq.access_token)
    pub access_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderPayReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderPayReq {
    fn default() -> &'a UserOrderPayReq {
        <UserOrderPayReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderPayReq {
    pub fn new() -> UserOrderPayReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderPayReq| { &m.order_id },
            |m: &mut UserOrderPayReq| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cart_ids",
            |m: &UserOrderPayReq| { &m.cart_ids },
            |m: &mut UserOrderPayReq| { &mut m.cart_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &UserOrderPayReq| { &m.access_token },
            |m: &mut UserOrderPayReq| { &mut m.access_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderPayReq>(
            "UserOrderPayReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderPayReq {
    const NAME: &'static str = "UserOrderPayReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = is.read_int32()?;
                },
                18 => {
                    self.cart_ids = is.read_string()?;
                },
                26 => {
                    self.access_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.order_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.order_id);
        }
        if !self.cart_ids.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cart_ids);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.order_id != 0 {
            os.write_int32(1, self.order_id)?;
        }
        if !self.cart_ids.is_empty() {
            os.write_string(2, &self.cart_ids)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(3, &self.access_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderPayReq {
        UserOrderPayReq::new()
    }

    fn clear(&mut self) {
        self.order_id = 0;
        self.cart_ids.clear();
        self.access_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderPayReq {
        static instance: UserOrderPayReq = UserOrderPayReq {
            order_id: 0,
            cart_ids: ::std::string::String::new(),
            access_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderPayReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderPayReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderPayReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderPayReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderPayRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderPayRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderPayRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderPayRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderPayRsp {
    fn default() -> &'a UserOrderPayRsp {
        <UserOrderPayRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderPayRsp {
    pub fn new() -> UserOrderPayRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderPayRsp| { &m.ret },
            |m: &mut UserOrderPayRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderPayRsp>(
            "UserOrderPayRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderPayRsp {
    const NAME: &'static str = "UserOrderPayRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderPayRsp {
        UserOrderPayRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderPayRsp {
        static instance: UserOrderPayRsp = UserOrderPayRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderPayRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderPayRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderPayRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderPayRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderTakeReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderTakeReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderTakeReq.order_id)
    pub order_id: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderTakeReq.access_token)
    pub access_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderTakeReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderTakeReq {
    fn default() -> &'a UserOrderTakeReq {
        <UserOrderTakeReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderTakeReq {
    pub fn new() -> UserOrderTakeReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderTakeReq| { &m.order_id },
            |m: &mut UserOrderTakeReq| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &UserOrderTakeReq| { &m.access_token },
            |m: &mut UserOrderTakeReq| { &mut m.access_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderTakeReq>(
            "UserOrderTakeReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderTakeReq {
    const NAME: &'static str = "UserOrderTakeReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = is.read_int32()?;
                },
                18 => {
                    self.access_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.order_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.order_id);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.order_id != 0 {
            os.write_int32(1, self.order_id)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(2, &self.access_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderTakeReq {
        UserOrderTakeReq::new()
    }

    fn clear(&mut self) {
        self.order_id = 0;
        self.access_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderTakeReq {
        static instance: UserOrderTakeReq = UserOrderTakeReq {
            order_id: 0,
            access_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderTakeReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderTakeReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderTakeReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderTakeReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderTakeRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderTakeRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderTakeRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderTakeRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderTakeRsp {
    fn default() -> &'a UserOrderTakeRsp {
        <UserOrderTakeRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderTakeRsp {
    pub fn new() -> UserOrderTakeRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderTakeRsp| { &m.ret },
            |m: &mut UserOrderTakeRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderTakeRsp>(
            "UserOrderTakeRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderTakeRsp {
    const NAME: &'static str = "UserOrderTakeRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderTakeRsp {
        UserOrderTakeRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderTakeRsp {
        static instance: UserOrderTakeRsp = UserOrderTakeRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderTakeRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderTakeRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderTakeRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderTakeRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderExpressReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderExpressReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderExpressReq.order_id)
    pub order_id: i32,
    // @@protoc_insertion_point(field:pbdef.UserOrderExpressReq.access_token)
    pub access_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderExpressReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderExpressReq {
    fn default() -> &'a UserOrderExpressReq {
        <UserOrderExpressReq as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderExpressReq {
    pub fn new() -> UserOrderExpressReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserOrderExpressReq| { &m.order_id },
            |m: &mut UserOrderExpressReq| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "access_token",
            |m: &UserOrderExpressReq| { &m.access_token },
            |m: &mut UserOrderExpressReq| { &mut m.access_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderExpressReq>(
            "UserOrderExpressReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderExpressReq {
    const NAME: &'static str = "UserOrderExpressReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = is.read_int32()?;
                },
                18 => {
                    self.access_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.order_id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.order_id);
        }
        if !self.access_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.access_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.order_id != 0 {
            os.write_int32(1, self.order_id)?;
        }
        if !self.access_token.is_empty() {
            os.write_string(2, &self.access_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderExpressReq {
        UserOrderExpressReq::new()
    }

    fn clear(&mut self) {
        self.order_id = 0;
        self.access_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderExpressReq {
        static instance: UserOrderExpressReq = UserOrderExpressReq {
            order_id: 0,
            access_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderExpressReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderExpressReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderExpressReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderExpressReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserOrderExpressRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserOrderExpressRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserOrderExpressRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserOrderExpressRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserOrderExpressRsp {
    fn default() -> &'a UserOrderExpressRsp {
        <UserOrderExpressRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserOrderExpressRsp {
    pub fn new() -> UserOrderExpressRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserOrderExpressRsp| { &m.ret },
            |m: &mut UserOrderExpressRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserOrderExpressRsp>(
            "UserOrderExpressRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserOrderExpressRsp {
    const NAME: &'static str = "UserOrderExpressRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserOrderExpressRsp {
        UserOrderExpressRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserOrderExpressRsp {
        static instance: UserOrderExpressRsp = UserOrderExpressRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserOrderExpressRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserOrderExpressRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserOrderExpressRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserOrderExpressRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressInfo {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressInfo.addressId)
    pub addressId: i32,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.realName)
    pub realName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.phone)
    pub phone: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.detail)
    pub detail: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.isDefault)
    pub isDefault: i32,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.province)
    pub province: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.city)
    pub city: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.district)
    pub district: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.street)
    pub street: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfo.postCode)
    pub postCode: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressInfo {
    fn default() -> &'a AddressInfo {
        <AddressInfo as ::protobuf::Message>::default_instance()
    }
}

impl AddressInfo {
    pub fn new() -> AddressInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addressId",
            |m: &AddressInfo| { &m.addressId },
            |m: &mut AddressInfo| { &mut m.addressId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realName",
            |m: &AddressInfo| { &m.realName },
            |m: &mut AddressInfo| { &mut m.realName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phone",
            |m: &AddressInfo| { &m.phone },
            |m: &mut AddressInfo| { &mut m.phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "detail",
            |m: &AddressInfo| { &m.detail },
            |m: &mut AddressInfo| { &mut m.detail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isDefault",
            |m: &AddressInfo| { &m.isDefault },
            |m: &mut AddressInfo| { &mut m.isDefault },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "province",
            |m: &AddressInfo| { &m.province },
            |m: &mut AddressInfo| { &mut m.province },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "city",
            |m: &AddressInfo| { &m.city },
            |m: &mut AddressInfo| { &mut m.city },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "district",
            |m: &AddressInfo| { &m.district },
            |m: &mut AddressInfo| { &mut m.district },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "street",
            |m: &AddressInfo| { &m.street },
            |m: &mut AddressInfo| { &mut m.street },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "postCode",
            |m: &AddressInfo| { &m.postCode },
            |m: &mut AddressInfo| { &mut m.postCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressInfo>(
            "AddressInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressInfo {
    const NAME: &'static str = "AddressInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.addressId = is.read_int32()?;
                },
                18 => {
                    self.realName = is.read_string()?;
                },
                26 => {
                    self.phone = is.read_string()?;
                },
                34 => {
                    self.detail = is.read_string()?;
                },
                40 => {
                    self.isDefault = is.read_int32()?;
                },
                50 => {
                    self.province = is.read_string()?;
                },
                58 => {
                    self.city = is.read_string()?;
                },
                66 => {
                    self.district = is.read_string()?;
                },
                74 => {
                    self.street = is.read_string()?;
                },
                80 => {
                    self.postCode = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.addressId != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.addressId);
        }
        if !self.realName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.realName);
        }
        if !self.phone.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.phone);
        }
        if !self.detail.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.detail);
        }
        if self.isDefault != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.isDefault);
        }
        if !self.province.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.province);
        }
        if !self.city.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.city);
        }
        if !self.district.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.district);
        }
        if !self.street.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.street);
        }
        if self.postCode != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.postCode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.addressId != 0 {
            os.write_int32(1, self.addressId)?;
        }
        if !self.realName.is_empty() {
            os.write_string(2, &self.realName)?;
        }
        if !self.phone.is_empty() {
            os.write_string(3, &self.phone)?;
        }
        if !self.detail.is_empty() {
            os.write_string(4, &self.detail)?;
        }
        if self.isDefault != 0 {
            os.write_int32(5, self.isDefault)?;
        }
        if !self.province.is_empty() {
            os.write_string(6, &self.province)?;
        }
        if !self.city.is_empty() {
            os.write_string(7, &self.city)?;
        }
        if !self.district.is_empty() {
            os.write_string(8, &self.district)?;
        }
        if !self.street.is_empty() {
            os.write_string(9, &self.street)?;
        }
        if self.postCode != 0 {
            os.write_int32(10, self.postCode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressInfo {
        AddressInfo::new()
    }

    fn clear(&mut self) {
        self.addressId = 0;
        self.realName.clear();
        self.phone.clear();
        self.detail.clear();
        self.isDefault = 0;
        self.province.clear();
        self.city.clear();
        self.district.clear();
        self.street.clear();
        self.postCode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressInfo {
        static instance: AddressInfo = AddressInfo {
            addressId: 0,
            realName: ::std::string::String::new(),
            phone: ::std::string::String::new(),
            detail: ::std::string::String::new(),
            isDefault: 0,
            province: ::std::string::String::new(),
            city: ::std::string::String::new(),
            district: ::std::string::String::new(),
            street: ::std::string::String::new(),
            postCode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressInfoSimple)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressInfoSimple {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.addressId)
    pub addressId: i32,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.realName)
    pub realName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.phone)
    pub phone: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.isDefault)
    pub isDefault: i32,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.province)
    pub province: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.city)
    pub city: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.district)
    pub district: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.street)
    pub street: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.AddressInfoSimple.postCode)
    pub postCode: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressInfoSimple.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressInfoSimple {
    fn default() -> &'a AddressInfoSimple {
        <AddressInfoSimple as ::protobuf::Message>::default_instance()
    }
}

impl AddressInfoSimple {
    pub fn new() -> AddressInfoSimple {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addressId",
            |m: &AddressInfoSimple| { &m.addressId },
            |m: &mut AddressInfoSimple| { &mut m.addressId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realName",
            |m: &AddressInfoSimple| { &m.realName },
            |m: &mut AddressInfoSimple| { &mut m.realName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phone",
            |m: &AddressInfoSimple| { &m.phone },
            |m: &mut AddressInfoSimple| { &mut m.phone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "isDefault",
            |m: &AddressInfoSimple| { &m.isDefault },
            |m: &mut AddressInfoSimple| { &mut m.isDefault },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "province",
            |m: &AddressInfoSimple| { &m.province },
            |m: &mut AddressInfoSimple| { &mut m.province },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "city",
            |m: &AddressInfoSimple| { &m.city },
            |m: &mut AddressInfoSimple| { &mut m.city },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "district",
            |m: &AddressInfoSimple| { &m.district },
            |m: &mut AddressInfoSimple| { &mut m.district },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "street",
            |m: &AddressInfoSimple| { &m.street },
            |m: &mut AddressInfoSimple| { &mut m.street },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "postCode",
            |m: &AddressInfoSimple| { &m.postCode },
            |m: &mut AddressInfoSimple| { &mut m.postCode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressInfoSimple>(
            "AddressInfoSimple",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressInfoSimple {
    const NAME: &'static str = "AddressInfoSimple";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.addressId = is.read_int32()?;
                },
                18 => {
                    self.realName = is.read_string()?;
                },
                26 => {
                    self.phone = is.read_string()?;
                },
                40 => {
                    self.isDefault = is.read_int32()?;
                },
                50 => {
                    self.province = is.read_string()?;
                },
                58 => {
                    self.city = is.read_string()?;
                },
                66 => {
                    self.district = is.read_string()?;
                },
                74 => {
                    self.street = is.read_string()?;
                },
                80 => {
                    self.postCode = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.addressId != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.addressId);
        }
        if !self.realName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.realName);
        }
        if !self.phone.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.phone);
        }
        if self.isDefault != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.isDefault);
        }
        if !self.province.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.province);
        }
        if !self.city.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.city);
        }
        if !self.district.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.district);
        }
        if !self.street.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.street);
        }
        if self.postCode != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.postCode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.addressId != 0 {
            os.write_int32(1, self.addressId)?;
        }
        if !self.realName.is_empty() {
            os.write_string(2, &self.realName)?;
        }
        if !self.phone.is_empty() {
            os.write_string(3, &self.phone)?;
        }
        if self.isDefault != 0 {
            os.write_int32(5, self.isDefault)?;
        }
        if !self.province.is_empty() {
            os.write_string(6, &self.province)?;
        }
        if !self.city.is_empty() {
            os.write_string(7, &self.city)?;
        }
        if !self.district.is_empty() {
            os.write_string(8, &self.district)?;
        }
        if !self.street.is_empty() {
            os.write_string(9, &self.street)?;
        }
        if self.postCode != 0 {
            os.write_int32(10, self.postCode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressInfoSimple {
        AddressInfoSimple::new()
    }

    fn clear(&mut self) {
        self.addressId = 0;
        self.realName.clear();
        self.phone.clear();
        self.isDefault = 0;
        self.province.clear();
        self.city.clear();
        self.district.clear();
        self.street.clear();
        self.postCode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressInfoSimple {
        static instance: AddressInfoSimple = AddressInfoSimple {
            addressId: 0,
            realName: ::std::string::String::new(),
            phone: ::std::string::String::new(),
            isDefault: 0,
            province: ::std::string::String::new(),
            city: ::std::string::String::new(),
            district: ::std::string::String::new(),
            street: ::std::string::String::new(),
            postCode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressInfoSimple {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressInfoSimple").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressInfoSimple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressInfoSimple {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CreateAddressReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateAddressReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CreateAddressReq.info)
    pub info: ::protobuf::MessageField<AddressInfo>,
    // @@protoc_insertion_point(field:pbdef.CreateAddressReq.phpUid)
    pub phpUid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CreateAddressReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateAddressReq {
    fn default() -> &'a CreateAddressReq {
        <CreateAddressReq as ::protobuf::Message>::default_instance()
    }
}

impl CreateAddressReq {
    pub fn new() -> CreateAddressReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AddressInfo>(
            "info",
            |m: &CreateAddressReq| { &m.info },
            |m: &mut CreateAddressReq| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &CreateAddressReq| { &m.phpUid },
            |m: &mut CreateAddressReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateAddressReq>(
            "CreateAddressReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateAddressReq {
    const NAME: &'static str = "CreateAddressReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                16 => {
                    self.phpUid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.phpUid != 0 {
            os.write_uint64(2, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateAddressReq {
        CreateAddressReq::new()
    }

    fn clear(&mut self) {
        self.info.clear();
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateAddressReq {
        static instance: CreateAddressReq = CreateAddressReq {
            info: ::protobuf::MessageField::none(),
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateAddressReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateAddressReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateAddressReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAddressReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CreateAddressRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CreateAddressRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CreateAddressRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CreateAddressRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateAddressRsp {
    fn default() -> &'a CreateAddressRsp {
        <CreateAddressRsp as ::protobuf::Message>::default_instance()
    }
}

impl CreateAddressRsp {
    pub fn new() -> CreateAddressRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CreateAddressRsp| { &m.ret },
            |m: &mut CreateAddressRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateAddressRsp>(
            "CreateAddressRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateAddressRsp {
    const NAME: &'static str = "CreateAddressRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateAddressRsp {
        CreateAddressRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateAddressRsp {
        static instance: CreateAddressRsp = CreateAddressRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateAddressRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateAddressRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateAddressRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAddressRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressListReq.phpUid)
    pub phpUid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressListReq {
    fn default() -> &'a AddressListReq {
        <AddressListReq as ::protobuf::Message>::default_instance()
    }
}

impl AddressListReq {
    pub fn new() -> AddressListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &AddressListReq| { &m.phpUid },
            |m: &mut AddressListReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressListReq>(
            "AddressListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressListReq {
    const NAME: &'static str = "AddressListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.phpUid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.phpUid != 0 {
            os.write_uint64(2, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressListReq {
        AddressListReq::new()
    }

    fn clear(&mut self) {
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressListReq {
        static instance: AddressListReq = AddressListReq {
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.AddressListRsp.infos)
    pub infos: ::std::vec::Vec<AddressInfoSimple>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressListRsp {
    fn default() -> &'a AddressListRsp {
        <AddressListRsp as ::protobuf::Message>::default_instance()
    }
}

impl AddressListRsp {
    pub fn new() -> AddressListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &AddressListRsp| { &m.ret },
            |m: &mut AddressListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &AddressListRsp| { &m.infos },
            |m: &mut AddressListRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressListRsp>(
            "AddressListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressListRsp {
    const NAME: &'static str = "AddressListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressListRsp {
        AddressListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressListRsp {
        static instance: AddressListRsp = AddressListRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressDetailReq.addressId)
    pub addressId: i32,
    // @@protoc_insertion_point(field:pbdef.AddressDetailReq.phpUid)
    pub phpUid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressDetailReq {
    fn default() -> &'a AddressDetailReq {
        <AddressDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl AddressDetailReq {
    pub fn new() -> AddressDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addressId",
            |m: &AddressDetailReq| { &m.addressId },
            |m: &mut AddressDetailReq| { &mut m.addressId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &AddressDetailReq| { &m.phpUid },
            |m: &mut AddressDetailReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressDetailReq>(
            "AddressDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressDetailReq {
    const NAME: &'static str = "AddressDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.addressId = is.read_int32()?;
                },
                16 => {
                    self.phpUid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.addressId != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.addressId);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.addressId != 0 {
            os.write_int32(1, self.addressId)?;
        }
        if self.phpUid != 0 {
            os.write_uint64(2, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressDetailReq {
        AddressDetailReq::new()
    }

    fn clear(&mut self) {
        self.addressId = 0;
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressDetailReq {
        static instance: AddressDetailReq = AddressDetailReq {
            addressId: 0,
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.AddressDetailRsp.info)
    pub info: ::protobuf::MessageField<AddressInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressDetailRsp {
    fn default() -> &'a AddressDetailRsp {
        <AddressDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl AddressDetailRsp {
    pub fn new() -> AddressDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &AddressDetailRsp| { &m.ret },
            |m: &mut AddressDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AddressInfo>(
            "info",
            |m: &AddressDetailRsp| { &m.info },
            |m: &mut AddressDetailRsp| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressDetailRsp>(
            "AddressDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressDetailRsp {
    const NAME: &'static str = "AddressDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressDetailRsp {
        AddressDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressDetailRsp {
        static instance: AddressDetailRsp = AddressDetailRsp {
            ret: 0,
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressDelReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressDelReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressDelReq.addressId)
    pub addressId: i32,
    // @@protoc_insertion_point(field:pbdef.AddressDelReq.phpUid)
    pub phpUid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressDelReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressDelReq {
    fn default() -> &'a AddressDelReq {
        <AddressDelReq as ::protobuf::Message>::default_instance()
    }
}

impl AddressDelReq {
    pub fn new() -> AddressDelReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "addressId",
            |m: &AddressDelReq| { &m.addressId },
            |m: &mut AddressDelReq| { &mut m.addressId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phpUid",
            |m: &AddressDelReq| { &m.phpUid },
            |m: &mut AddressDelReq| { &mut m.phpUid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressDelReq>(
            "AddressDelReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressDelReq {
    const NAME: &'static str = "AddressDelReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.addressId = is.read_int32()?;
                },
                16 => {
                    self.phpUid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.addressId != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.addressId);
        }
        if self.phpUid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.phpUid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.addressId != 0 {
            os.write_int32(1, self.addressId)?;
        }
        if self.phpUid != 0 {
            os.write_uint64(2, self.phpUid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressDelReq {
        AddressDelReq::new()
    }

    fn clear(&mut self) {
        self.addressId = 0;
        self.phpUid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressDelReq {
        static instance: AddressDelReq = AddressDelReq {
            addressId: 0,
            phpUid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressDelReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressDelReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressDelReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressDelReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddressDelRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddressDelRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.AddressDelRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddressDelRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddressDelRsp {
    fn default() -> &'a AddressDelRsp {
        <AddressDelRsp as ::protobuf::Message>::default_instance()
    }
}

impl AddressDelRsp {
    pub fn new() -> AddressDelRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &AddressDelRsp| { &m.ret },
            |m: &mut AddressDelRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddressDelRsp>(
            "AddressDelRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddressDelRsp {
    const NAME: &'static str = "AddressDelRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddressDelRsp {
        AddressDelRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddressDelRsp {
        static instance: AddressDelRsp = AddressDelRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddressDelRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddressDelRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddressDelRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressDelRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductReplyReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductReplyReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ProductReplyReq.id)
    pub id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductReplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductReplyReq {
    fn default() -> &'a ProductReplyReq {
        <ProductReplyReq as ::protobuf::Message>::default_instance()
    }
}

impl ProductReplyReq {
    pub fn new() -> ProductReplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ProductReplyReq| { &m.id },
            |m: &mut ProductReplyReq| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductReplyReq>(
            "ProductReplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductReplyReq {
    const NAME: &'static str = "ProductReplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductReplyReq {
        ProductReplyReq::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductReplyReq {
        static instance: ProductReplyReq = ProductReplyReq {
            id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductReplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductReplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductReplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductReplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ProductReplyRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProductReplyRsp {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ProductReplyRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProductReplyRsp {
    fn default() -> &'a ProductReplyRsp {
        <ProductReplyRsp as ::protobuf::Message>::default_instance()
    }
}

impl ProductReplyRsp {
    pub fn new() -> ProductReplyRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProductReplyRsp>(
            "ProductReplyRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProductReplyRsp {
    const NAME: &'static str = "ProductReplyRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProductReplyRsp {
        ProductReplyRsp::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProductReplyRsp {
        static instance: ProductReplyRsp = ProductReplyRsp {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProductReplyRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProductReplyRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProductReplyRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProductReplyRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddReplyReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddReplyReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddReplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddReplyReq {
    fn default() -> &'a AddReplyReq {
        <AddReplyReq as ::protobuf::Message>::default_instance()
    }
}

impl AddReplyReq {
    pub fn new() -> AddReplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddReplyReq>(
            "AddReplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddReplyReq {
    const NAME: &'static str = "AddReplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddReplyReq {
        AddReplyReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddReplyReq {
        static instance: AddReplyReq = AddReplyReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddReplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddReplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddReplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddReplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.AddReplyRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AddReplyRsp {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.AddReplyRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AddReplyRsp {
    fn default() -> &'a AddReplyRsp {
        <AddReplyRsp as ::protobuf::Message>::default_instance()
    }
}

impl AddReplyRsp {
    pub fn new() -> AddReplyRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AddReplyRsp>(
            "AddReplyRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AddReplyRsp {
    const NAME: &'static str = "AddReplyRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AddReplyRsp {
        AddReplyRsp::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AddReplyRsp {
        static instance: AddReplyRsp = AddReplyRsp {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AddReplyRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AddReplyRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AddReplyRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddReplyRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerchantShiYiListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerchantShiYiListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MerchantShiYiListReq.mer_id)
    pub mer_id: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerchantShiYiListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerchantShiYiListReq {
    fn default() -> &'a MerchantShiYiListReq {
        <MerchantShiYiListReq as ::protobuf::Message>::default_instance()
    }
}

impl MerchantShiYiListReq {
    pub fn new() -> MerchantShiYiListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mer_id",
            |m: &MerchantShiYiListReq| { &m.mer_id },
            |m: &mut MerchantShiYiListReq| { &mut m.mer_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerchantShiYiListReq>(
            "MerchantShiYiListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerchantShiYiListReq {
    const NAME: &'static str = "MerchantShiYiListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mer_id = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.mer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.mer_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.mer_id.is_empty() {
            os.write_string(1, &self.mer_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerchantShiYiListReq {
        MerchantShiYiListReq::new()
    }

    fn clear(&mut self) {
        self.mer_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerchantShiYiListReq {
        static instance: MerchantShiYiListReq = MerchantShiYiListReq {
            mer_id: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerchantShiYiListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerchantShiYiListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerchantShiYiListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerchantShiYiListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerchantShiYiListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerchantShiYiListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MerchantShiYiListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.MerchantShiYiListRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MerchantShiYiListRsp.lists)
    pub lists: ::std::vec::Vec<MerchantItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerchantShiYiListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerchantShiYiListRsp {
    fn default() -> &'a MerchantShiYiListRsp {
        <MerchantShiYiListRsp as ::protobuf::Message>::default_instance()
    }
}

impl MerchantShiYiListRsp {
    pub fn new() -> MerchantShiYiListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &MerchantShiYiListRsp| { &m.ret },
            |m: &mut MerchantShiYiListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &MerchantShiYiListRsp| { &m.msg },
            |m: &mut MerchantShiYiListRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &MerchantShiYiListRsp| { &m.lists },
            |m: &mut MerchantShiYiListRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerchantShiYiListRsp>(
            "MerchantShiYiListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerchantShiYiListRsp {
    const NAME: &'static str = "MerchantShiYiListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerchantShiYiListRsp {
        MerchantShiYiListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg.clear();
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerchantShiYiListRsp {
        static instance: MerchantShiYiListRsp = MerchantShiYiListRsp {
            ret: 0,
            msg: ::std::string::String::new(),
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerchantShiYiListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerchantShiYiListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerchantShiYiListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerchantShiYiListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MerchantItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MerchantItem {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MerchantItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MerchantItem {
    fn default() -> &'a MerchantItem {
        <MerchantItem as ::protobuf::Message>::default_instance()
    }
}

impl MerchantItem {
    pub fn new() -> MerchantItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MerchantItem>(
            "MerchantItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MerchantItem {
    const NAME: &'static str = "MerchantItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MerchantItem {
        MerchantItem::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MerchantItem {
        static instance: MerchantItem = MerchantItem {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MerchantItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MerchantItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MerchantItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MerchantItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserWalletRechargeReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserWalletRechargeReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserWalletRechargeReq.recharge_acount)
    pub recharge_acount: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserWalletRechargeReq.php_uid)
    pub php_uid: i32,
    // @@protoc_insertion_point(field:pbdef.UserWalletRechargeReq.php_token)
    pub php_token: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserWalletRechargeReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserWalletRechargeReq {
    fn default() -> &'a UserWalletRechargeReq {
        <UserWalletRechargeReq as ::protobuf::Message>::default_instance()
    }
}

impl UserWalletRechargeReq {
    pub fn new() -> UserWalletRechargeReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recharge_acount",
            |m: &UserWalletRechargeReq| { &m.recharge_acount },
            |m: &mut UserWalletRechargeReq| { &mut m.recharge_acount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_uid",
            |m: &UserWalletRechargeReq| { &m.php_uid },
            |m: &mut UserWalletRechargeReq| { &mut m.php_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_token",
            |m: &UserWalletRechargeReq| { &m.php_token },
            |m: &mut UserWalletRechargeReq| { &mut m.php_token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserWalletRechargeReq>(
            "UserWalletRechargeReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserWalletRechargeReq {
    const NAME: &'static str = "UserWalletRechargeReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.recharge_acount = is.read_string()?;
                },
                16 => {
                    self.php_uid = is.read_int32()?;
                },
                26 => {
                    self.php_token = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.recharge_acount.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.recharge_acount);
        }
        if self.php_uid != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.php_uid);
        }
        if !self.php_token.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.php_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.recharge_acount.is_empty() {
            os.write_string(1, &self.recharge_acount)?;
        }
        if self.php_uid != 0 {
            os.write_int32(2, self.php_uid)?;
        }
        if !self.php_token.is_empty() {
            os.write_string(3, &self.php_token)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserWalletRechargeReq {
        UserWalletRechargeReq::new()
    }

    fn clear(&mut self) {
        self.recharge_acount.clear();
        self.php_uid = 0;
        self.php_token.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserWalletRechargeReq {
        static instance: UserWalletRechargeReq = UserWalletRechargeReq {
            recharge_acount: ::std::string::String::new(),
            php_uid: 0,
            php_token: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserWalletRechargeReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserWalletRechargeReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserWalletRechargeReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserWalletRechargeReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserWalletRechargeRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserWalletRechargeRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserWalletRechargeRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.UserWalletRechargeRsp.order_id)
    pub order_id: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserWalletRechargeRsp.payment_url)
    pub payment_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserWalletRechargeRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserWalletRechargeRsp {
    fn default() -> &'a UserWalletRechargeRsp {
        <UserWalletRechargeRsp as ::protobuf::Message>::default_instance()
    }
}

impl UserWalletRechargeRsp {
    pub fn new() -> UserWalletRechargeRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &UserWalletRechargeRsp| { &m.ret },
            |m: &mut UserWalletRechargeRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_id",
            |m: &UserWalletRechargeRsp| { &m.order_id },
            |m: &mut UserWalletRechargeRsp| { &mut m.order_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "payment_url",
            |m: &UserWalletRechargeRsp| { &m.payment_url },
            |m: &mut UserWalletRechargeRsp| { &mut m.payment_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserWalletRechargeRsp>(
            "UserWalletRechargeRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserWalletRechargeRsp {
    const NAME: &'static str = "UserWalletRechargeRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.order_id = is.read_string()?;
                },
                26 => {
                    self.payment_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if !self.order_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.order_id);
        }
        if !self.payment_url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.payment_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if !self.order_id.is_empty() {
            os.write_string(2, &self.order_id)?;
        }
        if !self.payment_url.is_empty() {
            os.write_string(3, &self.payment_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserWalletRechargeRsp {
        UserWalletRechargeRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.order_id.clear();
        self.payment_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserWalletRechargeRsp {
        static instance: UserWalletRechargeRsp = UserWalletRechargeRsp {
            ret: 0,
            order_id: ::std::string::String::new(),
            payment_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserWalletRechargeRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserWalletRechargeRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserWalletRechargeRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserWalletRechargeRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eMerchant.proto\x12\x05pbdef\x1a\x0eUserData.protoP\0\"\xda\x01\n\
    \x10PlaceontainerReq\x12\"\n\x0ccollectionId\x18\x01\x20\x01(\x05R\x0cco\
    llectionId\x12\x14\n\x05mapId\x18\x02\x20\x01(\x05R\x05mapId\x12\x1a\n\
    \x08position\x18\x03\x20\x01(\x05R\x08position\x12\x16\n\x06shopId\x18\
    \x04\x20\x01(\x05R\x06shopId\x12\x14\n\x05usage\x18\x05\x20\x01(\x05R\
    \x05usage\x12*\n\x10userCollectionId\x18\x06\x20\x01(\x05R\x10userCollec\
    tionId\x12\x16\n\x06userId\x18\x07\x20\x01(\x05R\x06userId\">\n\x10Place\
    ontainerRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x18\n\x07m\
    essage\x18\x02\x20\x01(\tR\x07message\"O\n\nLstMallReq\x12\x17\n\x07land\
    _id\x18\x01\x20\x01(\x04R\x06landId\x12\x12\n\x04page\x18\x02\x20\x01(\r\
    R\x04page\x12\x14\n\x05limit\x18\x03\x20\x01(\rR\x05limit\"`\n\nLstMallR\
    sp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message\x12&\n\x04data\x18\x03\x20\x01(\x0b2\x12\
    .pbdef.LstMallDataR\x04data\"c\n\x0bLstMallData\x12\x14\n\x05count\x18\
    \x01\x20\x01(\x05R\x05count\x12>\n\x10LstMallItemLists\x18\x02\x20\x03(\
    \x0b2\x12.pbdef.LstMallItemR\x10LstMallItemLists\"\xdc\x02\n\x0bLstMallI\
    tem\x12\x1d\n\ncare_count\x18\x01\x20\x01(\x05R\tcareCount\x12\x1b\n\tis\
    _trader\x18\x02\x20\x01(\x05R\x08isTrader\x12\x17\n\x07type_id\x18\x03\
    \x20\x01(\x05R\x06typeId\x12\x15\n\x06mer_id\x18\x04\x20\x01(\x05R\x05me\
    rId\x12\x1d\n\nmer_banner\x18\x05\x20\x01(\tR\tmerBanner\x12\x1f\n\x0bmi\
    ni_banner\x18\x06\x20\x01(\tR\nminiBanner\x12\x19\n\x08mer_name\x18\x07\
    \x20\x01(\tR\x07merName\x12\x1d\n\nmer_avatar\x18\x08\x20\x01(\tR\tmerAv\
    atar\x12J\n\x14CollectionsInfoLists\x18\t\x20\x03(\x0b2\x16.pbdef.Collec\
    tionsInfoR\x14CollectionsInfoLists\x12\x1b\n\ttype_name\x18\n\x20\x01(\t\
    R\x08typeName\"\x7f\n\x0fCollectionsInfo\x12\x0e\n\x02id\x18\x01\x20\x01\
    (\tR\x02id\x12\x1a\n\x08position\x18\x02\x20\x01(\x05R\x08position\x12\
    \x14\n\x05usage\x18\x03\x20\x01(\x05R\x05usage\x12*\n\x10userCollectionI\
    d\x18\x04\x20\x01(\x05R\x10userCollectionId\">\n\x0cMerDetailReq\x12\x15\
    \n\x06mer_id\x18\x01\x20\x01(\rR\x05merId\x12\x17\n\x07php_uid\x18\x02\
    \x20\x01(\x05R\x06phpUid\"d\n\x0cMerDetailRsp\x12\x10\n\x03ret\x18\x01\
    \x20\x01(\x05R\x03ret\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07messag\
    e\x12(\n\x04data\x18\x03\x20\x01(\x0b2\x14.pbdef.MerDetailDataR\x04data\
    \"\xd9\n\n\rMerDetailData\x12\x15\n\x06mer_id\x18\x01\x20\x01(\rR\x05mer\
    Id\x12\x1f\n\x0bcategory_id\x18\x02\x20\x01(\x05R\ncategoryId\x12\x17\n\
    \x07type_id\x18\x03\x20\x01(\x05R\x06typeId\x12\x19\n\x08mer_name\x18\
    \x04\x20\x01(\tR\x07merName\x12\x1d\n\nmer_adress\x18\x05\x20\x01(\tR\tm\
    erAdress\x12\x1f\n\x0bmer_keyword\x18\x06\x20\x01(\tR\nmerKeyword\x12\
    \x1d\n\nmer_avatar\x18\x07\x20\x01(\tR\tmerAvatar\x12\x1d\n\nmer_banner\
    \x18\x08\x20\x01(\tR\tmerBanner\x12\x1f\n\x0bmini_banner\x18\t\x20\x01(\
    \tR\nminiBanner\x12\x14\n\x05sales\x18\n\x20\x01(\x05R\x05sales\x12#\n\r\
    product_score\x18\x0b\x20\x01(\tR\x0cproductScore\x12#\n\rservice_score\
    \x18\x0c\x20\x01(\tR\x0cserviceScore\x12#\n\rpostage_score\x18\r\x20\x01\
    (\tR\x0cpostageScore\x12\x12\n\x04mark\x18\x0e\x20\x01(\tR\x04mark\x12\
    \x16\n\x06status\x18\x0f\x20\x01(\x05R\x06status\x12'\n\x0fcommission_ra\
    te\x18\x10\x20\x01(\tR\x0ecommissionRate\x12\x12\n\x04long\x18\x11\x20\
    \x01(\tR\x04long\x12\x10\n\x03lat\x18\x12\x20\x01(\tR\x03lat\x12\x1e\n\
    \x0bis_bro_room\x18\x13\x20\x01(\x05R\tisBroRoom\x12\x20\n\x0cis_bro_goo\
    ds\x18\x14\x20\x01(\x05R\nisBroGoods\x12\x1b\n\tis_trader\x18\x15\x20\
    \x01(\x05R\x08isTrader\x12\x19\n\x08mer_info\x18\x16\x20\x01(\tR\x07merI\
    nfo\x12#\n\rservice_phone\x18\x17\x20\x01(\tR\x0cservicePhone\x12\x1f\n\
    \x0bcreate_time\x18\x18\x20\x01(\tR\ncreateTime\x12\x1d\n\ncare_count\
    \x18\x19\x20\x01(\x05R\tcareCount\x12(\n\x10copy_product_num\x18\x1a\x20\
    \x01(\x05R\x0ecopyProductNum\x12&\n\x0fexport_dump_num\x18\x1b\x20\x01(\
    \x05R\rexportDumpNum\x12\x1b\n\tmer_money\x18\x1c\x20\x01(\tR\x08merMone\
    y\x12\x1b\n\tsub_mchid\x18\x1d\x20\x01(\tR\x08subMchid\x12!\n\x0cdeliver\
    y_way\x18\x1e\x20\x01(\tR\x0bdeliveryWay\x12\x16\n\x06margin\x18\x1f\x20\
    \x01(\tR\x06margin\x12\x1b\n\tis_margin\x18\x20\x20\x01(\x05R\x08isMargi\
    n\x12)\n\x10delivery_balance\x18!\x20\x01(\tR\x0fdeliveryBalance\x12\x1b\
    \n\tot_margin\x18\"\x20\x01(\tR\x08otMargin\x12!\n\x0cservice_time\x18#\
    \x20\x01(\tR\x0bserviceTime\x12$\n\x0esystem_city_id\x18$\x20\x01(\x05R\
    \x0csystemCityId\x12\x12\n\x04care\x18%\x20\x01(\x08R\x04care\x12(\n\x10\
    mer_take_address\x18&\x20\x01(\tR\x0emerTakeAddress\x12#\n\rprovince_nam\
    e\x18'\x20\x01(\tR\x0cprovinceName\x12\x1b\n\tcity_name\x18(\x20\x01(\tR\
    \x08cityName\x12\x1b\n\ttype_name\x18)\x20\x01(\tR\x08typeName\x12#\n\rs\
    ervices_type\x18+\x20\x01(\tR\x0cservicesType\x12'\n\x0fmer_certificate\
    \x18,\x20\x01(\tR\x0emerCertificate\"(\n\x0fCategoryListReq\x12\x15\n\
    \x06mer_id\x18\x01\x20\x01(\x05R\x05merId\"^\n\x0fCategoryListRsp\x12\
    \x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x10\n\x03msg\x18\x02\x20\
    \x01(\tR\x03msg\x12'\n\x04data\x18\x03\x20\x03(\x0b2\x13.pbdef.CategoryD\
    ataR\x04data\"\x80\x01\n\x0cCategoryData\x12*\n\x11store_category_id\x18\
    \x01\x20\x01(\x05R\x0fstoreCategoryId\x12\x1b\n\tcate_name\x18\x02\x20\
    \x01(\tR\x08cateName\x12'\n\x04data\x18\x03\x20\x03(\x0b2\x13.pbdef.Cate\
    goryDataR\x04data\"*\n\x11CategoryDetailReq\x12\x15\n\x06mer_id\x18\x01\
    \x20\x01(\rR\x05merId\"b\n\x11CategoryDetailRsp\x12\x10\n\x03ret\x18\x01\
    \x20\x01(\x05R\x03ret\x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03msg\x12)\n\
    \x04data\x18\x03\x20\x01(\x0b2\x15.pbdef.CateDetailDataR\x04data\"\x10\n\
    \x0eCateDetailData\"\x87\x01\n\x0eProductListReq\x12\x15\n\x06mer_id\x18\
    \x01\x20\x01(\rR\x05merId\x12\x14\n\x05order\x18\x02\x20\x01(\tR\x05orde\
    r\x12\x1e\n\x0bmer_cate_id\x18\x03\x20\x01(\x05R\tmerCateId\x12\x12\n\
    \x04page\x18\x04\x20\x01(\x05R\x04page\x12\x14\n\x05limit\x18\x05\x20\
    \x01(\x05R\x05limit\"\\\n\x0eProductListRsp\x12\x10\n\x03ret\x18\x01\x20\
    \x01(\x05R\x03ret\x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03msg\x12&\n\x04\
    data\x18\x03\x20\x01(\x0b2\x12.pbdef.ProductDataR\x04data\"\x8c\x01\n\
    \x0bProductData\x12\x14\n\x05count\x18\x01\x20\x01(\x05R\x05count\x12&\n\
    \x04list\x18\x02\x20\x03(\x0b2\x12.pbdef.ProductItemR\x04list\x12?\n\x0e\
    mer_chant_info\x18\x03\x20\x01(\x0b2\x19.pbdef.MerChantSimpleDataR\x0cme\
    rChantInfo\"\xce\x02\n\x12MerChantSimpleData\x12\x1b\n\tis_trader\x18\
    \x01\x20\x01(\x05R\x08isTrader\x12\x17\n\x07type_id\x18\x02\x20\x01(\x05\
    R\x06typeId\x12\x15\n\x06mer_id\x18\x03\x20\x01(\x05R\x05merId\x12\x19\n\
    \x08mer_name\x18\x04\x20\x01(\tR\x07merName\x12\x1d\n\nmer_avatar\x18\
    \x05\x20\x01(\tR\tmerAvatar\x12#\n\rproduct_score\x18\x06\x20\x01(\tR\
    \x0cproductScore\x12#\n\rservice_score\x18\x07\x20\x01(\tR\x0cserviceSco\
    re\x12#\n\rpostage_score\x18\x08\x20\x01(\tR\x0cpostageScore\x12#\n\rser\
    vice_phone\x18\t\x20\x01(\tR\x0cservicePhone\x12\x1d\n\ncare_count\x18\n\
    \x20\x01(\x05R\tcareCount\"\x9e\x04\n\x0bProductItem\x12'\n\x0fexpiratio\
    n_time\x18\x01\x20\x01(\x05R\x0eexpirationTime\x12\x1d\n\nproduct_id\x18\
    \x02\x20\x01(\x05R\tproductId\x12\x15\n\x06mer_id\x18\x03\x20\x01(\x05R\
    \x05merId\x12\x19\n\x08brand_id\x18\x04\x20\x01(\x05R\x07brandId\x12\x12\
    \n\x04type\x18\x05\x20\x01(\x05R\x04type\x12\x1b\n\tspec_type\x18\x06\
    \x20\x01(\x05R\x08specType\x12\x1b\n\tunit_name\x18\x07\x20\x01(\tR\x08u\
    nitName\x12\x1d\n\nmer_status\x18\x08\x20\x01(\x05R\tmerStatus\x12\x12\n\
    \x04rate\x18\t\x20\x01(\tR\x04rate\x12\x1f\n\x0breply_count\x18\n\x20\
    \x01(\x05R\nreplyCount\x12\x1d\n\nstore_info\x18\x0b\x20\x01(\tR\tstoreI\
    nfo\x12\x17\n\x07cate_id\x18\x0c\x20\x01(\x05R\x06cateId\x12\x14\n\x05ia\
    mge\x18\r\x20\x01(\tR\x05iamge\x12!\n\x0cslider_image\x18\x0e\x20\x01(\t\
    R\x0bsliderImage\x12\x1d\n\nstore_name\x18\x0f\x20\x01(\tR\tstoreName\
    \x12\x14\n\x05sales\x18\x10\x20\x01(\x05R\x05sales\x12\x14\n\x05price\
    \x18\x11\x20\x01(\tR\x05price\x12\x14\n\x05stock\x18\x12\x20\x01(\x05R\
    \x05stock\x12!\n\x0cproduct_type\x18\x13\x20\x01(\x05R\x0bproductType\")\
    \n\x10ProductDetailReq\x12\x15\n\x06pro_id\x18\x01\x20\x01(\x05R\x05proI\
    d\"\xae\x01\n\x10ProductDetailRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03msg\x12&\n\x04data\x18\
    \x03\x20\x01(\x0b2\x12.pbdef.ProductItemR\x04data\x124\n\x08sku_list\x18\
    \x04\x20\x03(\x0b2\x19.pbdef.ProductSkuAttrItemR\x07skuList\x12\x18\n\
    \x07content\x18\x05\x20\x01(\tR\x07content\"*\n\x11ProductSkuListReq\x12\
    \x15\n\x06pro_id\x18\x01\x20\x01(\x05R\x05proId\"%\n\x11ProductSkuListRs\
    p\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"<\n\x12ProductSkuAttrIt\
    em\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04attr\x18\
    \x02\x20\x03(\tR\x04attr\"*\n\x11ProductContentReq\x12\x15\n\x06pro_id\
    \x18\x01\x20\x01(\x05R\x05proId\"?\n\x11ProductContentRsp\x12\x10\n\x03r\
    et\x18\x01\x20\x01(\x05R\x03ret\x12\x18\n\x07content\x18\x02\x20\x01(\tR\
    \x07content\">\n\x13ProductSkuDetailReq\x12\x15\n\x06pro_id\x18\x01\x20\
    \x01(\x05R\x05proId\x12\x10\n\x03sku\x18\x02\x20\x01(\tR\x03sku\"Y\n\x13\
    ProductSkuDetailRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x120\n\
    \x08sku_data\x18\x02\x20\x01(\x0b2\x15.pbdef.ProductSkuItemR\x07skuData\
    \"\xec\x01\n\x0eProductSkuItem\x12\x1d\n\nproduct_id\x18\x01\x20\x01(\
    \x05R\tproductId\x12\x16\n\x06imgage\x18\x02\x20\x01(\tR\x06imgage\x12\
    \x1a\n\x08integral\x18\x04\x20\x01(\x05R\x08integral\x12\x19\n\x08ot_pri\
    ce\x18\x05\x20\x01(\tR\x07otPrice\x12\x14\n\x05price\x18\x06\x20\x01(\tR\
    \x05price\x12\x14\n\x05stock\x18\x07\x20\x01(\x05R\x05stock\x12\x14\n\
    \x05sales\x18\x08\x20\x01(\x05R\x05sales\x12\x12\n\x04type\x18\t\x20\x01\
    (\x05R\x04type\x12\x16\n\x06unique\x18\n\x20\x01(\tR\x06unique\"P\n\x0bC\
    artListReq\x12\x14\n\x05limit\x18\x01\x20\x01(\x05R\x05limit\x12\x12\n\
    \x04page\x18\x02\x20\x01(\x05R\x04page\x12\x17\n\x07php_uid\x18\x03\x20\
    \x01(\x05R\x06phpUid\"V\n\x0bCartListRsp\x12\x10\n\x03ret\x18\x01\x20\
    \x01(\x05R\x03ret\x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03msg\x12#\n\x04\
    data\x18\x03\x20\x03(\x0b2\x0f.pbdef.CartItemR\x04data\"\x8d\x02\n\x08Ca\
    rtItem\x12\x15\n\x06mer_id\x18\x01\x20\x01(\x05R\x05merId\x12\x1d\n\npro\
    duct_id\x18\x02\x20\x01(\x05R\tproductId\x12\x19\n\x08cart_num\x18\x03\
    \x20\x01(\x05R\x07cartNum\x12\x1f\n\x0bcreate_time\x18\x04\x20\x01(\rR\n\
    createTime\x12.\n\x13product_attr_unique\x18\x05\x20\x01(\tR\x11productA\
    ttrUnique\x12-\n\x08pro_info\x18\x06\x20\x01(\x0b2\x12.pbdef.ProductItem\
    R\x07proInfo\x120\n\x08sku_info\x18\x07\x20\x01(\x0b2\x15.pbdef.ProductS\
    kuItemR\x07skuInfo\"\xa7\x02\n\rCartCreateReq\x12!\n\x0cproduct_type\x18\
    \x01\x20\x01(\x05R\x0bproductType\x12\x15\n\x06mer_id\x18\x02\x20\x01(\
    \x05R\x05merId\x12\x1d\n\nproduct_id\x18\x03\x20\x01(\x05R\tproductId\
    \x12.\n\x13product_attr_unique\x18\x04\x20\x01(\tR\x11productAttrUnique\
    \x12\x19\n\x08cart_num\x18\x05\x20\x01(\x05R\x07cartNum\x12\x15\n\x06is_\
    new\x18\x06\x20\x01(\x05R\x05isNew\x12\x1b\n\tspread_id\x18\x07\x20\x01(\
    \x05R\x08spreadId\x12&\n\x0fgroup_buying_id\x18\x08\x20\x01(\x05R\rgroup\
    BuyingId\x12\x16\n\x06phpUid\x18\t\x20\x01(\x05R\x06phpUid\"J\n\rCartCre\
    ateRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x10\n\x03msg\
    \x18\x02\x20\x01(\tR\x03msg\x12\x15\n\x06car_id\x18\x03\x20\x01(\tR\x05c\
    arId\"\x8b\x01\n\rCartChangeReq\x12\x17\n\x07cart_id\x18\x01\x20\x01(\
    \x05R\x06cartId\x12\x19\n\x08cart_num\x18\x02\x20\x01(\x05R\x07cartNum\
    \x12.\n\x13product_attr_unique\x18\x03\x20\x01(\tR\x11productAttrUnique\
    \x12\x16\n\x06phpUid\x18\x04\x20\x01(\x05R\x06phpUid\"3\n\rCartChangeRsp\
    \x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x10\n\x03msg\x18\x02\
    \x20\x01(\tR\x03msg\"B\n\rCartDeleteReq\x12\x19\n\x08cart_ids\x18\x01\
    \x20\x03(\x05R\x07cartIds\x12\x16\n\x06phpUid\x18\x02\x20\x01(\x05R\x06p\
    hpUid\"3\n\rCartDeleteRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\
    \x12\x10\n\x03msg\x18\x02\x20\x01(\tR\x03msg\"X\n\x11RelationCerateReq\
    \x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06typeId\x12\x12\n\x04type\
    \x18\x02\x20\x01(\x05R\x04type\x12\x16\n\x06phpUid\x18\x03\x20\x01(\x05R\
    \x06phpUid\"%\n\x11RelationCerateRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\
    \x05R\x03ret\"s\n\x0cRelationItem\x12\x17\n\x07type_id\x18\x01\x20\x01(\
    \x05R\x06typeId\x12\x12\n\x04type\x18\x02\x20\x01(\x05R\x04type\x12\x16\
    \n\x06phpUid\x18\x03\x20\x01(\x05R\x06phpUid\x12\x1e\n\ncreateTime\x18\
    \x04\x20\x01(\tR\ncreateTime\"0\n\x16RelationProductListReq\x12\x16\n\
    \x06phpUid\x18\x01\x20\x01(\x05R\x06phpUid\"U\n\x16RelationProductListRs\
    p\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12)\n\x05lists\x18\x02\
    \x20\x03(\x0b2\x13.pbdef.RelationItemR\x05lists\"\\\n\x15RelationProduct\
    DelReq\x12\x17\n\x07type_id\x18\x01\x20\x01(\x05R\x06typeId\x12\x12\n\
    \x04type\x18\x02\x20\x01(\x05R\x04type\x12\x16\n\x06phpUid\x18\x03\x20\
    \x01(\x05R\x06phpUid\")\n\x15RelationProductDelRsp\x12\x10\n\x03ret\x18\
    \x01\x20\x01(\x05R\x03ret\"U\n\x10UserOrderListReq\x12\x17\n\x07php_uid\
    \x18\x01\x20\x01(\x05R\x06phpUid\x12\x14\n\x05limit\x18\x02\x20\x01(\x05\
    R\x05limit\x12\x12\n\x04page\x18\x03\x20\x01(\x05R\x04page\"P\n\x10UserO\
    rderListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12*\n\x05list\
    s\x18\x02\x20\x03(\x0b2\x14.pbdef.UserOrderItemR\x05lists\"\xfd\x03\n\rU\
    serOrderItem\x12\x19\n\x08order_id\x18\x01\x20\x01(\x05R\x07orderId\x12\
    \x19\n\x08order_sn\x18\x02\x20\x01(\tR\x07orderSn\x12\x1a\n\x08realName\
    \x18\x03\x20\x01(\tR\x08realName\x12\x1d\n\nuser_phone\x18\x04\x20\x01(\
    \tR\tuserPhone\x12!\n\x0cuser_address\x18\x05\x20\x01(\tR\x0buserAddress\
    \x12\x1f\n\x0btotal_price\x18\x06\x20\x01(\tR\ntotalPrice\x12\x1b\n\tpay\
    _price\x18\x07\x20\x01(\tR\x08payPrice\x12#\n\rgive_integral\x18\x08\x20\
    \x01(\x05R\x0cgiveIntegral\x12\x1f\n\x0bcreate_time\x18\n\x20\x01(\tR\nc\
    reateTime\x12#\n\rproduct_image\x18\x0b\x20\x01(\tR\x0cproductImage\x12!\
    \n\x0cproduct_name\x18\x0c\x20\x01(\tR\x0bproductName\x12!\n\x0cproduct_\
    attr\x18\r\x20\x01(\tR\x0bproductAttr\x12#\n\rdelivery_name\x18\x0e\x20\
    \x01(\tR\x0cdeliveryName\x12\x1f\n\x0bdelivery_id\x18\x0f\x20\x01(\tR\nd\
    eliveryId\x12#\n\rdelivery_type\x18\x10\x20\x01(\tR\x0cdeliveryType\"/\n\
    \x12UserOrderDetailReq\x12\x19\n\x08order_id\x18\x01\x20\x01(\x05R\x07or\
    derId\"T\n\x12UserOrderDetailRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x12,\n\x06detail\x18\x02\x20\x01(\x0b2\x14.pbdef.UserOrderItemR\
    \x06detail\"\x88\x03\n\x12UserOrderCreateReq\x12\x17\n\x07cart_id\x18\
    \x01\x20\x01(\tR\x06cartId\x12\x1d\n\naddress_id\x18\x02\x20\x01(\x05R\t\
    addressId\x12\x1d\n\nuse_coupon\x18\x03\x20\x01(\tR\tuseCoupon\x12\x14\n\
    \x05takes\x18\x04\x20\x01(\tR\x05takes\x12!\n\x0cuse_integral\x18\x05\
    \x20\x01(\x05R\x0buseIntegral\x12!\n\x0creceipt_data\x18\x06\x20\x01(\tR\
    \x0breceiptData\x12\x16\n\x06extend\x18\x07\x20\x01(\tR\x06extend\x12\
    \x12\n\x04mark\x18\x08\x20\x01(\tR\x04mark\x12\x19\n\x08pay_type\x18\t\
    \x20\x01(\tR\x07payType\x12\x1d\n\nuser_phone\x18\n\x20\x01(\tR\tuserPho\
    ne\x12\x1d\n\norder_type\x18\x0b\x20\x01(\x05R\torderType\x12\x17\n\x07p\
    hp_uid\x18\x0c\x20\x01(\x05R\x06phpUid\x12!\n\x0caccess_token\x18\r\x20\
    \x01(\tR\x0baccessToken\"b\n\x12UserOrderCreateRsp\x12\x10\n\x03ret\x18\
    \x01\x20\x01(\x05R\x03ret\x12\x19\n\x08order_id\x18\x02\x20\x01(\tR\x07o\
    rderId\x12\x1f\n\x0bpayment_url\x18\x03\x20\x01(\tR\npaymentUrl\"\xa2\
    \x01\n\x11UserOrderCheckReq\x12\x17\n\x07cart_id\x18\x01\x20\x01(\tR\x06\
    cartId\x12\x1c\n\taddressId\x18\x02\x20\x01(\tR\taddressId\x12\x1d\n\nus\
    e_coupon\x18\x03\x20\x01(\tR\tuseCoupon\x12\x14\n\x05takes\x18\x04\x20\
    \x01(\tR\x05takes\x12!\n\x0caccess_token\x18\x05\x20\x01(\tR\x0baccessTo\
    ken\"%\n\x11UserOrderCheckRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03\
    ret\"O\n\x0fUserOrderDelReq\x12\x19\n\x08order_id\x18\x01\x20\x01(\x05R\
    \x07orderId\x12!\n\x0caccess_token\x18\x02\x20\x01(\tR\x0baccessToken\"#\
    \n\x0fUserOrderDelRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"j\n\
    \x0fUserOrderPayReq\x12\x19\n\x08order_id\x18\x01\x20\x01(\x05R\x07order\
    Id\x12\x19\n\x08cart_ids\x18\x02\x20\x01(\tR\x07cartIds\x12!\n\x0caccess\
    _token\x18\x03\x20\x01(\tR\x0baccessToken\"#\n\x0fUserOrderPayRsp\x12\
    \x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"P\n\x10UserOrderTakeReq\x12\
    \x19\n\x08order_id\x18\x01\x20\x01(\x05R\x07orderId\x12!\n\x0caccess_tok\
    en\x18\x02\x20\x01(\tR\x0baccessToken\"$\n\x10UserOrderTakeRsp\x12\x10\n\
    \x03ret\x18\x01\x20\x01(\x05R\x03ret\"S\n\x13UserOrderExpressReq\x12\x19\
    \n\x08order_id\x18\x01\x20\x01(\x05R\x07orderId\x12!\n\x0caccess_token\
    \x18\x02\x20\x01(\tR\x0baccessToken\"'\n\x13UserOrderExpressRsp\x12\x10\
    \n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"\x93\x02\n\x0bAddressInfo\x12\
    \x1c\n\taddressId\x18\x01\x20\x01(\x05R\taddressId\x12\x1a\n\x08realName\
    \x18\x02\x20\x01(\tR\x08realName\x12\x14\n\x05phone\x18\x03\x20\x01(\tR\
    \x05phone\x12\x16\n\x06detail\x18\x04\x20\x01(\tR\x06detail\x12\x1c\n\ti\
    sDefault\x18\x05\x20\x01(\x05R\tisDefault\x12\x1a\n\x08province\x18\x06\
    \x20\x01(\tR\x08province\x12\x12\n\x04city\x18\x07\x20\x01(\tR\x04city\
    \x12\x1a\n\x08district\x18\x08\x20\x01(\tR\x08district\x12\x16\n\x06stre\
    et\x18\t\x20\x01(\tR\x06street\x12\x1a\n\x08postCode\x18\n\x20\x01(\x05R\
    \x08postCode\"\x81\x02\n\x11AddressInfoSimple\x12\x1c\n\taddressId\x18\
    \x01\x20\x01(\x05R\taddressId\x12\x1a\n\x08realName\x18\x02\x20\x01(\tR\
    \x08realName\x12\x14\n\x05phone\x18\x03\x20\x01(\tR\x05phone\x12\x1c\n\t\
    isDefault\x18\x05\x20\x01(\x05R\tisDefault\x12\x1a\n\x08province\x18\x06\
    \x20\x01(\tR\x08province\x12\x12\n\x04city\x18\x07\x20\x01(\tR\x04city\
    \x12\x1a\n\x08district\x18\x08\x20\x01(\tR\x08district\x12\x16\n\x06stre\
    et\x18\t\x20\x01(\tR\x06street\x12\x1a\n\x08postCode\x18\n\x20\x01(\x05R\
    \x08postCode\"R\n\x10CreateAddressReq\x12&\n\x04info\x18\x01\x20\x01(\
    \x0b2\x12.pbdef.AddressInfoR\x04info\x12\x16\n\x06phpUid\x18\x02\x20\x01\
    (\x04R\x06phpUid\"$\n\x10CreateAddressRsp\x12\x10\n\x03ret\x18\x01\x20\
    \x01(\x05R\x03ret\"(\n\x0eAddressListReq\x12\x16\n\x06phpUid\x18\x02\x20\
    \x01(\x04R\x06phpUid\"R\n\x0eAddressListRsp\x12\x10\n\x03ret\x18\x01\x20\
    \x01(\x05R\x03ret\x12.\n\x05infos\x18\x02\x20\x03(\x0b2\x18.pbdef.Addres\
    sInfoSimpleR\x05infos\"H\n\x10AddressDetailReq\x12\x1c\n\taddressId\x18\
    \x01\x20\x01(\x05R\taddressId\x12\x16\n\x06phpUid\x18\x02\x20\x01(\x04R\
    \x06phpUid\"L\n\x10AddressDetailRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\
    \x05R\x03ret\x12&\n\x04info\x18\x02\x20\x01(\x0b2\x12.pbdef.AddressInfoR\
    \x04info\"E\n\rAddressDelReq\x12\x1c\n\taddressId\x18\x01\x20\x01(\x05R\
    \taddressId\x12\x16\n\x06phpUid\x18\x02\x20\x01(\x04R\x06phpUid\"!\n\rAd\
    dressDelRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"!\n\x0fProduc\
    tReplyReq\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\"\x11\n\x0fProductRe\
    plyRsp\"\r\n\x0bAddReplyReq\"\r\n\x0bAddReplyRsp\"-\n\x14MerchantShiYiLi\
    stReq\x12\x15\n\x06mer_id\x18\x01\x20\x01(\tR\x05merId\"e\n\x14MerchantS\
    hiYiListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x10\n\x03m\
    sg\x18\x02\x20\x01(\tR\x03msg\x12)\n\x05lists\x18\x03\x20\x03(\x0b2\x13.\
    pbdef.MerchantItemR\x05lists\"\x0e\n\x0cMerchantItem\"v\n\x15UserWalletR\
    echargeReq\x12'\n\x0frecharge_acount\x18\x01\x20\x01(\tR\x0erechargeAcou\
    nt\x12\x17\n\x07php_uid\x18\x02\x20\x01(\x05R\x06phpUid\x12\x1b\n\tphp_t\
    oken\x18\x03\x20\x01(\tR\x08phpToken\"e\n\x15UserWalletRechargeRsp\x12\
    \x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x19\n\x08order_id\x18\x02\
    \x20\x01(\tR\x07orderId\x12\x1f\n\x0bpayment_url\x18\x03\x20\x01(\tR\npa\
    ymentUrlb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::UserData::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(83);
            messages.push(PlaceontainerReq::generated_message_descriptor_data());
            messages.push(PlaceontainerRsp::generated_message_descriptor_data());
            messages.push(LstMallReq::generated_message_descriptor_data());
            messages.push(LstMallRsp::generated_message_descriptor_data());
            messages.push(LstMallData::generated_message_descriptor_data());
            messages.push(LstMallItem::generated_message_descriptor_data());
            messages.push(CollectionsInfo::generated_message_descriptor_data());
            messages.push(MerDetailReq::generated_message_descriptor_data());
            messages.push(MerDetailRsp::generated_message_descriptor_data());
            messages.push(MerDetailData::generated_message_descriptor_data());
            messages.push(CategoryListReq::generated_message_descriptor_data());
            messages.push(CategoryListRsp::generated_message_descriptor_data());
            messages.push(CategoryData::generated_message_descriptor_data());
            messages.push(CategoryDetailReq::generated_message_descriptor_data());
            messages.push(CategoryDetailRsp::generated_message_descriptor_data());
            messages.push(CateDetailData::generated_message_descriptor_data());
            messages.push(ProductListReq::generated_message_descriptor_data());
            messages.push(ProductListRsp::generated_message_descriptor_data());
            messages.push(ProductData::generated_message_descriptor_data());
            messages.push(MerChantSimpleData::generated_message_descriptor_data());
            messages.push(ProductItem::generated_message_descriptor_data());
            messages.push(ProductDetailReq::generated_message_descriptor_data());
            messages.push(ProductDetailRsp::generated_message_descriptor_data());
            messages.push(ProductSkuListReq::generated_message_descriptor_data());
            messages.push(ProductSkuListRsp::generated_message_descriptor_data());
            messages.push(ProductSkuAttrItem::generated_message_descriptor_data());
            messages.push(ProductContentReq::generated_message_descriptor_data());
            messages.push(ProductContentRsp::generated_message_descriptor_data());
            messages.push(ProductSkuDetailReq::generated_message_descriptor_data());
            messages.push(ProductSkuDetailRsp::generated_message_descriptor_data());
            messages.push(ProductSkuItem::generated_message_descriptor_data());
            messages.push(CartListReq::generated_message_descriptor_data());
            messages.push(CartListRsp::generated_message_descriptor_data());
            messages.push(CartItem::generated_message_descriptor_data());
            messages.push(CartCreateReq::generated_message_descriptor_data());
            messages.push(CartCreateRsp::generated_message_descriptor_data());
            messages.push(CartChangeReq::generated_message_descriptor_data());
            messages.push(CartChangeRsp::generated_message_descriptor_data());
            messages.push(CartDeleteReq::generated_message_descriptor_data());
            messages.push(CartDeleteRsp::generated_message_descriptor_data());
            messages.push(RelationCerateReq::generated_message_descriptor_data());
            messages.push(RelationCerateRsp::generated_message_descriptor_data());
            messages.push(RelationItem::generated_message_descriptor_data());
            messages.push(RelationProductListReq::generated_message_descriptor_data());
            messages.push(RelationProductListRsp::generated_message_descriptor_data());
            messages.push(RelationProductDelReq::generated_message_descriptor_data());
            messages.push(RelationProductDelRsp::generated_message_descriptor_data());
            messages.push(UserOrderListReq::generated_message_descriptor_data());
            messages.push(UserOrderListRsp::generated_message_descriptor_data());
            messages.push(UserOrderItem::generated_message_descriptor_data());
            messages.push(UserOrderDetailReq::generated_message_descriptor_data());
            messages.push(UserOrderDetailRsp::generated_message_descriptor_data());
            messages.push(UserOrderCreateReq::generated_message_descriptor_data());
            messages.push(UserOrderCreateRsp::generated_message_descriptor_data());
            messages.push(UserOrderCheckReq::generated_message_descriptor_data());
            messages.push(UserOrderCheckRsp::generated_message_descriptor_data());
            messages.push(UserOrderDelReq::generated_message_descriptor_data());
            messages.push(UserOrderDelRsp::generated_message_descriptor_data());
            messages.push(UserOrderPayReq::generated_message_descriptor_data());
            messages.push(UserOrderPayRsp::generated_message_descriptor_data());
            messages.push(UserOrderTakeReq::generated_message_descriptor_data());
            messages.push(UserOrderTakeRsp::generated_message_descriptor_data());
            messages.push(UserOrderExpressReq::generated_message_descriptor_data());
            messages.push(UserOrderExpressRsp::generated_message_descriptor_data());
            messages.push(AddressInfo::generated_message_descriptor_data());
            messages.push(AddressInfoSimple::generated_message_descriptor_data());
            messages.push(CreateAddressReq::generated_message_descriptor_data());
            messages.push(CreateAddressRsp::generated_message_descriptor_data());
            messages.push(AddressListReq::generated_message_descriptor_data());
            messages.push(AddressListRsp::generated_message_descriptor_data());
            messages.push(AddressDetailReq::generated_message_descriptor_data());
            messages.push(AddressDetailRsp::generated_message_descriptor_data());
            messages.push(AddressDelReq::generated_message_descriptor_data());
            messages.push(AddressDelRsp::generated_message_descriptor_data());
            messages.push(ProductReplyReq::generated_message_descriptor_data());
            messages.push(ProductReplyRsp::generated_message_descriptor_data());
            messages.push(AddReplyReq::generated_message_descriptor_data());
            messages.push(AddReplyRsp::generated_message_descriptor_data());
            messages.push(MerchantShiYiListReq::generated_message_descriptor_data());
            messages.push(MerchantShiYiListRsp::generated_message_descriptor_data());
            messages.push(MerchantItem::generated_message_descriptor_data());
            messages.push(UserWalletRechargeReq::generated_message_descriptor_data());
            messages.push(UserWalletRechargeRsp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
