// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `Server.Cross.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:pbdef.ServerStateItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerStateItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerStateItem.type)
    pub type_: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerStateItem.id)
    pub id: u32,
    // @@protoc_insertion_point(field:pbdef.ServerStateItem.host)
    pub host: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerStateItem.port)
    pub port: u32,
    // @@protoc_insertion_point(field:pbdef.ServerStateItem.capability)
    pub capability: u32,
    // @@protoc_insertion_point(field:pbdef.ServerStateItem.tcp_port)
    pub tcp_port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerStateItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerStateItem {
    fn default() -> &'a ServerStateItem {
        <ServerStateItem as ::protobuf::Message>::default_instance()
    }
}

impl ServerStateItem {
    pub fn new() -> ServerStateItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ServerStateItem| { &m.type_ },
            |m: &mut ServerStateItem| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &ServerStateItem| { &m.id },
            |m: &mut ServerStateItem| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "host",
            |m: &ServerStateItem| { &m.host },
            |m: &mut ServerStateItem| { &mut m.host },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &ServerStateItem| { &m.port },
            |m: &mut ServerStateItem| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "capability",
            |m: &ServerStateItem| { &m.capability },
            |m: &mut ServerStateItem| { &mut m.capability },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tcp_port",
            |m: &ServerStateItem| { &m.tcp_port },
            |m: &mut ServerStateItem| { &mut m.tcp_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerStateItem>(
            "ServerStateItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerStateItem {
    const NAME: &'static str = "ServerStateItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.type_ = is.read_string()?;
                },
                16 => {
                    self.id = is.read_uint32()?;
                },
                26 => {
                    self.host = is.read_string()?;
                },
                32 => {
                    self.port = is.read_uint32()?;
                },
                40 => {
                    self.capability = is.read_uint32()?;
                },
                48 => {
                    self.tcp_port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.type_.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.id);
        }
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.host);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.port);
        }
        if self.capability != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.capability);
        }
        if self.tcp_port != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.tcp_port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.type_.is_empty() {
            os.write_string(1, &self.type_)?;
        }
        if self.id != 0 {
            os.write_uint32(2, self.id)?;
        }
        if !self.host.is_empty() {
            os.write_string(3, &self.host)?;
        }
        if self.port != 0 {
            os.write_uint32(4, self.port)?;
        }
        if self.capability != 0 {
            os.write_uint32(5, self.capability)?;
        }
        if self.tcp_port != 0 {
            os.write_uint32(6, self.tcp_port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerStateItem {
        ServerStateItem::new()
    }

    fn clear(&mut self) {
        self.type_.clear();
        self.id = 0;
        self.host.clear();
        self.port = 0;
        self.capability = 0;
        self.tcp_port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerStateItem {
        static instance: ServerStateItem = ServerStateItem {
            type_: ::std::string::String::new(),
            id: 0,
            host: ::std::string::String::new(),
            port: 0,
            capability: 0,
            tcp_port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerStateItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerStateItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerStateItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerStateItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RedisBridgeToMysqlItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RedisBridgeToMysqlItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.ServerId)
    pub ServerId: u32,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.Uid)
    pub Uid: u64,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.Param1)
    pub Param1: u32,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.Param2)
    pub Param2: u32,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.Param3)
    pub Param3: u32,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.Data)
    pub Data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.TableName)
    pub TableName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.PrimaryKeyType)
    pub PrimaryKeyType: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.PrimaryKeyUint64)
    pub PrimaryKeyUint64: u64,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.PrimaryKeyString)
    pub PrimaryKeyString: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.ModelName)
    pub ModelName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.ItemUuid)
    pub ItemUuid: u64,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.CreateMilli)
    pub CreateMilli: u64,
    // @@protoc_insertion_point(field:pbdef.RedisBridgeToMysqlItem.NextSaveMilli)
    pub NextSaveMilli: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RedisBridgeToMysqlItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RedisBridgeToMysqlItem {
    fn default() -> &'a RedisBridgeToMysqlItem {
        <RedisBridgeToMysqlItem as ::protobuf::Message>::default_instance()
    }
}

impl RedisBridgeToMysqlItem {
    pub fn new() -> RedisBridgeToMysqlItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ServerId",
            |m: &RedisBridgeToMysqlItem| { &m.ServerId },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.ServerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Uid",
            |m: &RedisBridgeToMysqlItem| { &m.Uid },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.Uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Param1",
            |m: &RedisBridgeToMysqlItem| { &m.Param1 },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.Param1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Param2",
            |m: &RedisBridgeToMysqlItem| { &m.Param2 },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.Param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Param3",
            |m: &RedisBridgeToMysqlItem| { &m.Param3 },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.Param3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Data",
            |m: &RedisBridgeToMysqlItem| { &m.Data },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.Data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "TableName",
            |m: &RedisBridgeToMysqlItem| { &m.TableName },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.TableName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PrimaryKeyType",
            |m: &RedisBridgeToMysqlItem| { &m.PrimaryKeyType },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.PrimaryKeyType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PrimaryKeyUint64",
            |m: &RedisBridgeToMysqlItem| { &m.PrimaryKeyUint64 },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.PrimaryKeyUint64 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PrimaryKeyString",
            |m: &RedisBridgeToMysqlItem| { &m.PrimaryKeyString },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.PrimaryKeyString },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ModelName",
            |m: &RedisBridgeToMysqlItem| { &m.ModelName },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.ModelName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ItemUuid",
            |m: &RedisBridgeToMysqlItem| { &m.ItemUuid },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.ItemUuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "CreateMilli",
            |m: &RedisBridgeToMysqlItem| { &m.CreateMilli },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.CreateMilli },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NextSaveMilli",
            |m: &RedisBridgeToMysqlItem| { &m.NextSaveMilli },
            |m: &mut RedisBridgeToMysqlItem| { &mut m.NextSaveMilli },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RedisBridgeToMysqlItem>(
            "RedisBridgeToMysqlItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RedisBridgeToMysqlItem {
    const NAME: &'static str = "RedisBridgeToMysqlItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ServerId = is.read_uint32()?;
                },
                16 => {
                    self.Uid = is.read_uint64()?;
                },
                24 => {
                    self.Param1 = is.read_uint32()?;
                },
                32 => {
                    self.Param2 = is.read_uint32()?;
                },
                40 => {
                    self.Param3 = is.read_uint32()?;
                },
                50 => {
                    self.Data = is.read_bytes()?;
                },
                58 => {
                    self.TableName = is.read_string()?;
                },
                66 => {
                    self.PrimaryKeyType = is.read_string()?;
                },
                72 => {
                    self.PrimaryKeyUint64 = is.read_uint64()?;
                },
                82 => {
                    self.PrimaryKeyString = is.read_string()?;
                },
                90 => {
                    self.ModelName = is.read_string()?;
                },
                96 => {
                    self.ItemUuid = is.read_uint64()?;
                },
                104 => {
                    self.CreateMilli = is.read_uint64()?;
                },
                112 => {
                    self.NextSaveMilli = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ServerId != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.ServerId);
        }
        if self.Uid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.Uid);
        }
        if self.Param1 != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.Param1);
        }
        if self.Param2 != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.Param2);
        }
        if self.Param3 != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.Param3);
        }
        if !self.Data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.Data);
        }
        if !self.TableName.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.TableName);
        }
        if !self.PrimaryKeyType.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.PrimaryKeyType);
        }
        if self.PrimaryKeyUint64 != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.PrimaryKeyUint64);
        }
        if !self.PrimaryKeyString.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.PrimaryKeyString);
        }
        if !self.ModelName.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.ModelName);
        }
        if self.ItemUuid != 0 {
            my_size += ::protobuf::rt::uint64_size(12, self.ItemUuid);
        }
        if self.CreateMilli != 0 {
            my_size += ::protobuf::rt::uint64_size(13, self.CreateMilli);
        }
        if self.NextSaveMilli != 0 {
            my_size += ::protobuf::rt::uint64_size(14, self.NextSaveMilli);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ServerId != 0 {
            os.write_uint32(1, self.ServerId)?;
        }
        if self.Uid != 0 {
            os.write_uint64(2, self.Uid)?;
        }
        if self.Param1 != 0 {
            os.write_uint32(3, self.Param1)?;
        }
        if self.Param2 != 0 {
            os.write_uint32(4, self.Param2)?;
        }
        if self.Param3 != 0 {
            os.write_uint32(5, self.Param3)?;
        }
        if !self.Data.is_empty() {
            os.write_bytes(6, &self.Data)?;
        }
        if !self.TableName.is_empty() {
            os.write_string(7, &self.TableName)?;
        }
        if !self.PrimaryKeyType.is_empty() {
            os.write_string(8, &self.PrimaryKeyType)?;
        }
        if self.PrimaryKeyUint64 != 0 {
            os.write_uint64(9, self.PrimaryKeyUint64)?;
        }
        if !self.PrimaryKeyString.is_empty() {
            os.write_string(10, &self.PrimaryKeyString)?;
        }
        if !self.ModelName.is_empty() {
            os.write_string(11, &self.ModelName)?;
        }
        if self.ItemUuid != 0 {
            os.write_uint64(12, self.ItemUuid)?;
        }
        if self.CreateMilli != 0 {
            os.write_uint64(13, self.CreateMilli)?;
        }
        if self.NextSaveMilli != 0 {
            os.write_uint64(14, self.NextSaveMilli)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RedisBridgeToMysqlItem {
        RedisBridgeToMysqlItem::new()
    }

    fn clear(&mut self) {
        self.ServerId = 0;
        self.Uid = 0;
        self.Param1 = 0;
        self.Param2 = 0;
        self.Param3 = 0;
        self.Data.clear();
        self.TableName.clear();
        self.PrimaryKeyType.clear();
        self.PrimaryKeyUint64 = 0;
        self.PrimaryKeyString.clear();
        self.ModelName.clear();
        self.ItemUuid = 0;
        self.CreateMilli = 0;
        self.NextSaveMilli = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RedisBridgeToMysqlItem {
        static instance: RedisBridgeToMysqlItem = RedisBridgeToMysqlItem {
            ServerId: 0,
            Uid: 0,
            Param1: 0,
            Param2: 0,
            Param3: 0,
            Data: ::std::vec::Vec::new(),
            TableName: ::std::string::String::new(),
            PrimaryKeyType: ::std::string::String::new(),
            PrimaryKeyUint64: 0,
            PrimaryKeyString: ::std::string::String::new(),
            ModelName: ::std::string::String::new(),
            ItemUuid: 0,
            CreateMilli: 0,
            NextSaveMilli: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RedisBridgeToMysqlItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RedisBridgeToMysqlItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RedisBridgeToMysqlItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedisBridgeToMysqlItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerDefSyncServerStatePtl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerDefSyncServerStatePtl {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerDefSyncServerStatePtl.reqSelfServerType)
    pub reqSelfServerType: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerDefSyncServerStatePtl.reqSelfServerHost)
    pub reqSelfServerHost: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerDefSyncServerStatePtl.reqSelfServerPort)
    pub reqSelfServerPort: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefSyncServerStatePtl.reqSelfServerId)
    pub reqSelfServerId: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefSyncServerStatePtl.rspServerList)
    pub rspServerList: ::std::vec::Vec<ServerStateItem>,
    // @@protoc_insertion_point(field:pbdef.ServerDefSyncServerStatePtl.reqSelfTcpPort)
    pub reqSelfTcpPort: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerDefSyncServerStatePtl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerDefSyncServerStatePtl {
    fn default() -> &'a ServerDefSyncServerStatePtl {
        <ServerDefSyncServerStatePtl as ::protobuf::Message>::default_instance()
    }
}

impl ServerDefSyncServerStatePtl {
    pub fn new() -> ServerDefSyncServerStatePtl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSelfServerType",
            |m: &ServerDefSyncServerStatePtl| { &m.reqSelfServerType },
            |m: &mut ServerDefSyncServerStatePtl| { &mut m.reqSelfServerType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSelfServerHost",
            |m: &ServerDefSyncServerStatePtl| { &m.reqSelfServerHost },
            |m: &mut ServerDefSyncServerStatePtl| { &mut m.reqSelfServerHost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSelfServerPort",
            |m: &ServerDefSyncServerStatePtl| { &m.reqSelfServerPort },
            |m: &mut ServerDefSyncServerStatePtl| { &mut m.reqSelfServerPort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSelfServerId",
            |m: &ServerDefSyncServerStatePtl| { &m.reqSelfServerId },
            |m: &mut ServerDefSyncServerStatePtl| { &mut m.reqSelfServerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rspServerList",
            |m: &ServerDefSyncServerStatePtl| { &m.rspServerList },
            |m: &mut ServerDefSyncServerStatePtl| { &mut m.rspServerList },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSelfTcpPort",
            |m: &ServerDefSyncServerStatePtl| { &m.reqSelfTcpPort },
            |m: &mut ServerDefSyncServerStatePtl| { &mut m.reqSelfTcpPort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerDefSyncServerStatePtl>(
            "ServerDefSyncServerStatePtl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerDefSyncServerStatePtl {
    const NAME: &'static str = "ServerDefSyncServerStatePtl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reqSelfServerType = is.read_string()?;
                },
                18 => {
                    self.reqSelfServerHost = is.read_string()?;
                },
                24 => {
                    self.reqSelfServerPort = is.read_uint32()?;
                },
                32 => {
                    self.reqSelfServerId = is.read_uint32()?;
                },
                42 => {
                    self.rspServerList.push(is.read_message()?);
                },
                48 => {
                    self.reqSelfTcpPort = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.reqSelfServerType.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.reqSelfServerType);
        }
        if !self.reqSelfServerHost.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.reqSelfServerHost);
        }
        if self.reqSelfServerPort != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.reqSelfServerPort);
        }
        if self.reqSelfServerId != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.reqSelfServerId);
        }
        for value in &self.rspServerList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.reqSelfTcpPort != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.reqSelfTcpPort);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.reqSelfServerType.is_empty() {
            os.write_string(1, &self.reqSelfServerType)?;
        }
        if !self.reqSelfServerHost.is_empty() {
            os.write_string(2, &self.reqSelfServerHost)?;
        }
        if self.reqSelfServerPort != 0 {
            os.write_uint32(3, self.reqSelfServerPort)?;
        }
        if self.reqSelfServerId != 0 {
            os.write_uint32(4, self.reqSelfServerId)?;
        }
        for v in &self.rspServerList {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.reqSelfTcpPort != 0 {
            os.write_uint32(6, self.reqSelfTcpPort)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerDefSyncServerStatePtl {
        ServerDefSyncServerStatePtl::new()
    }

    fn clear(&mut self) {
        self.reqSelfServerType.clear();
        self.reqSelfServerHost.clear();
        self.reqSelfServerPort = 0;
        self.reqSelfServerId = 0;
        self.rspServerList.clear();
        self.reqSelfTcpPort = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerDefSyncServerStatePtl {
        static instance: ServerDefSyncServerStatePtl = ServerDefSyncServerStatePtl {
            reqSelfServerType: ::std::string::String::new(),
            reqSelfServerHost: ::std::string::String::new(),
            reqSelfServerPort: 0,
            reqSelfServerId: 0,
            rspServerList: ::std::vec::Vec::new(),
            reqSelfTcpPort: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerDefSyncServerStatePtl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerDefSyncServerStatePtl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerDefSyncServerStatePtl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerDefSyncServerStatePtl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerDefServerCrossStateReportPtl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerDefServerCrossStateReportPtl {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerDefServerCrossStateReportPtl.reqDataType)
    pub reqDataType: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefServerCrossStateReportPtl.reqSelfServerId)
    pub reqSelfServerId: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefServerCrossStateReportPtl.reqUid)
    pub reqUid: u64,
    // @@protoc_insertion_point(field:pbdef.ServerDefServerCrossStateReportPtl.reqDataUInt32Param0)
    pub reqDataUInt32Param0: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefServerCrossStateReportPtl.reqDataUInt64Param0)
    pub reqDataUInt64Param0: u64,
    // @@protoc_insertion_point(field:pbdef.ServerDefServerCrossStateReportPtl.batchOnlineTimes)
    pub batchOnlineTimes: ::std::vec::Vec<super::BaseDefine::DataPairUint64_5>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerDefServerCrossStateReportPtl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerDefServerCrossStateReportPtl {
    fn default() -> &'a ServerDefServerCrossStateReportPtl {
        <ServerDefServerCrossStateReportPtl as ::protobuf::Message>::default_instance()
    }
}

impl ServerDefServerCrossStateReportPtl {
    pub fn new() -> ServerDefServerCrossStateReportPtl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqDataType",
            |m: &ServerDefServerCrossStateReportPtl| { &m.reqDataType },
            |m: &mut ServerDefServerCrossStateReportPtl| { &mut m.reqDataType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSelfServerId",
            |m: &ServerDefServerCrossStateReportPtl| { &m.reqSelfServerId },
            |m: &mut ServerDefServerCrossStateReportPtl| { &mut m.reqSelfServerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqUid",
            |m: &ServerDefServerCrossStateReportPtl| { &m.reqUid },
            |m: &mut ServerDefServerCrossStateReportPtl| { &mut m.reqUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqDataUInt32Param0",
            |m: &ServerDefServerCrossStateReportPtl| { &m.reqDataUInt32Param0 },
            |m: &mut ServerDefServerCrossStateReportPtl| { &mut m.reqDataUInt32Param0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqDataUInt64Param0",
            |m: &ServerDefServerCrossStateReportPtl| { &m.reqDataUInt64Param0 },
            |m: &mut ServerDefServerCrossStateReportPtl| { &mut m.reqDataUInt64Param0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "batchOnlineTimes",
            |m: &ServerDefServerCrossStateReportPtl| { &m.batchOnlineTimes },
            |m: &mut ServerDefServerCrossStateReportPtl| { &mut m.batchOnlineTimes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerDefServerCrossStateReportPtl>(
            "ServerDefServerCrossStateReportPtl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerDefServerCrossStateReportPtl {
    const NAME: &'static str = "ServerDefServerCrossStateReportPtl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reqDataType = is.read_uint32()?;
                },
                16 => {
                    self.reqSelfServerId = is.read_uint32()?;
                },
                24 => {
                    self.reqUid = is.read_uint64()?;
                },
                32 => {
                    self.reqDataUInt32Param0 = is.read_uint32()?;
                },
                40 => {
                    self.reqDataUInt64Param0 = is.read_uint64()?;
                },
                50 => {
                    self.batchOnlineTimes.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reqDataType != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.reqDataType);
        }
        if self.reqSelfServerId != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.reqSelfServerId);
        }
        if self.reqUid != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.reqUid);
        }
        if self.reqDataUInt32Param0 != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.reqDataUInt32Param0);
        }
        if self.reqDataUInt64Param0 != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.reqDataUInt64Param0);
        }
        for value in &self.batchOnlineTimes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.reqDataType != 0 {
            os.write_uint32(1, self.reqDataType)?;
        }
        if self.reqSelfServerId != 0 {
            os.write_uint32(2, self.reqSelfServerId)?;
        }
        if self.reqUid != 0 {
            os.write_uint64(3, self.reqUid)?;
        }
        if self.reqDataUInt32Param0 != 0 {
            os.write_uint32(4, self.reqDataUInt32Param0)?;
        }
        if self.reqDataUInt64Param0 != 0 {
            os.write_uint64(5, self.reqDataUInt64Param0)?;
        }
        for v in &self.batchOnlineTimes {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerDefServerCrossStateReportPtl {
        ServerDefServerCrossStateReportPtl::new()
    }

    fn clear(&mut self) {
        self.reqDataType = 0;
        self.reqSelfServerId = 0;
        self.reqUid = 0;
        self.reqDataUInt32Param0 = 0;
        self.reqDataUInt64Param0 = 0;
        self.batchOnlineTimes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerDefServerCrossStateReportPtl {
        static instance: ServerDefServerCrossStateReportPtl = ServerDefServerCrossStateReportPtl {
            reqDataType: 0,
            reqSelfServerId: 0,
            reqUid: 0,
            reqDataUInt32Param0: 0,
            reqDataUInt64Param0: 0,
            batchOnlineTimes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerDefServerCrossStateReportPtl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerDefServerCrossStateReportPtl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerDefServerCrossStateReportPtl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerDefServerCrossStateReportPtl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerDefCrossSyncBriefSnapshotPtl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerDefCrossSyncBriefSnapshotPtl {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSyncBriefSnapshotPtl.reqSvrId)
    pub reqSvrId: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSyncBriefSnapshotPtl.reqUid)
    pub reqUid: u64,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSyncBriefSnapshotPtl.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSyncBriefSnapshotPtl.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerDefCrossSyncBriefSnapshotPtl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerDefCrossSyncBriefSnapshotPtl {
    fn default() -> &'a ServerDefCrossSyncBriefSnapshotPtl {
        <ServerDefCrossSyncBriefSnapshotPtl as ::protobuf::Message>::default_instance()
    }
}

impl ServerDefCrossSyncBriefSnapshotPtl {
    pub fn new() -> ServerDefCrossSyncBriefSnapshotPtl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqSvrId",
            |m: &ServerDefCrossSyncBriefSnapshotPtl| { &m.reqSvrId },
            |m: &mut ServerDefCrossSyncBriefSnapshotPtl| { &mut m.reqSvrId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqUid",
            |m: &ServerDefCrossSyncBriefSnapshotPtl| { &m.reqUid },
            |m: &mut ServerDefCrossSyncBriefSnapshotPtl| { &mut m.reqUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ServerDefCrossSyncBriefSnapshotPtl| { &m.name },
            |m: &mut ServerDefCrossSyncBriefSnapshotPtl| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ServerDefCrossSyncBriefSnapshotPtl| { &m.ret },
            |m: &mut ServerDefCrossSyncBriefSnapshotPtl| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerDefCrossSyncBriefSnapshotPtl>(
            "ServerDefCrossSyncBriefSnapshotPtl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerDefCrossSyncBriefSnapshotPtl {
    const NAME: &'static str = "ServerDefCrossSyncBriefSnapshotPtl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.reqSvrId = is.read_uint32()?;
                },
                24 => {
                    self.reqUid = is.read_uint64()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                40 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reqSvrId != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.reqSvrId);
        }
        if self.reqUid != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.reqUid);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.reqSvrId != 0 {
            os.write_uint32(2, self.reqSvrId)?;
        }
        if self.reqUid != 0 {
            os.write_uint64(3, self.reqUid)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if self.ret != 0 {
            os.write_int32(5, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerDefCrossSyncBriefSnapshotPtl {
        ServerDefCrossSyncBriefSnapshotPtl::new()
    }

    fn clear(&mut self) {
        self.reqSvrId = 0;
        self.reqUid = 0;
        self.name.clear();
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerDefCrossSyncBriefSnapshotPtl {
        static instance: ServerDefCrossSyncBriefSnapshotPtl = ServerDefCrossSyncBriefSnapshotPtl {
            reqSvrId: 0,
            reqUid: 0,
            name: ::std::string::String::new(),
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerDefCrossSyncBriefSnapshotPtl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerDefCrossSyncBriefSnapshotPtl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerDefCrossSyncBriefSnapshotPtl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerDefCrossSyncBriefSnapshotPtl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerDefServerStateNotifyPtl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerDefServerStateNotifyPtl {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerDefServerStateNotifyPtl.reqServerList)
    pub reqServerList: ::std::vec::Vec<ServerStateItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerDefServerStateNotifyPtl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerDefServerStateNotifyPtl {
    fn default() -> &'a ServerDefServerStateNotifyPtl {
        <ServerDefServerStateNotifyPtl as ::protobuf::Message>::default_instance()
    }
}

impl ServerDefServerStateNotifyPtl {
    pub fn new() -> ServerDefServerStateNotifyPtl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reqServerList",
            |m: &ServerDefServerStateNotifyPtl| { &m.reqServerList },
            |m: &mut ServerDefServerStateNotifyPtl| { &mut m.reqServerList },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerDefServerStateNotifyPtl>(
            "ServerDefServerStateNotifyPtl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerDefServerStateNotifyPtl {
    const NAME: &'static str = "ServerDefServerStateNotifyPtl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reqServerList.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reqServerList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.reqServerList {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerDefServerStateNotifyPtl {
        ServerDefServerStateNotifyPtl::new()
    }

    fn clear(&mut self) {
        self.reqServerList.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerDefServerStateNotifyPtl {
        static instance: ServerDefServerStateNotifyPtl = ServerDefServerStateNotifyPtl {
            reqServerList: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerDefServerStateNotifyPtl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerDefServerStateNotifyPtl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerDefServerStateNotifyPtl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerDefServerStateNotifyPtl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerApiCommonReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerApiCommonReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.param1)
    pub param1: u32,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.param2)
    pub param2: u32,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.param3)
    pub param3: u32,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.str_param1)
    pub str_param1: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.str_param2)
    pub str_param2: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.str_param3)
    pub str_param3: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonReq.long_param1)
    pub long_param1: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerApiCommonReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerApiCommonReq {
    fn default() -> &'a ServerApiCommonReq {
        <ServerApiCommonReq as ::protobuf::Message>::default_instance()
    }
}

impl ServerApiCommonReq {
    pub fn new() -> ServerApiCommonReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "param1",
            |m: &ServerApiCommonReq| { &m.param1 },
            |m: &mut ServerApiCommonReq| { &mut m.param1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "param2",
            |m: &ServerApiCommonReq| { &m.param2 },
            |m: &mut ServerApiCommonReq| { &mut m.param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "param3",
            |m: &ServerApiCommonReq| { &m.param3 },
            |m: &mut ServerApiCommonReq| { &mut m.param3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "str_param1",
            |m: &ServerApiCommonReq| { &m.str_param1 },
            |m: &mut ServerApiCommonReq| { &mut m.str_param1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "str_param2",
            |m: &ServerApiCommonReq| { &m.str_param2 },
            |m: &mut ServerApiCommonReq| { &mut m.str_param2 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "str_param3",
            |m: &ServerApiCommonReq| { &m.str_param3 },
            |m: &mut ServerApiCommonReq| { &mut m.str_param3 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "long_param1",
            |m: &ServerApiCommonReq| { &m.long_param1 },
            |m: &mut ServerApiCommonReq| { &mut m.long_param1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerApiCommonReq>(
            "ServerApiCommonReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerApiCommonReq {
    const NAME: &'static str = "ServerApiCommonReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.param1 = is.read_uint32()?;
                },
                16 => {
                    self.param2 = is.read_uint32()?;
                },
                24 => {
                    self.param3 = is.read_uint32()?;
                },
                34 => {
                    self.str_param1 = is.read_string()?;
                },
                42 => {
                    self.str_param2 = is.read_string()?;
                },
                50 => {
                    self.str_param3 = is.read_string()?;
                },
                56 => {
                    self.long_param1 = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.param1 != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.param1);
        }
        if self.param2 != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.param2);
        }
        if self.param3 != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.param3);
        }
        if !self.str_param1.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.str_param1);
        }
        if !self.str_param2.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.str_param2);
        }
        if !self.str_param3.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.str_param3);
        }
        if self.long_param1 != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.long_param1);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.param1 != 0 {
            os.write_uint32(1, self.param1)?;
        }
        if self.param2 != 0 {
            os.write_uint32(2, self.param2)?;
        }
        if self.param3 != 0 {
            os.write_uint32(3, self.param3)?;
        }
        if !self.str_param1.is_empty() {
            os.write_string(4, &self.str_param1)?;
        }
        if !self.str_param2.is_empty() {
            os.write_string(5, &self.str_param2)?;
        }
        if !self.str_param3.is_empty() {
            os.write_string(6, &self.str_param3)?;
        }
        if self.long_param1 != 0 {
            os.write_uint64(7, self.long_param1)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerApiCommonReq {
        ServerApiCommonReq::new()
    }

    fn clear(&mut self) {
        self.param1 = 0;
        self.param2 = 0;
        self.param3 = 0;
        self.str_param1.clear();
        self.str_param2.clear();
        self.str_param3.clear();
        self.long_param1 = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerApiCommonReq {
        static instance: ServerApiCommonReq = ServerApiCommonReq {
            param1: 0,
            param2: 0,
            param3: 0,
            str_param1: ::std::string::String::new(),
            str_param2: ::std::string::String::new(),
            str_param3: ::std::string::String::new(),
            long_param1: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerApiCommonReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerApiCommonReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerApiCommonReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerApiCommonReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerApiCommonRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerApiCommonRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonRsp.rsp_code)
    pub rsp_code: i32,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonRsp.msg)
    pub msg: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonRsp.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonRsp.rst_param1)
    pub rst_param1: i32,
    // @@protoc_insertion_point(field:pbdef.ServerApiCommonRsp.rst_str_param1)
    pub rst_str_param1: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerApiCommonRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerApiCommonRsp {
    fn default() -> &'a ServerApiCommonRsp {
        <ServerApiCommonRsp as ::protobuf::Message>::default_instance()
    }
}

impl ServerApiCommonRsp {
    pub fn new() -> ServerApiCommonRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rsp_code",
            |m: &ServerApiCommonRsp| { &m.rsp_code },
            |m: &mut ServerApiCommonRsp| { &mut m.rsp_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &ServerApiCommonRsp| { &m.msg },
            |m: &mut ServerApiCommonRsp| { &mut m.msg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &ServerApiCommonRsp| { &m.data },
            |m: &mut ServerApiCommonRsp| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rst_param1",
            |m: &ServerApiCommonRsp| { &m.rst_param1 },
            |m: &mut ServerApiCommonRsp| { &mut m.rst_param1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rst_str_param1",
            |m: &ServerApiCommonRsp| { &m.rst_str_param1 },
            |m: &mut ServerApiCommonRsp| { &mut m.rst_str_param1 },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerApiCommonRsp>(
            "ServerApiCommonRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerApiCommonRsp {
    const NAME: &'static str = "ServerApiCommonRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rsp_code = is.read_int32()?;
                },
                18 => {
                    self.msg = is.read_string()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                32 => {
                    self.rst_param1 = is.read_int32()?;
                },
                42 => {
                    self.rst_str_param1 = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.rsp_code != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.rsp_code);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.msg);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        if self.rst_param1 != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.rst_param1);
        }
        if !self.rst_str_param1.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.rst_str_param1);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.rsp_code != 0 {
            os.write_int32(1, self.rsp_code)?;
        }
        if !self.msg.is_empty() {
            os.write_string(2, &self.msg)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        if self.rst_param1 != 0 {
            os.write_int32(4, self.rst_param1)?;
        }
        if !self.rst_str_param1.is_empty() {
            os.write_string(5, &self.rst_str_param1)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerApiCommonRsp {
        ServerApiCommonRsp::new()
    }

    fn clear(&mut self) {
        self.rsp_code = 0;
        self.msg.clear();
        self.data.clear();
        self.rst_param1 = 0;
        self.rst_str_param1.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerApiCommonRsp {
        static instance: ServerApiCommonRsp = ServerApiCommonRsp {
            rsp_code: 0,
            msg: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            rst_param1: 0,
            rst_str_param1: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerApiCommonRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerApiCommonRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerApiCommonRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerApiCommonRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ServerDefCrossSendUserNotifyPtl)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServerDefCrossSendUserNotifyPtl {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSendUserNotifyPtl.reqTargetSvrId)
    pub reqTargetSvrId: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSendUserNotifyPtl.is_all)
    pub is_all: bool,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSendUserNotifyPtl.uids)
    pub uids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSendUserNotifyPtl.reqCmdId)
    pub reqCmdId: u32,
    // @@protoc_insertion_point(field:pbdef.ServerDefCrossSendUserNotifyPtl.notify_content)
    pub notify_content: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ServerDefCrossSendUserNotifyPtl.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerDefCrossSendUserNotifyPtl {
    fn default() -> &'a ServerDefCrossSendUserNotifyPtl {
        <ServerDefCrossSendUserNotifyPtl as ::protobuf::Message>::default_instance()
    }
}

impl ServerDefCrossSendUserNotifyPtl {
    pub fn new() -> ServerDefCrossSendUserNotifyPtl {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqTargetSvrId",
            |m: &ServerDefCrossSendUserNotifyPtl| { &m.reqTargetSvrId },
            |m: &mut ServerDefCrossSendUserNotifyPtl| { &mut m.reqTargetSvrId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_all",
            |m: &ServerDefCrossSendUserNotifyPtl| { &m.is_all },
            |m: &mut ServerDefCrossSendUserNotifyPtl| { &mut m.is_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uids",
            |m: &ServerDefCrossSendUserNotifyPtl| { &m.uids },
            |m: &mut ServerDefCrossSendUserNotifyPtl| { &mut m.uids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reqCmdId",
            |m: &ServerDefCrossSendUserNotifyPtl| { &m.reqCmdId },
            |m: &mut ServerDefCrossSendUserNotifyPtl| { &mut m.reqCmdId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "notify_content",
            |m: &ServerDefCrossSendUserNotifyPtl| { &m.notify_content },
            |m: &mut ServerDefCrossSendUserNotifyPtl| { &mut m.notify_content },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerDefCrossSendUserNotifyPtl>(
            "ServerDefCrossSendUserNotifyPtl",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerDefCrossSendUserNotifyPtl {
    const NAME: &'static str = "ServerDefCrossSendUserNotifyPtl";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reqTargetSvrId = is.read_uint32()?;
                },
                16 => {
                    self.is_all = is.read_bool()?;
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.uids)?;
                },
                24 => {
                    self.uids.push(is.read_uint64()?);
                },
                32 => {
                    self.reqCmdId = is.read_uint32()?;
                },
                42 => {
                    self.notify_content = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.reqTargetSvrId != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.reqTargetSvrId);
        }
        if self.is_all != false {
            my_size += 1 + 1;
        }
        for value in &self.uids {
            my_size += ::protobuf::rt::uint64_size(3, *value);
        };
        if self.reqCmdId != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.reqCmdId);
        }
        if !self.notify_content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.notify_content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.reqTargetSvrId != 0 {
            os.write_uint32(1, self.reqTargetSvrId)?;
        }
        if self.is_all != false {
            os.write_bool(2, self.is_all)?;
        }
        for v in &self.uids {
            os.write_uint64(3, *v)?;
        };
        if self.reqCmdId != 0 {
            os.write_uint32(4, self.reqCmdId)?;
        }
        if !self.notify_content.is_empty() {
            os.write_bytes(5, &self.notify_content)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerDefCrossSendUserNotifyPtl {
        ServerDefCrossSendUserNotifyPtl::new()
    }

    fn clear(&mut self) {
        self.reqTargetSvrId = 0;
        self.is_all = false;
        self.uids.clear();
        self.reqCmdId = 0;
        self.notify_content.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerDefCrossSendUserNotifyPtl {
        static instance: ServerDefCrossSendUserNotifyPtl = ServerDefCrossSendUserNotifyPtl {
            reqTargetSvrId: 0,
            is_all: false,
            uids: ::std::vec::Vec::new(),
            reqCmdId: 0,
            notify_content: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerDefCrossSendUserNotifyPtl {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerDefCrossSendUserNotifyPtl").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerDefCrossSendUserNotifyPtl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerDefCrossSendUserNotifyPtl {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12Server.Cross.proto\x12\x05pbdef\x1a\x0eUserData.protoP\0\"\x98\x01\
    \n\x0fServerStateItem\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\
    \x0e\n\x02id\x18\x02\x20\x01(\rR\x02id\x12\x12\n\x04host\x18\x03\x20\x01\
    (\tR\x04host\x12\x12\n\x04port\x18\x04\x20\x01(\rR\x04port\x12\x1e\n\nca\
    pability\x18\x05\x20\x01(\rR\ncapability\x12\x19\n\x08tcp_port\x18\x06\
    \x20\x01(\rR\x07tcpPort\"\xc2\x03\n\x16RedisBridgeToMysqlItem\x12\x1a\n\
    \x08ServerId\x18\x01\x20\x01(\rR\x08ServerId\x12\x10\n\x03Uid\x18\x02\
    \x20\x01(\x04R\x03Uid\x12\x16\n\x06Param1\x18\x03\x20\x01(\rR\x06Param1\
    \x12\x16\n\x06Param2\x18\x04\x20\x01(\rR\x06Param2\x12\x16\n\x06Param3\
    \x18\x05\x20\x01(\rR\x06Param3\x12\x12\n\x04Data\x18\x06\x20\x01(\x0cR\
    \x04Data\x12\x1c\n\tTableName\x18\x07\x20\x01(\tR\tTableName\x12&\n\x0eP\
    rimaryKeyType\x18\x08\x20\x01(\tR\x0ePrimaryKeyType\x12*\n\x10PrimaryKey\
    Uint64\x18\t\x20\x01(\x04R\x10PrimaryKeyUint64\x12*\n\x10PrimaryKeyStrin\
    g\x18\n\x20\x01(\tR\x10PrimaryKeyString\x12\x1c\n\tModelName\x18\x0b\x20\
    \x01(\tR\tModelName\x12\x1a\n\x08ItemUuid\x18\x0c\x20\x01(\x04R\x08ItemU\
    uid\x12\x20\n\x0bCreateMilli\x18\r\x20\x01(\x04R\x0bCreateMilli\x12$\n\r\
    NextSaveMilli\x18\x0e\x20\x01(\x04R\rNextSaveMilli\"\xb7\x02\n\x1bServer\
    DefSyncServerStatePtl\x12,\n\x11reqSelfServerType\x18\x01\x20\x01(\tR\
    \x11reqSelfServerType\x12,\n\x11reqSelfServerHost\x18\x02\x20\x01(\tR\
    \x11reqSelfServerHost\x12,\n\x11reqSelfServerPort\x18\x03\x20\x01(\rR\
    \x11reqSelfServerPort\x12(\n\x0freqSelfServerId\x18\x04\x20\x01(\rR\x0fr\
    eqSelfServerId\x12<\n\rrspServerList\x18\x05\x20\x03(\x0b2\x16.pbdef.Ser\
    verStateItemR\rrspServerList\x12&\n\x0ereqSelfTcpPort\x18\x06\x20\x01(\r\
    R\x0ereqSelfTcpPort\"\xb1\x02\n\"ServerDefServerCrossStateReportPtl\x12\
    \x20\n\x0breqDataType\x18\x01\x20\x01(\rR\x0breqDataType\x12(\n\x0freqSe\
    lfServerId\x18\x02\x20\x01(\rR\x0freqSelfServerId\x12\x16\n\x06reqUid\
    \x18\x03\x20\x01(\x04R\x06reqUid\x120\n\x13reqDataUInt32Param0\x18\x04\
    \x20\x01(\rR\x13reqDataUInt32Param0\x120\n\x13reqDataUInt64Param0\x18\
    \x05\x20\x01(\x04R\x13reqDataUInt64Param0\x12C\n\x10batchOnlineTimes\x18\
    \x06\x20\x03(\x0b2\x17.pbdef.DataPairUint64_5R\x10batchOnlineTimes\"~\n\
    \"ServerDefCrossSyncBriefSnapshotPtl\x12\x1a\n\x08reqSvrId\x18\x02\x20\
    \x01(\rR\x08reqSvrId\x12\x16\n\x06reqUid\x18\x03\x20\x01(\x04R\x06reqUid\
    \x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12\x10\n\x03ret\x18\x05\
    \x20\x01(\x05R\x03ret\"]\n\x1dServerDefServerStateNotifyPtl\x12<\n\rreqS\
    erverList\x18\x01\x20\x03(\x0b2\x16.pbdef.ServerStateItemR\rreqServerLis\
    t\"\xda\x01\n\x12ServerApiCommonReq\x12\x16\n\x06param1\x18\x01\x20\x01(\
    \rR\x06param1\x12\x16\n\x06param2\x18\x02\x20\x01(\rR\x06param2\x12\x16\
    \n\x06param3\x18\x03\x20\x01(\rR\x06param3\x12\x1d\n\nstr_param1\x18\x04\
    \x20\x01(\tR\tstrParam1\x12\x1d\n\nstr_param2\x18\x05\x20\x01(\tR\tstrPa\
    ram2\x12\x1d\n\nstr_param3\x18\x06\x20\x01(\tR\tstrParam3\x12\x1f\n\x0bl\
    ong_param1\x18\x07\x20\x01(\x04R\nlongParam1\"\x9a\x01\n\x12ServerApiCom\
    monRsp\x12\x19\n\x08rsp_code\x18\x01\x20\x01(\x05R\x07rspCode\x12\x10\n\
    \x03msg\x18\x02\x20\x01(\tR\x03msg\x12\x12\n\x04data\x18\x03\x20\x01(\
    \x0cR\x04data\x12\x1d\n\nrst_param1\x18\x04\x20\x01(\x05R\trstParam1\x12\
    $\n\x0erst_str_param1\x18\x05\x20\x01(\tR\x0crstStrParam1\"\xb7\x01\n\
    \x1fServerDefCrossSendUserNotifyPtl\x12&\n\x0ereqTargetSvrId\x18\x01\x20\
    \x01(\rR\x0ereqTargetSvrId\x12\x15\n\x06is_all\x18\x02\x20\x01(\x08R\x05\
    isAll\x12\x12\n\x04uids\x18\x03\x20\x03(\x04R\x04uids\x12\x1a\n\x08reqCm\
    dId\x18\x04\x20\x01(\rR\x08reqCmdId\x12%\n\x0enotify_content\x18\x05\x20\
    \x01(\x0cR\rnotifyContentb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::UserData::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(9);
            messages.push(ServerStateItem::generated_message_descriptor_data());
            messages.push(RedisBridgeToMysqlItem::generated_message_descriptor_data());
            messages.push(ServerDefSyncServerStatePtl::generated_message_descriptor_data());
            messages.push(ServerDefServerCrossStateReportPtl::generated_message_descriptor_data());
            messages.push(ServerDefCrossSyncBriefSnapshotPtl::generated_message_descriptor_data());
            messages.push(ServerDefServerStateNotifyPtl::generated_message_descriptor_data());
            messages.push(ServerApiCommonReq::generated_message_descriptor_data());
            messages.push(ServerApiCommonRsp::generated_message_descriptor_data());
            messages.push(ServerDefCrossSendUserNotifyPtl::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
