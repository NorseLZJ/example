// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `Friend.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:pbdef.FriendItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendItem.friend_id)
    pub friend_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendItem.friend_nickName)
    pub friend_nickName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendItem.friend_head)
    pub friend_head: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendItem.friend_state)
    pub friend_state: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendItem {
    fn default() -> &'a FriendItem {
        <FriendItem as ::protobuf::Message>::default_instance()
    }
}

impl FriendItem {
    pub fn new() -> FriendItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_id",
            |m: &FriendItem| { &m.friend_id },
            |m: &mut FriendItem| { &mut m.friend_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_nickName",
            |m: &FriendItem| { &m.friend_nickName },
            |m: &mut FriendItem| { &mut m.friend_nickName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_head",
            |m: &FriendItem| { &m.friend_head },
            |m: &mut FriendItem| { &mut m.friend_head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_state",
            |m: &FriendItem| { &m.friend_state },
            |m: &mut FriendItem| { &mut m.friend_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendItem>(
            "FriendItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendItem {
    const NAME: &'static str = "FriendItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.friend_id = is.read_uint64()?;
                },
                18 => {
                    self.friend_nickName = is.read_string()?;
                },
                26 => {
                    self.friend_head = is.read_string()?;
                },
                32 => {
                    self.friend_state = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.friend_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.friend_id);
        }
        if !self.friend_nickName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.friend_nickName);
        }
        if !self.friend_head.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.friend_head);
        }
        if self.friend_state != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.friend_state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.friend_id != 0 {
            os.write_uint64(1, self.friend_id)?;
        }
        if !self.friend_nickName.is_empty() {
            os.write_string(2, &self.friend_nickName)?;
        }
        if !self.friend_head.is_empty() {
            os.write_string(3, &self.friend_head)?;
        }
        if self.friend_state != 0 {
            os.write_uint32(4, self.friend_state)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendItem {
        FriendItem::new()
    }

    fn clear(&mut self) {
        self.friend_id = 0;
        self.friend_nickName.clear();
        self.friend_head.clear();
        self.friend_state = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendItem {
        static instance: FriendItem = FriendItem {
            friend_id: 0,
            friend_nickName: ::std::string::String::new(),
            friend_head: ::std::string::String::new(),
            friend_state: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGetListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGetListReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGetListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGetListReq {
    fn default() -> &'a FriendsGetListReq {
        <FriendsGetListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGetListReq {
    pub fn new() -> FriendsGetListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGetListReq>(
            "FriendsGetListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGetListReq {
    const NAME: &'static str = "FriendsGetListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGetListReq {
        FriendsGetListReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGetListReq {
        static instance: FriendsGetListReq = FriendsGetListReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGetListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGetListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGetListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGetListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGetListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGetListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGetListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsGetListRsp.friend_list)
    pub friend_list: ::std::vec::Vec<FriendItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGetListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGetListRsp {
    fn default() -> &'a FriendsGetListRsp {
        <FriendsGetListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGetListRsp {
    pub fn new() -> FriendsGetListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGetListRsp| { &m.ret },
            |m: &mut FriendsGetListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friend_list",
            |m: &FriendsGetListRsp| { &m.friend_list },
            |m: &mut FriendsGetListRsp| { &mut m.friend_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGetListRsp>(
            "FriendsGetListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGetListRsp {
    const NAME: &'static str = "FriendsGetListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.friend_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.friend_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.friend_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGetListRsp {
        FriendsGetListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.friend_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGetListRsp {
        static instance: FriendsGetListRsp = FriendsGetListRsp {
            ret: 0,
            friend_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGetListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGetListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGetListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGetListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsSearchReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsSearchReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsSearchReq.search_text)
    pub search_text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsSearchReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsSearchReq {
    fn default() -> &'a FriendsSearchReq {
        <FriendsSearchReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsSearchReq {
    pub fn new() -> FriendsSearchReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "search_text",
            |m: &FriendsSearchReq| { &m.search_text },
            |m: &mut FriendsSearchReq| { &mut m.search_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsSearchReq>(
            "FriendsSearchReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsSearchReq {
    const NAME: &'static str = "FriendsSearchReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search_text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.search_text.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.search_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.search_text.is_empty() {
            os.write_string(1, &self.search_text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsSearchReq {
        FriendsSearchReq::new()
    }

    fn clear(&mut self) {
        self.search_text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsSearchReq {
        static instance: FriendsSearchReq = FriendsSearchReq {
            search_text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsSearchReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsSearchReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsSearchReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsSearchReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsSearchRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsSearchRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsSearchRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsSearchRsp.user_snapshot_list)
    pub user_snapshot_list: ::std::vec::Vec<FriendItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsSearchRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsSearchRsp {
    fn default() -> &'a FriendsSearchRsp {
        <FriendsSearchRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsSearchRsp {
    pub fn new() -> FriendsSearchRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsSearchRsp| { &m.ret },
            |m: &mut FriendsSearchRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_snapshot_list",
            |m: &FriendsSearchRsp| { &m.user_snapshot_list },
            |m: &mut FriendsSearchRsp| { &mut m.user_snapshot_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsSearchRsp>(
            "FriendsSearchRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsSearchRsp {
    const NAME: &'static str = "FriendsSearchRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.user_snapshot_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.user_snapshot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.user_snapshot_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsSearchRsp {
        FriendsSearchRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.user_snapshot_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsSearchRsp {
        static instance: FriendsSearchRsp = FriendsSearchRsp {
            ret: 0,
            user_snapshot_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsSearchRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsSearchRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsSearchRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsSearchRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsApplyReq.friend_id)
    pub friend_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsApplyReq.apply_text)
    pub apply_text: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyReq {
    fn default() -> &'a FriendsApplyReq {
        <FriendsApplyReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyReq {
    pub fn new() -> FriendsApplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_id",
            |m: &FriendsApplyReq| { &m.friend_id },
            |m: &mut FriendsApplyReq| { &mut m.friend_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "apply_text",
            |m: &FriendsApplyReq| { &m.apply_text },
            |m: &mut FriendsApplyReq| { &mut m.apply_text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyReq>(
            "FriendsApplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyReq {
    const NAME: &'static str = "FriendsApplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.friend_id = is.read_uint64()?;
                },
                18 => {
                    self.apply_text = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.friend_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.friend_id);
        }
        if !self.apply_text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.apply_text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.friend_id != 0 {
            os.write_uint64(1, self.friend_id)?;
        }
        if !self.apply_text.is_empty() {
            os.write_string(2, &self.apply_text)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyReq {
        FriendsApplyReq::new()
    }

    fn clear(&mut self) {
        self.friend_id = 0;
        self.apply_text.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyReq {
        static instance: FriendsApplyReq = FriendsApplyReq {
            friend_id: 0,
            apply_text: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsApplyRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyRsp {
    fn default() -> &'a FriendsApplyRsp {
        <FriendsApplyRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyRsp {
    pub fn new() -> FriendsApplyRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsApplyRsp| { &m.ret },
            |m: &mut FriendsApplyRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyRsp>(
            "FriendsApplyRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyRsp {
    const NAME: &'static str = "FriendsApplyRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyRsp {
        FriendsApplyRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyRsp {
        static instance: FriendsApplyRsp = FriendsApplyRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyNotify {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsApplyNotify.apply_user)
    pub apply_user: ::protobuf::MessageField<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyNotify {
    fn default() -> &'a FriendsApplyNotify {
        <FriendsApplyNotify as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyNotify {
    pub fn new() -> FriendsApplyNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::UserSnapshot>(
            "apply_user",
            |m: &FriendsApplyNotify| { &m.apply_user },
            |m: &mut FriendsApplyNotify| { &mut m.apply_user },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyNotify>(
            "FriendsApplyNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyNotify {
    const NAME: &'static str = "FriendsApplyNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.apply_user)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.apply_user.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.apply_user.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyNotify {
        FriendsApplyNotify::new()
    }

    fn clear(&mut self) {
        self.apply_user.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyNotify {
        static instance: FriendsApplyNotify = FriendsApplyNotify {
            apply_user: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsDelReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsDelReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsDelReq.friend_id)
    pub friend_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsDelReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsDelReq {
    fn default() -> &'a FriendsDelReq {
        <FriendsDelReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsDelReq {
    pub fn new() -> FriendsDelReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_id",
            |m: &FriendsDelReq| { &m.friend_id },
            |m: &mut FriendsDelReq| { &mut m.friend_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsDelReq>(
            "FriendsDelReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsDelReq {
    const NAME: &'static str = "FriendsDelReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.friend_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.friend_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.friend_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.friend_id != 0 {
            os.write_uint64(1, self.friend_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsDelReq {
        FriendsDelReq::new()
    }

    fn clear(&mut self) {
        self.friend_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsDelReq {
        static instance: FriendsDelReq = FriendsDelReq {
            friend_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsDelReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsDelReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsDelReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsDelReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsDelRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsDelRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsDelRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsDelRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsDelRsp {
    fn default() -> &'a FriendsDelRsp {
        <FriendsDelRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsDelRsp {
    pub fn new() -> FriendsDelRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsDelRsp| { &m.ret },
            |m: &mut FriendsDelRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsDelRsp>(
            "FriendsDelRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsDelRsp {
    const NAME: &'static str = "FriendsDelRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsDelRsp {
        FriendsDelRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsDelRsp {
        static instance: FriendsDelRsp = FriendsDelRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsDelRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsDelRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsDelRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsDelRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyReplyReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyReplyReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsApplyReplyReq.friend_id)
    pub friend_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsApplyReplyReq.agree)
    pub agree: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyReplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyReplyReq {
    fn default() -> &'a FriendsApplyReplyReq {
        <FriendsApplyReplyReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyReplyReq {
    pub fn new() -> FriendsApplyReplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_id",
            |m: &FriendsApplyReplyReq| { &m.friend_id },
            |m: &mut FriendsApplyReplyReq| { &mut m.friend_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "agree",
            |m: &FriendsApplyReplyReq| { &m.agree },
            |m: &mut FriendsApplyReplyReq| { &mut m.agree },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyReplyReq>(
            "FriendsApplyReplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyReplyReq {
    const NAME: &'static str = "FriendsApplyReplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.friend_id = is.read_uint64()?;
                },
                16 => {
                    self.agree = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.friend_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.friend_id);
        }
        if self.agree != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.friend_id != 0 {
            os.write_uint64(1, self.friend_id)?;
        }
        if self.agree != false {
            os.write_bool(2, self.agree)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyReplyReq {
        FriendsApplyReplyReq::new()
    }

    fn clear(&mut self) {
        self.friend_id = 0;
        self.agree = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyReplyReq {
        static instance: FriendsApplyReplyReq = FriendsApplyReplyReq {
            friend_id: 0,
            agree: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyReplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyReplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyReplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyReplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyReplyRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyReplyRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsApplyReplyRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyReplyRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyReplyRsp {
    fn default() -> &'a FriendsApplyReplyRsp {
        <FriendsApplyReplyRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyReplyRsp {
    pub fn new() -> FriendsApplyReplyRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsApplyReplyRsp| { &m.ret },
            |m: &mut FriendsApplyReplyRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyReplyRsp>(
            "FriendsApplyReplyRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyReplyRsp {
    const NAME: &'static str = "FriendsApplyReplyRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyReplyRsp {
        FriendsApplyReplyRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyReplyRsp {
        static instance: FriendsApplyReplyRsp = FriendsApplyReplyRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyReplyRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyReplyRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyReplyRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyReplyRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsMoveToBlackListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsMoveToBlackListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsMoveToBlackListReq.friend_id)
    pub friend_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsMoveToBlackListReq.move_to_or_out)
    pub move_to_or_out: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsMoveToBlackListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsMoveToBlackListReq {
    fn default() -> &'a FriendsMoveToBlackListReq {
        <FriendsMoveToBlackListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsMoveToBlackListReq {
    pub fn new() -> FriendsMoveToBlackListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friend_id",
            |m: &FriendsMoveToBlackListReq| { &m.friend_id },
            |m: &mut FriendsMoveToBlackListReq| { &mut m.friend_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "move_to_or_out",
            |m: &FriendsMoveToBlackListReq| { &m.move_to_or_out },
            |m: &mut FriendsMoveToBlackListReq| { &mut m.move_to_or_out },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsMoveToBlackListReq>(
            "FriendsMoveToBlackListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsMoveToBlackListReq {
    const NAME: &'static str = "FriendsMoveToBlackListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.friend_id = is.read_uint64()?;
                },
                16 => {
                    self.move_to_or_out = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.friend_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.friend_id);
        }
        if self.move_to_or_out != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.friend_id != 0 {
            os.write_uint64(1, self.friend_id)?;
        }
        if self.move_to_or_out != false {
            os.write_bool(2, self.move_to_or_out)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsMoveToBlackListReq {
        FriendsMoveToBlackListReq::new()
    }

    fn clear(&mut self) {
        self.friend_id = 0;
        self.move_to_or_out = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsMoveToBlackListReq {
        static instance: FriendsMoveToBlackListReq = FriendsMoveToBlackListReq {
            friend_id: 0,
            move_to_or_out: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsMoveToBlackListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsMoveToBlackListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsMoveToBlackListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsMoveToBlackListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsMoveToBlackListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsMoveToBlackListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsMoveToBlackListRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsMoveToBlackListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsMoveToBlackListRsp {
    fn default() -> &'a FriendsMoveToBlackListRsp {
        <FriendsMoveToBlackListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsMoveToBlackListRsp {
    pub fn new() -> FriendsMoveToBlackListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsMoveToBlackListRsp| { &m.ret },
            |m: &mut FriendsMoveToBlackListRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsMoveToBlackListRsp>(
            "FriendsMoveToBlackListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsMoveToBlackListRsp {
    const NAME: &'static str = "FriendsMoveToBlackListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsMoveToBlackListRsp {
        FriendsMoveToBlackListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsMoveToBlackListRsp {
        static instance: FriendsMoveToBlackListRsp = FriendsMoveToBlackListRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsMoveToBlackListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsMoveToBlackListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsMoveToBlackListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsMoveToBlackListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyListReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyListReq {
    fn default() -> &'a FriendsApplyListReq {
        <FriendsApplyListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyListReq {
    pub fn new() -> FriendsApplyListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyListReq>(
            "FriendsApplyListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyListReq {
    const NAME: &'static str = "FriendsApplyListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyListReq {
        FriendsApplyListReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyListReq {
        static instance: FriendsApplyListReq = FriendsApplyListReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsApplyListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsApplyListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsApplyListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsApplyListRsp.user_snapshot_list)
    pub user_snapshot_list: ::std::vec::Vec<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsApplyListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsApplyListRsp {
    fn default() -> &'a FriendsApplyListRsp {
        <FriendsApplyListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsApplyListRsp {
    pub fn new() -> FriendsApplyListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsApplyListRsp| { &m.ret },
            |m: &mut FriendsApplyListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_snapshot_list",
            |m: &FriendsApplyListRsp| { &m.user_snapshot_list },
            |m: &mut FriendsApplyListRsp| { &mut m.user_snapshot_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsApplyListRsp>(
            "FriendsApplyListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsApplyListRsp {
    const NAME: &'static str = "FriendsApplyListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.user_snapshot_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.user_snapshot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.user_snapshot_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsApplyListRsp {
        FriendsApplyListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.user_snapshot_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsApplyListRsp {
        static instance: FriendsApplyListRsp = FriendsApplyListRsp {
            ret: 0,
            user_snapshot_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsApplyListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsApplyListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsApplyListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsApplyListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendGroupItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendGroupItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendGroupItem.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendGroupItem.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendGroupItem.desc)
    pub desc: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendGroupItem.head)
    pub head: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendGroupItem.person_number)
    pub person_number: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendGroupItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendGroupItem {
    fn default() -> &'a FriendGroupItem {
        <FriendGroupItem as ::protobuf::Message>::default_instance()
    }
}

impl FriendGroupItem {
    pub fn new() -> FriendGroupItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendGroupItem| { &m.group_id },
            |m: &mut FriendGroupItem| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FriendGroupItem| { &m.name },
            |m: &mut FriendGroupItem| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "desc",
            |m: &FriendGroupItem| { &m.desc },
            |m: &mut FriendGroupItem| { &mut m.desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "head",
            |m: &FriendGroupItem| { &m.head },
            |m: &mut FriendGroupItem| { &mut m.head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "person_number",
            |m: &FriendGroupItem| { &m.person_number },
            |m: &mut FriendGroupItem| { &mut m.person_number },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendGroupItem>(
            "FriendGroupItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendGroupItem {
    const NAME: &'static str = "FriendGroupItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.desc = is.read_string()?;
                },
                34 => {
                    self.head = is.read_string()?;
                },
                40 => {
                    self.person_number = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.desc);
        }
        if !self.head.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.head);
        }
        if self.person_number != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.person_number);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.desc.is_empty() {
            os.write_string(3, &self.desc)?;
        }
        if !self.head.is_empty() {
            os.write_string(4, &self.head)?;
        }
        if self.person_number != 0 {
            os.write_int32(5, self.person_number)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendGroupItem {
        FriendGroupItem::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.name.clear();
        self.desc.clear();
        self.head.clear();
        self.person_number = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendGroupItem {
        static instance: FriendGroupItem = FriendGroupItem {
            group_id: 0,
            name: ::std::string::String::new(),
            desc: ::std::string::String::new(),
            head: ::std::string::String::new(),
            person_number: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendGroupItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendGroupItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendGroupItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendGroupItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupCreateReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupCreateReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupCreateReq.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupCreateReq.desc)
    pub desc: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupCreateReq.head)
    pub head: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupCreateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupCreateReq {
    fn default() -> &'a FriendsGroupCreateReq {
        <FriendsGroupCreateReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupCreateReq {
    pub fn new() -> FriendsGroupCreateReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &FriendsGroupCreateReq| { &m.name },
            |m: &mut FriendsGroupCreateReq| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "desc",
            |m: &FriendsGroupCreateReq| { &m.desc },
            |m: &mut FriendsGroupCreateReq| { &mut m.desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "head",
            |m: &FriendsGroupCreateReq| { &m.head },
            |m: &mut FriendsGroupCreateReq| { &mut m.head },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupCreateReq>(
            "FriendsGroupCreateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupCreateReq {
    const NAME: &'static str = "FriendsGroupCreateReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.desc = is.read_string()?;
                },
                26 => {
                    self.head = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.desc);
        }
        if !self.head.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.head);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.desc.is_empty() {
            os.write_string(2, &self.desc)?;
        }
        if !self.head.is_empty() {
            os.write_string(3, &self.head)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupCreateReq {
        FriendsGroupCreateReq::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.desc.clear();
        self.head.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupCreateReq {
        static instance: FriendsGroupCreateReq = FriendsGroupCreateReq {
            name: ::std::string::String::new(),
            desc: ::std::string::String::new(),
            head: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupCreateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupCreateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupCreateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupCreateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupCreateRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupCreateRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupCreateRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupCreateRsp.group_id)
    pub group_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupCreateRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupCreateRsp {
    fn default() -> &'a FriendsGroupCreateRsp {
        <FriendsGroupCreateRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupCreateRsp {
    pub fn new() -> FriendsGroupCreateRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupCreateRsp| { &m.ret },
            |m: &mut FriendsGroupCreateRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupCreateRsp| { &m.group_id },
            |m: &mut FriendsGroupCreateRsp| { &mut m.group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupCreateRsp>(
            "FriendsGroupCreateRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupCreateRsp {
    const NAME: &'static str = "FriendsGroupCreateRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                16 => {
                    self.group_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if self.group_id != 0 {
            os.write_uint64(2, self.group_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupCreateRsp {
        FriendsGroupCreateRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.group_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupCreateRsp {
        static instance: FriendsGroupCreateRsp = FriendsGroupCreateRsp {
            ret: 0,
            group_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupCreateRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupCreateRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupCreateRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupCreateRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupInviteReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupInviteReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupInviteReq.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupInviteReq.uid)
    pub uid: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupInviteReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupInviteReq {
    fn default() -> &'a FriendsGroupInviteReq {
        <FriendsGroupInviteReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupInviteReq {
    pub fn new() -> FriendsGroupInviteReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupInviteReq| { &m.group_id },
            |m: &mut FriendsGroupInviteReq| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uid",
            |m: &FriendsGroupInviteReq| { &m.uid },
            |m: &mut FriendsGroupInviteReq| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupInviteReq>(
            "FriendsGroupInviteReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupInviteReq {
    const NAME: &'static str = "FriendsGroupInviteReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.uid)?;
                },
                16 => {
                    self.uid.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        for value in &self.uid {
            my_size += ::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        for v in &self.uid {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupInviteReq {
        FriendsGroupInviteReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.uid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupInviteReq {
        static instance: FriendsGroupInviteReq = FriendsGroupInviteReq {
            group_id: 0,
            uid: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupInviteReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupInviteReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupInviteReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupInviteReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupInviteRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupInviteRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupInviteRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupInviteRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupInviteRsp {
    fn default() -> &'a FriendsGroupInviteRsp {
        <FriendsGroupInviteRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupInviteRsp {
    pub fn new() -> FriendsGroupInviteRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupInviteRsp| { &m.ret },
            |m: &mut FriendsGroupInviteRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupInviteRsp>(
            "FriendsGroupInviteRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupInviteRsp {
    const NAME: &'static str = "FriendsGroupInviteRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupInviteRsp {
        FriendsGroupInviteRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupInviteRsp {
        static instance: FriendsGroupInviteRsp = FriendsGroupInviteRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupInviteRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupInviteRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupInviteRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupInviteRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsHandleInviteReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsHandleInviteReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsHandleInviteReq.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsHandleInviteReq.is_agree)
    pub is_agree: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsHandleInviteReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsHandleInviteReq {
    fn default() -> &'a FriendsHandleInviteReq {
        <FriendsHandleInviteReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsHandleInviteReq {
    pub fn new() -> FriendsHandleInviteReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsHandleInviteReq| { &m.group_id },
            |m: &mut FriendsHandleInviteReq| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_agree",
            |m: &FriendsHandleInviteReq| { &m.is_agree },
            |m: &mut FriendsHandleInviteReq| { &mut m.is_agree },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsHandleInviteReq>(
            "FriendsHandleInviteReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsHandleInviteReq {
    const NAME: &'static str = "FriendsHandleInviteReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                16 => {
                    self.is_agree = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        if self.is_agree != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        if self.is_agree != false {
            os.write_bool(2, self.is_agree)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsHandleInviteReq {
        FriendsHandleInviteReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.is_agree = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsHandleInviteReq {
        static instance: FriendsHandleInviteReq = FriendsHandleInviteReq {
            group_id: 0,
            is_agree: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsHandleInviteReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsHandleInviteReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsHandleInviteReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsHandleInviteReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsHandleInviteRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsHandleInviteRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsHandleInviteRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsHandleInviteRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsHandleInviteRsp {
    fn default() -> &'a FriendsHandleInviteRsp {
        <FriendsHandleInviteRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsHandleInviteRsp {
    pub fn new() -> FriendsHandleInviteRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsHandleInviteRsp| { &m.ret },
            |m: &mut FriendsHandleInviteRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsHandleInviteRsp>(
            "FriendsHandleInviteRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsHandleInviteRsp {
    const NAME: &'static str = "FriendsHandleInviteRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsHandleInviteRsp {
        FriendsHandleInviteRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsHandleInviteRsp {
        static instance: FriendsHandleInviteRsp = FriendsHandleInviteRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsHandleInviteRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsHandleInviteRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsHandleInviteRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsHandleInviteRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupApplyReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupApplyReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupApplyReq.group_id)
    pub group_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupApplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupApplyReq {
    fn default() -> &'a FriendsGroupApplyReq {
        <FriendsGroupApplyReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupApplyReq {
    pub fn new() -> FriendsGroupApplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupApplyReq| { &m.group_id },
            |m: &mut FriendsGroupApplyReq| { &mut m.group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupApplyReq>(
            "FriendsGroupApplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupApplyReq {
    const NAME: &'static str = "FriendsGroupApplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupApplyReq {
        FriendsGroupApplyReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupApplyReq {
        static instance: FriendsGroupApplyReq = FriendsGroupApplyReq {
            group_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupApplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupApplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupApplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupApplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupApplyRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupApplyRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupApplyRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupApplyRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupApplyRsp {
    fn default() -> &'a FriendsGroupApplyRsp {
        <FriendsGroupApplyRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupApplyRsp {
    pub fn new() -> FriendsGroupApplyRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupApplyRsp| { &m.ret },
            |m: &mut FriendsGroupApplyRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupApplyRsp>(
            "FriendsGroupApplyRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupApplyRsp {
    const NAME: &'static str = "FriendsGroupApplyRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupApplyRsp {
        FriendsGroupApplyRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupApplyRsp {
        static instance: FriendsGroupApplyRsp = FriendsGroupApplyRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupApplyRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupApplyRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupApplyRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupApplyRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsHandleGroupApplyReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsHandleGroupApplyReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsHandleGroupApplyReq.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsHandleGroupApplyReq.uid)
    pub uid: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsHandleGroupApplyReq.is_agree)
    pub is_agree: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsHandleGroupApplyReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsHandleGroupApplyReq {
    fn default() -> &'a FriendsHandleGroupApplyReq {
        <FriendsHandleGroupApplyReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsHandleGroupApplyReq {
    pub fn new() -> FriendsHandleGroupApplyReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsHandleGroupApplyReq| { &m.group_id },
            |m: &mut FriendsHandleGroupApplyReq| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &FriendsHandleGroupApplyReq| { &m.uid },
            |m: &mut FriendsHandleGroupApplyReq| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_agree",
            |m: &FriendsHandleGroupApplyReq| { &m.is_agree },
            |m: &mut FriendsHandleGroupApplyReq| { &mut m.is_agree },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsHandleGroupApplyReq>(
            "FriendsHandleGroupApplyReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsHandleGroupApplyReq {
    const NAME: &'static str = "FriendsHandleGroupApplyReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                16 => {
                    self.uid = is.read_uint64()?;
                },
                24 => {
                    self.is_agree = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.uid);
        }
        if self.is_agree != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        if self.uid != 0 {
            os.write_uint64(2, self.uid)?;
        }
        if self.is_agree != false {
            os.write_bool(3, self.is_agree)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsHandleGroupApplyReq {
        FriendsHandleGroupApplyReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.uid = 0;
        self.is_agree = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsHandleGroupApplyReq {
        static instance: FriendsHandleGroupApplyReq = FriendsHandleGroupApplyReq {
            group_id: 0,
            uid: 0,
            is_agree: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsHandleGroupApplyReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsHandleGroupApplyReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsHandleGroupApplyReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsHandleGroupApplyReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsHandleGroupApplyRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsHandleGroupApplyRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsHandleGroupApplyRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsHandleGroupApplyRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsHandleGroupApplyRsp {
    fn default() -> &'a FriendsHandleGroupApplyRsp {
        <FriendsHandleGroupApplyRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsHandleGroupApplyRsp {
    pub fn new() -> FriendsHandleGroupApplyRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsHandleGroupApplyRsp| { &m.ret },
            |m: &mut FriendsHandleGroupApplyRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsHandleGroupApplyRsp>(
            "FriendsHandleGroupApplyRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsHandleGroupApplyRsp {
    const NAME: &'static str = "FriendsHandleGroupApplyRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsHandleGroupApplyRsp {
        FriendsHandleGroupApplyRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsHandleGroupApplyRsp {
        static instance: FriendsHandleGroupApplyRsp = FriendsHandleGroupApplyRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsHandleGroupApplyRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsHandleGroupApplyRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsHandleGroupApplyRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsHandleGroupApplyRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupInviteListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupInviteListReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupInviteListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupInviteListReq {
    fn default() -> &'a FriendsGroupInviteListReq {
        <FriendsGroupInviteListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupInviteListReq {
    pub fn new() -> FriendsGroupInviteListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupInviteListReq>(
            "FriendsGroupInviteListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupInviteListReq {
    const NAME: &'static str = "FriendsGroupInviteListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupInviteListReq {
        FriendsGroupInviteListReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupInviteListReq {
        static instance: FriendsGroupInviteListReq = FriendsGroupInviteListReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupInviteListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupInviteListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupInviteListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupInviteListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupInviteListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupInviteListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupInviteListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupInviteListRsp.lists)
    pub lists: ::std::vec::Vec<FriendGroupItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupInviteListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupInviteListRsp {
    fn default() -> &'a FriendsGroupInviteListRsp {
        <FriendsGroupInviteListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupInviteListRsp {
    pub fn new() -> FriendsGroupInviteListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupInviteListRsp| { &m.ret },
            |m: &mut FriendsGroupInviteListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &FriendsGroupInviteListRsp| { &m.lists },
            |m: &mut FriendsGroupInviteListRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupInviteListRsp>(
            "FriendsGroupInviteListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupInviteListRsp {
    const NAME: &'static str = "FriendsGroupInviteListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupInviteListRsp {
        FriendsGroupInviteListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupInviteListRsp {
        static instance: FriendsGroupInviteListRsp = FriendsGroupInviteListRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupInviteListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupInviteListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupInviteListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupInviteListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupApplyListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupApplyListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupApplyListReq.group_id)
    pub group_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupApplyListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupApplyListReq {
    fn default() -> &'a FriendsGroupApplyListReq {
        <FriendsGroupApplyListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupApplyListReq {
    pub fn new() -> FriendsGroupApplyListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupApplyListReq| { &m.group_id },
            |m: &mut FriendsGroupApplyListReq| { &mut m.group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupApplyListReq>(
            "FriendsGroupApplyListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupApplyListReq {
    const NAME: &'static str = "FriendsGroupApplyListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupApplyListReq {
        FriendsGroupApplyListReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupApplyListReq {
        static instance: FriendsGroupApplyListReq = FriendsGroupApplyListReq {
            group_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupApplyListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupApplyListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupApplyListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupApplyListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupApplyListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupApplyListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupApplyListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupApplyListRsp.user_snapshot_list)
    pub user_snapshot_list: ::std::vec::Vec<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupApplyListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupApplyListRsp {
    fn default() -> &'a FriendsGroupApplyListRsp {
        <FriendsGroupApplyListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupApplyListRsp {
    pub fn new() -> FriendsGroupApplyListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupApplyListRsp| { &m.ret },
            |m: &mut FriendsGroupApplyListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_snapshot_list",
            |m: &FriendsGroupApplyListRsp| { &m.user_snapshot_list },
            |m: &mut FriendsGroupApplyListRsp| { &mut m.user_snapshot_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupApplyListRsp>(
            "FriendsGroupApplyListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupApplyListRsp {
    const NAME: &'static str = "FriendsGroupApplyListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.user_snapshot_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.user_snapshot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.user_snapshot_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupApplyListRsp {
        FriendsGroupApplyListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.user_snapshot_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupApplyListRsp {
        static instance: FriendsGroupApplyListRsp = FriendsGroupApplyListRsp {
            ret: 0,
            user_snapshot_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupApplyListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupApplyListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupApplyListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupApplyListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsMyGroupListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsMyGroupListReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsMyGroupListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsMyGroupListReq {
    fn default() -> &'a FriendsMyGroupListReq {
        <FriendsMyGroupListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsMyGroupListReq {
    pub fn new() -> FriendsMyGroupListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsMyGroupListReq>(
            "FriendsMyGroupListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsMyGroupListReq {
    const NAME: &'static str = "FriendsMyGroupListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsMyGroupListReq {
        FriendsMyGroupListReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsMyGroupListReq {
        static instance: FriendsMyGroupListReq = FriendsMyGroupListReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsMyGroupListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsMyGroupListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsMyGroupListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsMyGroupListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsMyGroupListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsMyGroupListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsMyGroupListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsMyGroupListRsp.group_list)
    pub group_list: ::std::vec::Vec<FriendGroupItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsMyGroupListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsMyGroupListRsp {
    fn default() -> &'a FriendsMyGroupListRsp {
        <FriendsMyGroupListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsMyGroupListRsp {
    pub fn new() -> FriendsMyGroupListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsMyGroupListRsp| { &m.ret },
            |m: &mut FriendsMyGroupListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "group_list",
            |m: &FriendsMyGroupListRsp| { &m.group_list },
            |m: &mut FriendsMyGroupListRsp| { &mut m.group_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsMyGroupListRsp>(
            "FriendsMyGroupListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsMyGroupListRsp {
    const NAME: &'static str = "FriendsMyGroupListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.group_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.group_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.group_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsMyGroupListRsp {
        FriendsMyGroupListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.group_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsMyGroupListRsp {
        static instance: FriendsMyGroupListRsp = FriendsMyGroupListRsp {
            ret: 0,
            group_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsMyGroupListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsMyGroupListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsMyGroupListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsMyGroupListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsMyGroupUserListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsMyGroupUserListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsMyGroupUserListReq.group_id)
    pub group_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsMyGroupUserListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsMyGroupUserListReq {
    fn default() -> &'a FriendsMyGroupUserListReq {
        <FriendsMyGroupUserListReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsMyGroupUserListReq {
    pub fn new() -> FriendsMyGroupUserListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsMyGroupUserListReq| { &m.group_id },
            |m: &mut FriendsMyGroupUserListReq| { &mut m.group_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsMyGroupUserListReq>(
            "FriendsMyGroupUserListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsMyGroupUserListReq {
    const NAME: &'static str = "FriendsMyGroupUserListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsMyGroupUserListReq {
        FriendsMyGroupUserListReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsMyGroupUserListReq {
        static instance: FriendsMyGroupUserListReq = FriendsMyGroupUserListReq {
            group_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsMyGroupUserListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsMyGroupUserListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsMyGroupUserListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsMyGroupUserListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsMyGroupUserListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsMyGroupUserListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsMyGroupUserListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsMyGroupUserListRsp.user_snapshot_list)
    pub user_snapshot_list: ::std::vec::Vec<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsMyGroupUserListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsMyGroupUserListRsp {
    fn default() -> &'a FriendsMyGroupUserListRsp {
        <FriendsMyGroupUserListRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsMyGroupUserListRsp {
    pub fn new() -> FriendsMyGroupUserListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsMyGroupUserListRsp| { &m.ret },
            |m: &mut FriendsMyGroupUserListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "user_snapshot_list",
            |m: &FriendsMyGroupUserListRsp| { &m.user_snapshot_list },
            |m: &mut FriendsMyGroupUserListRsp| { &mut m.user_snapshot_list },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsMyGroupUserListRsp>(
            "FriendsMyGroupUserListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsMyGroupUserListRsp {
    const NAME: &'static str = "FriendsMyGroupUserListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.user_snapshot_list.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.user_snapshot_list {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.user_snapshot_list {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsMyGroupUserListRsp {
        FriendsMyGroupUserListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.user_snapshot_list.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsMyGroupUserListRsp {
        static instance: FriendsMyGroupUserListRsp = FriendsMyGroupUserListRsp {
            ret: 0,
            user_snapshot_list: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsMyGroupUserListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsMyGroupUserListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsMyGroupUserListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsMyGroupUserListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupChangeMasterReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupChangeMasterReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupChangeMasterReq.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupChangeMasterReq.uid)
    pub uid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupChangeMasterReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupChangeMasterReq {
    fn default() -> &'a FriendsGroupChangeMasterReq {
        <FriendsGroupChangeMasterReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupChangeMasterReq {
    pub fn new() -> FriendsGroupChangeMasterReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupChangeMasterReq| { &m.group_id },
            |m: &mut FriendsGroupChangeMasterReq| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &FriendsGroupChangeMasterReq| { &m.uid },
            |m: &mut FriendsGroupChangeMasterReq| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupChangeMasterReq>(
            "FriendsGroupChangeMasterReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupChangeMasterReq {
    const NAME: &'static str = "FriendsGroupChangeMasterReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                16 => {
                    self.uid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        if self.uid != 0 {
            os.write_uint64(2, self.uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupChangeMasterReq {
        FriendsGroupChangeMasterReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.uid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupChangeMasterReq {
        static instance: FriendsGroupChangeMasterReq = FriendsGroupChangeMasterReq {
            group_id: 0,
            uid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupChangeMasterReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupChangeMasterReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupChangeMasterReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupChangeMasterReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupChangeMasterRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupChangeMasterRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupChangeMasterRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupChangeMasterRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupChangeMasterRsp {
    fn default() -> &'a FriendsGroupChangeMasterRsp {
        <FriendsGroupChangeMasterRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupChangeMasterRsp {
    pub fn new() -> FriendsGroupChangeMasterRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupChangeMasterRsp| { &m.ret },
            |m: &mut FriendsGroupChangeMasterRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupChangeMasterRsp>(
            "FriendsGroupChangeMasterRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupChangeMasterRsp {
    const NAME: &'static str = "FriendsGroupChangeMasterRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupChangeMasterRsp {
        FriendsGroupChangeMasterRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupChangeMasterRsp {
        static instance: FriendsGroupChangeMasterRsp = FriendsGroupChangeMasterRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupChangeMasterRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupChangeMasterRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupChangeMasterRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupChangeMasterRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupTickOutReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupTickOutReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupTickOutReq.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupTickOutReq.uid)
    pub uid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupTickOutReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupTickOutReq {
    fn default() -> &'a FriendsGroupTickOutReq {
        <FriendsGroupTickOutReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupTickOutReq {
    pub fn new() -> FriendsGroupTickOutReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupTickOutReq| { &m.group_id },
            |m: &mut FriendsGroupTickOutReq| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &FriendsGroupTickOutReq| { &m.uid },
            |m: &mut FriendsGroupTickOutReq| { &mut m.uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupTickOutReq>(
            "FriendsGroupTickOutReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupTickOutReq {
    const NAME: &'static str = "FriendsGroupTickOutReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                16 => {
                    self.uid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        if self.uid != 0 {
            os.write_uint64(2, self.uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupTickOutReq {
        FriendsGroupTickOutReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.uid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupTickOutReq {
        static instance: FriendsGroupTickOutReq = FriendsGroupTickOutReq {
            group_id: 0,
            uid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupTickOutReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupTickOutReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupTickOutReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupTickOutReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupTickOutRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupTickOutRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupTickOutRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupTickOutRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupTickOutRsp {
    fn default() -> &'a FriendsGroupTickOutRsp {
        <FriendsGroupTickOutRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupTickOutRsp {
    pub fn new() -> FriendsGroupTickOutRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupTickOutRsp| { &m.ret },
            |m: &mut FriendsGroupTickOutRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupTickOutRsp>(
            "FriendsGroupTickOutRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupTickOutRsp {
    const NAME: &'static str = "FriendsGroupTickOutRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupTickOutRsp {
        FriendsGroupTickOutRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupTickOutRsp {
        static instance: FriendsGroupTickOutRsp = FriendsGroupTickOutRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupTickOutRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupTickOutRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupTickOutRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupTickOutRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupsStopTalkReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupsStopTalkReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupsStopTalkReq.group_id)
    pub group_id: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupsStopTalkReq.uid)
    pub uid: u64,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupsStopTalkReq.time)
    pub time: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupsStopTalkReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupsStopTalkReq {
    fn default() -> &'a FriendsGroupsStopTalkReq {
        <FriendsGroupsStopTalkReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupsStopTalkReq {
    pub fn new() -> FriendsGroupsStopTalkReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "group_id",
            |m: &FriendsGroupsStopTalkReq| { &m.group_id },
            |m: &mut FriendsGroupsStopTalkReq| { &mut m.group_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &FriendsGroupsStopTalkReq| { &m.uid },
            |m: &mut FriendsGroupsStopTalkReq| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "time",
            |m: &FriendsGroupsStopTalkReq| { &m.time },
            |m: &mut FriendsGroupsStopTalkReq| { &mut m.time },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupsStopTalkReq>(
            "FriendsGroupsStopTalkReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupsStopTalkReq {
    const NAME: &'static str = "FriendsGroupsStopTalkReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = is.read_uint64()?;
                },
                16 => {
                    self.uid = is.read_uint64()?;
                },
                24 => {
                    self.time = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.group_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.group_id);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.uid);
        }
        if self.time != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.time);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.group_id != 0 {
            os.write_uint64(1, self.group_id)?;
        }
        if self.uid != 0 {
            os.write_uint64(2, self.uid)?;
        }
        if self.time != 0 {
            os.write_uint32(3, self.time)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupsStopTalkReq {
        FriendsGroupsStopTalkReq::new()
    }

    fn clear(&mut self) {
        self.group_id = 0;
        self.uid = 0;
        self.time = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupsStopTalkReq {
        static instance: FriendsGroupsStopTalkReq = FriendsGroupsStopTalkReq {
            group_id: 0,
            uid: 0,
            time: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupsStopTalkReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupsStopTalkReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupsStopTalkReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupsStopTalkReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupsStopTalkRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupsStopTalkRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupsStopTalkRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupsStopTalkRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupsStopTalkRsp {
    fn default() -> &'a FriendsGroupsStopTalkRsp {
        <FriendsGroupsStopTalkRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupsStopTalkRsp {
    pub fn new() -> FriendsGroupsStopTalkRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupsStopTalkRsp| { &m.ret },
            |m: &mut FriendsGroupsStopTalkRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupsStopTalkRsp>(
            "FriendsGroupsStopTalkRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupsStopTalkRsp {
    const NAME: &'static str = "FriendsGroupsStopTalkRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupsStopTalkRsp {
        FriendsGroupsStopTalkRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupsStopTalkRsp {
        static instance: FriendsGroupsStopTalkRsp = FriendsGroupsStopTalkRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupsStopTalkRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupsStopTalkRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupsStopTalkRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupsStopTalkRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupSearchReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupSearchReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupSearchReq.keywords)
    pub keywords: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupSearchReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupSearchReq {
    fn default() -> &'a FriendsGroupSearchReq {
        <FriendsGroupSearchReq as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupSearchReq {
    pub fn new() -> FriendsGroupSearchReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "keywords",
            |m: &FriendsGroupSearchReq| { &m.keywords },
            |m: &mut FriendsGroupSearchReq| { &mut m.keywords },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupSearchReq>(
            "FriendsGroupSearchReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupSearchReq {
    const NAME: &'static str = "FriendsGroupSearchReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.keywords = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.keywords.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.keywords);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.keywords.is_empty() {
            os.write_string(1, &self.keywords)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupSearchReq {
        FriendsGroupSearchReq::new()
    }

    fn clear(&mut self) {
        self.keywords.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupSearchReq {
        static instance: FriendsGroupSearchReq = FriendsGroupSearchReq {
            keywords: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupSearchReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupSearchReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupSearchReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupSearchReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.FriendsGroupSearchRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FriendsGroupSearchRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.FriendsGroupSearchRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.FriendsGroupSearchRsp.lists)
    pub lists: ::std::vec::Vec<FriendGroupItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.FriendsGroupSearchRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FriendsGroupSearchRsp {
    fn default() -> &'a FriendsGroupSearchRsp {
        <FriendsGroupSearchRsp as ::protobuf::Message>::default_instance()
    }
}

impl FriendsGroupSearchRsp {
    pub fn new() -> FriendsGroupSearchRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &FriendsGroupSearchRsp| { &m.ret },
            |m: &mut FriendsGroupSearchRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &FriendsGroupSearchRsp| { &m.lists },
            |m: &mut FriendsGroupSearchRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FriendsGroupSearchRsp>(
            "FriendsGroupSearchRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FriendsGroupSearchRsp {
    const NAME: &'static str = "FriendsGroupSearchRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FriendsGroupSearchRsp {
        FriendsGroupSearchRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FriendsGroupSearchRsp {
        static instance: FriendsGroupSearchRsp = FriendsGroupSearchRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FriendsGroupSearchRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FriendsGroupSearchRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FriendsGroupSearchRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FriendsGroupSearchRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SendChatMsgReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SendChatMsgReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SendChatMsgReq.msg_type)
    pub msg_type: i32,
    // @@protoc_insertion_point(field:pbdef.SendChatMsgReq.recivier_id)
    pub recivier_id: u64,
    // @@protoc_insertion_point(field:pbdef.SendChatMsgReq.msg)
    pub msg: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SendChatMsgReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendChatMsgReq {
    fn default() -> &'a SendChatMsgReq {
        <SendChatMsgReq as ::protobuf::Message>::default_instance()
    }
}

impl SendChatMsgReq {
    pub fn new() -> SendChatMsgReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_type",
            |m: &SendChatMsgReq| { &m.msg_type },
            |m: &mut SendChatMsgReq| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recivier_id",
            |m: &SendChatMsgReq| { &m.recivier_id },
            |m: &mut SendChatMsgReq| { &mut m.recivier_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg",
            |m: &SendChatMsgReq| { &m.msg },
            |m: &mut SendChatMsgReq| { &mut m.msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendChatMsgReq>(
            "SendChatMsgReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendChatMsgReq {
    const NAME: &'static str = "SendChatMsgReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = is.read_int32()?;
                },
                16 => {
                    self.recivier_id = is.read_uint64()?;
                },
                26 => {
                    self.msg = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_type != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.msg_type);
        }
        if self.recivier_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.recivier_id);
        }
        if !self.msg.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.msg);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_type != 0 {
            os.write_int32(1, self.msg_type)?;
        }
        if self.recivier_id != 0 {
            os.write_uint64(2, self.recivier_id)?;
        }
        if !self.msg.is_empty() {
            os.write_string(3, &self.msg)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendChatMsgReq {
        SendChatMsgReq::new()
    }

    fn clear(&mut self) {
        self.msg_type = 0;
        self.recivier_id = 0;
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendChatMsgReq {
        static instance: SendChatMsgReq = SendChatMsgReq {
            msg_type: 0,
            recivier_id: 0,
            msg: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendChatMsgReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendChatMsgReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendChatMsgReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendChatMsgReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SendChatMsgRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SendChatMsgRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SendChatMsgRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.SendChatMsgRsp.new_msg)
    pub new_msg: ::protobuf::MessageField<super::UserData::ChatMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SendChatMsgRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SendChatMsgRsp {
    fn default() -> &'a SendChatMsgRsp {
        <SendChatMsgRsp as ::protobuf::Message>::default_instance()
    }
}

impl SendChatMsgRsp {
    pub fn new() -> SendChatMsgRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &SendChatMsgRsp| { &m.ret },
            |m: &mut SendChatMsgRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::ChatMessage>(
            "new_msg",
            |m: &SendChatMsgRsp| { &m.new_msg },
            |m: &mut SendChatMsgRsp| { &mut m.new_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SendChatMsgRsp>(
            "SendChatMsgRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SendChatMsgRsp {
    const NAME: &'static str = "SendChatMsgRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.new_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.new_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SendChatMsgRsp {
        SendChatMsgRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.new_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SendChatMsgRsp {
        static instance: SendChatMsgRsp = SendChatMsgRsp {
            ret: 0,
            new_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SendChatMsgRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SendChatMsgRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SendChatMsgRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendChatMsgRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetHistoryMsgListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetHistoryMsgListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetHistoryMsgListReq.msg_type)
    pub msg_type: i32,
    // @@protoc_insertion_point(field:pbdef.GetHistoryMsgListReq.target_uid)
    pub target_uid: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetHistoryMsgListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetHistoryMsgListReq {
    fn default() -> &'a GetHistoryMsgListReq {
        <GetHistoryMsgListReq as ::protobuf::Message>::default_instance()
    }
}

impl GetHistoryMsgListReq {
    pub fn new() -> GetHistoryMsgListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "msg_type",
            |m: &GetHistoryMsgListReq| { &m.msg_type },
            |m: &mut GetHistoryMsgListReq| { &mut m.msg_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_uid",
            |m: &GetHistoryMsgListReq| { &m.target_uid },
            |m: &mut GetHistoryMsgListReq| { &mut m.target_uid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetHistoryMsgListReq>(
            "GetHistoryMsgListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetHistoryMsgListReq {
    const NAME: &'static str = "GetHistoryMsgListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = is.read_int32()?;
                },
                16 => {
                    self.target_uid = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.msg_type != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.msg_type);
        }
        if self.target_uid != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.target_uid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.msg_type != 0 {
            os.write_int32(1, self.msg_type)?;
        }
        if self.target_uid != 0 {
            os.write_uint64(2, self.target_uid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetHistoryMsgListReq {
        GetHistoryMsgListReq::new()
    }

    fn clear(&mut self) {
        self.msg_type = 0;
        self.target_uid = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetHistoryMsgListReq {
        static instance: GetHistoryMsgListReq = GetHistoryMsgListReq {
            msg_type: 0,
            target_uid: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetHistoryMsgListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetHistoryMsgListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetHistoryMsgListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHistoryMsgListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetHistoryMsgListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetHistoryMsgListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetHistoryMsgListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.GetHistoryMsgListRsp.msg_lists)
    pub msg_lists: ::std::vec::Vec<super::UserData::ChatMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetHistoryMsgListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetHistoryMsgListRsp {
    fn default() -> &'a GetHistoryMsgListRsp {
        <GetHistoryMsgListRsp as ::protobuf::Message>::default_instance()
    }
}

impl GetHistoryMsgListRsp {
    pub fn new() -> GetHistoryMsgListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &GetHistoryMsgListRsp| { &m.ret },
            |m: &mut GetHistoryMsgListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "msg_lists",
            |m: &GetHistoryMsgListRsp| { &m.msg_lists },
            |m: &mut GetHistoryMsgListRsp| { &mut m.msg_lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetHistoryMsgListRsp>(
            "GetHistoryMsgListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetHistoryMsgListRsp {
    const NAME: &'static str = "GetHistoryMsgListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.msg_lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.msg_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.msg_lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetHistoryMsgListRsp {
        GetHistoryMsgListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.msg_lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetHistoryMsgListRsp {
        static instance: GetHistoryMsgListRsp = GetHistoryMsgListRsp {
            ret: 0,
            msg_lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetHistoryMsgListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetHistoryMsgListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetHistoryMsgListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetHistoryMsgListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ChatMessageNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatMessageNotify {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ChatMessageNotify.channelType)
    pub channelType: u32,
    // @@protoc_insertion_point(field:pbdef.ChatMessageNotify.new_msg)
    pub new_msg: ::protobuf::MessageField<super::UserData::ChatMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ChatMessageNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatMessageNotify {
    fn default() -> &'a ChatMessageNotify {
        <ChatMessageNotify as ::protobuf::Message>::default_instance()
    }
}

impl ChatMessageNotify {
    pub fn new() -> ChatMessageNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "channelType",
            |m: &ChatMessageNotify| { &m.channelType },
            |m: &mut ChatMessageNotify| { &mut m.channelType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::ChatMessage>(
            "new_msg",
            |m: &ChatMessageNotify| { &m.new_msg },
            |m: &mut ChatMessageNotify| { &mut m.new_msg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessageNotify>(
            "ChatMessageNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatMessageNotify {
    const NAME: &'static str = "ChatMessageNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channelType = is.read_uint32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_msg)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.channelType != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.channelType);
        }
        if let Some(v) = self.new_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.channelType != 0 {
            os.write_uint32(1, self.channelType)?;
        }
        if let Some(v) = self.new_msg.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatMessageNotify {
        ChatMessageNotify::new()
    }

    fn clear(&mut self) {
        self.channelType = 0;
        self.new_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatMessageNotify {
        static instance: ChatMessageNotify = ChatMessageNotify {
            channelType: 0,
            new_msg: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatMessageNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatMessageNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatMessageNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatMessageNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleIssueReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleIssueReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleIssueReq.img_urls)
    pub img_urls: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleIssueReq.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleIssueReq.visibility)
    pub visibility: u32,
    // @@protoc_insertion_point(field:pbdef.CircleIssueReq.userData)
    pub userData: ::protobuf::MessageField<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleIssueReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleIssueReq {
    fn default() -> &'a CircleIssueReq {
        <CircleIssueReq as ::protobuf::Message>::default_instance()
    }
}

impl CircleIssueReq {
    pub fn new() -> CircleIssueReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "img_urls",
            |m: &CircleIssueReq| { &m.img_urls },
            |m: &mut CircleIssueReq| { &mut m.img_urls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &CircleIssueReq| { &m.content },
            |m: &mut CircleIssueReq| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visibility",
            |m: &CircleIssueReq| { &m.visibility },
            |m: &mut CircleIssueReq| { &mut m.visibility },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::UserSnapshot>(
            "userData",
            |m: &CircleIssueReq| { &m.userData },
            |m: &mut CircleIssueReq| { &mut m.userData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleIssueReq>(
            "CircleIssueReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleIssueReq {
    const NAME: &'static str = "CircleIssueReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.img_urls = is.read_string()?;
                },
                18 => {
                    self.content = is.read_string()?;
                },
                24 => {
                    self.visibility = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.img_urls.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.img_urls);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        if self.visibility != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.visibility);
        }
        if let Some(v) = self.userData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.img_urls.is_empty() {
            os.write_string(1, &self.img_urls)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        if self.visibility != 0 {
            os.write_uint32(3, self.visibility)?;
        }
        if let Some(v) = self.userData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleIssueReq {
        CircleIssueReq::new()
    }

    fn clear(&mut self) {
        self.img_urls.clear();
        self.content.clear();
        self.visibility = 0;
        self.userData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleIssueReq {
        static instance: CircleIssueReq = CircleIssueReq {
            img_urls: ::std::string::String::new(),
            content: ::std::string::String::new(),
            visibility: 0,
            userData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleIssueReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleIssueReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleIssueReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleIssueReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleIssueRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleIssueRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleIssueRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleIssueRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleIssueRsp {
    fn default() -> &'a CircleIssueRsp {
        <CircleIssueRsp as ::protobuf::Message>::default_instance()
    }
}

impl CircleIssueRsp {
    pub fn new() -> CircleIssueRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CircleIssueRsp| { &m.ret },
            |m: &mut CircleIssueRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleIssueRsp>(
            "CircleIssueRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleIssueRsp {
    const NAME: &'static str = "CircleIssueRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleIssueRsp {
        CircleIssueRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleIssueRsp {
        static instance: CircleIssueRsp = CircleIssueRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleIssueRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleIssueRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleIssueRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleIssueRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleListReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleListReq.user_id)
    pub user_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleListReq.page)
    pub page: u32,
    // @@protoc_insertion_point(field:pbdef.CircleListReq.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:pbdef.CircleListReq.friend_ids)
    pub friend_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleListReq {
    fn default() -> &'a CircleListReq {
        <CircleListReq as ::protobuf::Message>::default_instance()
    }
}

impl CircleListReq {
    pub fn new() -> CircleListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &CircleListReq| { &m.user_id },
            |m: &mut CircleListReq| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &CircleListReq| { &m.page },
            |m: &mut CircleListReq| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &CircleListReq| { &m.limit },
            |m: &mut CircleListReq| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "friend_ids",
            |m: &CircleListReq| { &m.friend_ids },
            |m: &mut CircleListReq| { &mut m.friend_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleListReq>(
            "CircleListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleListReq {
    const NAME: &'static str = "CircleListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_id = is.read_uint64()?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.limit = is.read_uint32()?;
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.friend_ids)?;
                },
                32 => {
                    self.friend_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.user_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.limit);
        }
        for value in &self.friend_ids {
            my_size += ::protobuf::rt::uint64_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.user_id != 0 {
            os.write_uint64(1, self.user_id)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.limit != 0 {
            os.write_uint32(3, self.limit)?;
        }
        for v in &self.friend_ids {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleListReq {
        CircleListReq::new()
    }

    fn clear(&mut self) {
        self.user_id = 0;
        self.page = 0;
        self.limit = 0;
        self.friend_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleListReq {
        static instance: CircleListReq = CircleListReq {
            user_id: 0,
            page: 0,
            limit: 0,
            friend_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CircleListRsp.lists)
    pub lists: ::std::vec::Vec<CircleArticleItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleListRsp {
    fn default() -> &'a CircleListRsp {
        <CircleListRsp as ::protobuf::Message>::default_instance()
    }
}

impl CircleListRsp {
    pub fn new() -> CircleListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CircleListRsp| { &m.ret },
            |m: &mut CircleListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &CircleListRsp| { &m.lists },
            |m: &mut CircleListRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleListRsp>(
            "CircleListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleListRsp {
    const NAME: &'static str = "CircleListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleListRsp {
        CircleListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleListRsp {
        static instance: CircleListRsp = CircleListRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleArticleItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleArticleItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.article_id)
    pub article_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.user_name)
    pub user_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.user_head)
    pub user_head: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.img_urls)
    pub img_urls: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.like_num)
    pub like_num: u32,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.comment_num)
    pub comment_num: u32,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.comment_lists)
    pub comment_lists: ::std::vec::Vec<CommentItem>,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.self_like)
    pub self_like: bool,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.create_time)
    pub create_time: u32,
    // @@protoc_insertion_point(field:pbdef.CircleArticleItem.user_id)
    pub user_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleArticleItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleArticleItem {
    fn default() -> &'a CircleArticleItem {
        <CircleArticleItem as ::protobuf::Message>::default_instance()
    }
}

impl CircleArticleItem {
    pub fn new() -> CircleArticleItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "article_id",
            |m: &CircleArticleItem| { &m.article_id },
            |m: &mut CircleArticleItem| { &mut m.article_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_name",
            |m: &CircleArticleItem| { &m.user_name },
            |m: &mut CircleArticleItem| { &mut m.user_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_head",
            |m: &CircleArticleItem| { &m.user_head },
            |m: &mut CircleArticleItem| { &mut m.user_head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "img_urls",
            |m: &CircleArticleItem| { &m.img_urls },
            |m: &mut CircleArticleItem| { &mut m.img_urls },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &CircleArticleItem| { &m.content },
            |m: &mut CircleArticleItem| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "like_num",
            |m: &CircleArticleItem| { &m.like_num },
            |m: &mut CircleArticleItem| { &mut m.like_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment_num",
            |m: &CircleArticleItem| { &m.comment_num },
            |m: &mut CircleArticleItem| { &mut m.comment_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "comment_lists",
            |m: &CircleArticleItem| { &m.comment_lists },
            |m: &mut CircleArticleItem| { &mut m.comment_lists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "self_like",
            |m: &CircleArticleItem| { &m.self_like },
            |m: &mut CircleArticleItem| { &mut m.self_like },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &CircleArticleItem| { &m.create_time },
            |m: &mut CircleArticleItem| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &CircleArticleItem| { &m.user_id },
            |m: &mut CircleArticleItem| { &mut m.user_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleArticleItem>(
            "CircleArticleItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleArticleItem {
    const NAME: &'static str = "CircleArticleItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.article_id = is.read_uint64()?;
                },
                18 => {
                    self.user_name = is.read_string()?;
                },
                26 => {
                    self.user_head = is.read_string()?;
                },
                34 => {
                    self.img_urls = is.read_string()?;
                },
                42 => {
                    self.content = is.read_string()?;
                },
                48 => {
                    self.like_num = is.read_uint32()?;
                },
                56 => {
                    self.comment_num = is.read_uint32()?;
                },
                66 => {
                    self.comment_lists.push(is.read_message()?);
                },
                72 => {
                    self.self_like = is.read_bool()?;
                },
                80 => {
                    self.create_time = is.read_uint32()?;
                },
                88 => {
                    self.user_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.article_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.article_id);
        }
        if !self.user_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_name);
        }
        if !self.user_head.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user_head);
        }
        if !self.img_urls.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.img_urls);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.content);
        }
        if self.like_num != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.like_num);
        }
        if self.comment_num != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.comment_num);
        }
        for value in &self.comment_lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.self_like != false {
            my_size += 1 + 1;
        }
        if self.create_time != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.create_time);
        }
        if self.user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.article_id != 0 {
            os.write_uint64(1, self.article_id)?;
        }
        if !self.user_name.is_empty() {
            os.write_string(2, &self.user_name)?;
        }
        if !self.user_head.is_empty() {
            os.write_string(3, &self.user_head)?;
        }
        if !self.img_urls.is_empty() {
            os.write_string(4, &self.img_urls)?;
        }
        if !self.content.is_empty() {
            os.write_string(5, &self.content)?;
        }
        if self.like_num != 0 {
            os.write_uint32(6, self.like_num)?;
        }
        if self.comment_num != 0 {
            os.write_uint32(7, self.comment_num)?;
        }
        for v in &self.comment_lists {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.self_like != false {
            os.write_bool(9, self.self_like)?;
        }
        if self.create_time != 0 {
            os.write_uint32(10, self.create_time)?;
        }
        if self.user_id != 0 {
            os.write_uint64(11, self.user_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleArticleItem {
        CircleArticleItem::new()
    }

    fn clear(&mut self) {
        self.article_id = 0;
        self.user_name.clear();
        self.user_head.clear();
        self.img_urls.clear();
        self.content.clear();
        self.like_num = 0;
        self.comment_num = 0;
        self.comment_lists.clear();
        self.self_like = false;
        self.create_time = 0;
        self.user_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleArticleItem {
        static instance: CircleArticleItem = CircleArticleItem {
            article_id: 0,
            user_name: ::std::string::String::new(),
            user_head: ::std::string::String::new(),
            img_urls: ::std::string::String::new(),
            content: ::std::string::String::new(),
            like_num: 0,
            comment_num: 0,
            comment_lists: ::std::vec::Vec::new(),
            self_like: false,
            create_time: 0,
            user_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleArticleItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleArticleItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleArticleItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleArticleItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CommentItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CommentItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CommentItem.comment_id)
    pub comment_id: u64,
    // @@protoc_insertion_point(field:pbdef.CommentItem.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CommentItem.user_name)
    pub user_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CommentItem.user_head)
    pub user_head: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CommentItem.like_num)
    pub like_num: u32,
    // @@protoc_insertion_point(field:pbdef.CommentItem.reply_num)
    pub reply_num: u32,
    // @@protoc_insertion_point(field:pbdef.CommentItem.self_like)
    pub self_like: bool,
    // @@protoc_insertion_point(field:pbdef.CommentItem.replys)
    pub replys: ::std::vec::Vec<CommentItem>,
    // @@protoc_insertion_point(field:pbdef.CommentItem.create_time)
    pub create_time: u32,
    // @@protoc_insertion_point(field:pbdef.CommentItem.user_id)
    pub user_id: u64,
    // @@protoc_insertion_point(field:pbdef.CommentItem.target_uid)
    pub target_uid: u64,
    // @@protoc_insertion_point(field:pbdef.CommentItem.place_holder)
    pub place_holder: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CommentItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CommentItem {
    fn default() -> &'a CommentItem {
        <CommentItem as ::protobuf::Message>::default_instance()
    }
}

impl CommentItem {
    pub fn new() -> CommentItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment_id",
            |m: &CommentItem| { &m.comment_id },
            |m: &mut CommentItem| { &mut m.comment_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &CommentItem| { &m.content },
            |m: &mut CommentItem| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_name",
            |m: &CommentItem| { &m.user_name },
            |m: &mut CommentItem| { &mut m.user_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_head",
            |m: &CommentItem| { &m.user_head },
            |m: &mut CommentItem| { &mut m.user_head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "like_num",
            |m: &CommentItem| { &m.like_num },
            |m: &mut CommentItem| { &mut m.like_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "reply_num",
            |m: &CommentItem| { &m.reply_num },
            |m: &mut CommentItem| { &mut m.reply_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "self_like",
            |m: &CommentItem| { &m.self_like },
            |m: &mut CommentItem| { &mut m.self_like },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "replys",
            |m: &CommentItem| { &m.replys },
            |m: &mut CommentItem| { &mut m.replys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "create_time",
            |m: &CommentItem| { &m.create_time },
            |m: &mut CommentItem| { &mut m.create_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &CommentItem| { &m.user_id },
            |m: &mut CommentItem| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_uid",
            |m: &CommentItem| { &m.target_uid },
            |m: &mut CommentItem| { &mut m.target_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "place_holder",
            |m: &CommentItem| { &m.place_holder },
            |m: &mut CommentItem| { &mut m.place_holder },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CommentItem>(
            "CommentItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CommentItem {
    const NAME: &'static str = "CommentItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.comment_id = is.read_uint64()?;
                },
                18 => {
                    self.content = is.read_string()?;
                },
                26 => {
                    self.user_name = is.read_string()?;
                },
                34 => {
                    self.user_head = is.read_string()?;
                },
                40 => {
                    self.like_num = is.read_uint32()?;
                },
                48 => {
                    self.reply_num = is.read_uint32()?;
                },
                56 => {
                    self.self_like = is.read_bool()?;
                },
                66 => {
                    self.replys.push(is.read_message()?);
                },
                72 => {
                    self.create_time = is.read_uint32()?;
                },
                80 => {
                    self.user_id = is.read_uint64()?;
                },
                88 => {
                    self.target_uid = is.read_uint64()?;
                },
                160 => {
                    self.place_holder = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.comment_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.comment_id);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.content);
        }
        if !self.user_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user_name);
        }
        if !self.user_head.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.user_head);
        }
        if self.like_num != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.like_num);
        }
        if self.reply_num != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.reply_num);
        }
        if self.self_like != false {
            my_size += 1 + 1;
        }
        for value in &self.replys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.create_time != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.create_time);
        }
        if self.user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(10, self.user_id);
        }
        if self.target_uid != 0 {
            my_size += ::protobuf::rt::uint64_size(11, self.target_uid);
        }
        if self.place_holder != false {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.comment_id != 0 {
            os.write_uint64(1, self.comment_id)?;
        }
        if !self.content.is_empty() {
            os.write_string(2, &self.content)?;
        }
        if !self.user_name.is_empty() {
            os.write_string(3, &self.user_name)?;
        }
        if !self.user_head.is_empty() {
            os.write_string(4, &self.user_head)?;
        }
        if self.like_num != 0 {
            os.write_uint32(5, self.like_num)?;
        }
        if self.reply_num != 0 {
            os.write_uint32(6, self.reply_num)?;
        }
        if self.self_like != false {
            os.write_bool(7, self.self_like)?;
        }
        for v in &self.replys {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if self.create_time != 0 {
            os.write_uint32(9, self.create_time)?;
        }
        if self.user_id != 0 {
            os.write_uint64(10, self.user_id)?;
        }
        if self.target_uid != 0 {
            os.write_uint64(11, self.target_uid)?;
        }
        if self.place_holder != false {
            os.write_bool(20, self.place_holder)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CommentItem {
        CommentItem::new()
    }

    fn clear(&mut self) {
        self.comment_id = 0;
        self.content.clear();
        self.user_name.clear();
        self.user_head.clear();
        self.like_num = 0;
        self.reply_num = 0;
        self.self_like = false;
        self.replys.clear();
        self.create_time = 0;
        self.user_id = 0;
        self.target_uid = 0;
        self.place_holder = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CommentItem {
        static instance: CommentItem = CommentItem {
            comment_id: 0,
            content: ::std::string::String::new(),
            user_name: ::std::string::String::new(),
            user_head: ::std::string::String::new(),
            like_num: 0,
            reply_num: 0,
            self_like: false,
            replys: ::std::vec::Vec::new(),
            create_time: 0,
            user_id: 0,
            target_uid: 0,
            place_holder: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CommentItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CommentItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CommentItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommentItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleDeleteReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleDeleteReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleDeleteReq.article_id)
    pub article_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleDeleteReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleDeleteReq {
    fn default() -> &'a CircleDeleteReq {
        <CircleDeleteReq as ::protobuf::Message>::default_instance()
    }
}

impl CircleDeleteReq {
    pub fn new() -> CircleDeleteReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "article_id",
            |m: &CircleDeleteReq| { &m.article_id },
            |m: &mut CircleDeleteReq| { &mut m.article_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleDeleteReq>(
            "CircleDeleteReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleDeleteReq {
    const NAME: &'static str = "CircleDeleteReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.article_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.article_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.article_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.article_id != 0 {
            os.write_uint64(1, self.article_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleDeleteReq {
        CircleDeleteReq::new()
    }

    fn clear(&mut self) {
        self.article_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleDeleteReq {
        static instance: CircleDeleteReq = CircleDeleteReq {
            article_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleDeleteReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleDeleteReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleDeleteReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleDeleteReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleDeleteRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleDeleteRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleDeleteRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleDeleteRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleDeleteRsp {
    fn default() -> &'a CircleDeleteRsp {
        <CircleDeleteRsp as ::protobuf::Message>::default_instance()
    }
}

impl CircleDeleteRsp {
    pub fn new() -> CircleDeleteRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CircleDeleteRsp| { &m.ret },
            |m: &mut CircleDeleteRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleDeleteRsp>(
            "CircleDeleteRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleDeleteRsp {
    const NAME: &'static str = "CircleDeleteRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleDeleteRsp {
        CircleDeleteRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleDeleteRsp {
        static instance: CircleDeleteRsp = CircleDeleteRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleDeleteRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleDeleteRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleDeleteRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleDeleteRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleCommentReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleCommentReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleCommentReq.ctype)
    pub ctype: u32,
    // @@protoc_insertion_point(field:pbdef.CircleCommentReq.article_id)
    pub article_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleCommentReq.target_id)
    pub target_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleCommentReq.content)
    pub content: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.CircleCommentReq.target_uid)
    pub target_uid: u64,
    // @@protoc_insertion_point(field:pbdef.CircleCommentReq.userData)
    pub userData: ::protobuf::MessageField<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleCommentReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleCommentReq {
    fn default() -> &'a CircleCommentReq {
        <CircleCommentReq as ::protobuf::Message>::default_instance()
    }
}

impl CircleCommentReq {
    pub fn new() -> CircleCommentReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ctype",
            |m: &CircleCommentReq| { &m.ctype },
            |m: &mut CircleCommentReq| { &mut m.ctype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "article_id",
            |m: &CircleCommentReq| { &m.article_id },
            |m: &mut CircleCommentReq| { &mut m.article_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_id",
            |m: &CircleCommentReq| { &m.target_id },
            |m: &mut CircleCommentReq| { &mut m.target_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &CircleCommentReq| { &m.content },
            |m: &mut CircleCommentReq| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_uid",
            |m: &CircleCommentReq| { &m.target_uid },
            |m: &mut CircleCommentReq| { &mut m.target_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::UserSnapshot>(
            "userData",
            |m: &CircleCommentReq| { &m.userData },
            |m: &mut CircleCommentReq| { &mut m.userData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleCommentReq>(
            "CircleCommentReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleCommentReq {
    const NAME: &'static str = "CircleCommentReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctype = is.read_uint32()?;
                },
                16 => {
                    self.article_id = is.read_uint64()?;
                },
                24 => {
                    self.target_id = is.read_uint64()?;
                },
                34 => {
                    self.content = is.read_string()?;
                },
                40 => {
                    self.target_uid = is.read_uint64()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ctype != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.ctype);
        }
        if self.article_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.article_id);
        }
        if self.target_id != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.target_id);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.content);
        }
        if self.target_uid != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.target_uid);
        }
        if let Some(v) = self.userData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ctype != 0 {
            os.write_uint32(1, self.ctype)?;
        }
        if self.article_id != 0 {
            os.write_uint64(2, self.article_id)?;
        }
        if self.target_id != 0 {
            os.write_uint64(3, self.target_id)?;
        }
        if !self.content.is_empty() {
            os.write_string(4, &self.content)?;
        }
        if self.target_uid != 0 {
            os.write_uint64(5, self.target_uid)?;
        }
        if let Some(v) = self.userData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleCommentReq {
        CircleCommentReq::new()
    }

    fn clear(&mut self) {
        self.ctype = 0;
        self.article_id = 0;
        self.target_id = 0;
        self.content.clear();
        self.target_uid = 0;
        self.userData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleCommentReq {
        static instance: CircleCommentReq = CircleCommentReq {
            ctype: 0,
            article_id: 0,
            target_id: 0,
            content: ::std::string::String::new(),
            target_uid: 0,
            userData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleCommentReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleCommentReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleCommentReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleCommentReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleCommentRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleCommentRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleCommentRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CircleCommentRsp.comment_num)
    pub comment_num: u32,
    // @@protoc_insertion_point(field:pbdef.CircleCommentRsp.data)
    pub data: ::protobuf::MessageField<CommentItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleCommentRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleCommentRsp {
    fn default() -> &'a CircleCommentRsp {
        <CircleCommentRsp as ::protobuf::Message>::default_instance()
    }
}

impl CircleCommentRsp {
    pub fn new() -> CircleCommentRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CircleCommentRsp| { &m.ret },
            |m: &mut CircleCommentRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "comment_num",
            |m: &CircleCommentRsp| { &m.comment_num },
            |m: &mut CircleCommentRsp| { &mut m.comment_num },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CommentItem>(
            "data",
            |m: &CircleCommentRsp| { &m.data },
            |m: &mut CircleCommentRsp| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleCommentRsp>(
            "CircleCommentRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleCommentRsp {
    const NAME: &'static str = "CircleCommentRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                16 => {
                    self.comment_num = is.read_uint32()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if self.comment_num != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.comment_num);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if self.comment_num != 0 {
            os.write_uint32(2, self.comment_num)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleCommentRsp {
        CircleCommentRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.comment_num = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleCommentRsp {
        static instance: CircleCommentRsp = CircleCommentRsp {
            ret: 0,
            comment_num: 0,
            data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleCommentRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleCommentRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleCommentRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleCommentRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleLikeReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleLikeReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleLikeReq.article_id)
    pub article_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleLikeReq.ctype)
    pub ctype: u32,
    // @@protoc_insertion_point(field:pbdef.CircleLikeReq.target_id)
    pub target_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleLikeReq.dolike)
    pub dolike: bool,
    // @@protoc_insertion_point(field:pbdef.CircleLikeReq.beliked_user_id)
    pub beliked_user_id: u64,
    // @@protoc_insertion_point(field:pbdef.CircleLikeReq.userData)
    pub userData: ::protobuf::MessageField<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleLikeReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleLikeReq {
    fn default() -> &'a CircleLikeReq {
        <CircleLikeReq as ::protobuf::Message>::default_instance()
    }
}

impl CircleLikeReq {
    pub fn new() -> CircleLikeReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "article_id",
            |m: &CircleLikeReq| { &m.article_id },
            |m: &mut CircleLikeReq| { &mut m.article_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ctype",
            |m: &CircleLikeReq| { &m.ctype },
            |m: &mut CircleLikeReq| { &mut m.ctype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_id",
            |m: &CircleLikeReq| { &m.target_id },
            |m: &mut CircleLikeReq| { &mut m.target_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dolike",
            |m: &CircleLikeReq| { &m.dolike },
            |m: &mut CircleLikeReq| { &mut m.dolike },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "beliked_user_id",
            |m: &CircleLikeReq| { &m.beliked_user_id },
            |m: &mut CircleLikeReq| { &mut m.beliked_user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::UserSnapshot>(
            "userData",
            |m: &CircleLikeReq| { &m.userData },
            |m: &mut CircleLikeReq| { &mut m.userData },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleLikeReq>(
            "CircleLikeReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleLikeReq {
    const NAME: &'static str = "CircleLikeReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.article_id = is.read_uint64()?;
                },
                16 => {
                    self.ctype = is.read_uint32()?;
                },
                24 => {
                    self.target_id = is.read_uint64()?;
                },
                32 => {
                    self.dolike = is.read_bool()?;
                },
                40 => {
                    self.beliked_user_id = is.read_uint64()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.userData)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.article_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.article_id);
        }
        if self.ctype != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.ctype);
        }
        if self.target_id != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.target_id);
        }
        if self.dolike != false {
            my_size += 1 + 1;
        }
        if self.beliked_user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.beliked_user_id);
        }
        if let Some(v) = self.userData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.article_id != 0 {
            os.write_uint64(1, self.article_id)?;
        }
        if self.ctype != 0 {
            os.write_uint32(2, self.ctype)?;
        }
        if self.target_id != 0 {
            os.write_uint64(3, self.target_id)?;
        }
        if self.dolike != false {
            os.write_bool(4, self.dolike)?;
        }
        if self.beliked_user_id != 0 {
            os.write_uint64(5, self.beliked_user_id)?;
        }
        if let Some(v) = self.userData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleLikeReq {
        CircleLikeReq::new()
    }

    fn clear(&mut self) {
        self.article_id = 0;
        self.ctype = 0;
        self.target_id = 0;
        self.dolike = false;
        self.beliked_user_id = 0;
        self.userData.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleLikeReq {
        static instance: CircleLikeReq = CircleLikeReq {
            article_id: 0,
            ctype: 0,
            target_id: 0,
            dolike: false,
            beliked_user_id: 0,
            userData: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleLikeReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleLikeReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleLikeReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleLikeReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CircleLikeRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CircleLikeRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CircleLikeRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.CircleLikeRsp.like_num)
    pub like_num: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CircleLikeRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CircleLikeRsp {
    fn default() -> &'a CircleLikeRsp {
        <CircleLikeRsp as ::protobuf::Message>::default_instance()
    }
}

impl CircleLikeRsp {
    pub fn new() -> CircleLikeRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &CircleLikeRsp| { &m.ret },
            |m: &mut CircleLikeRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "like_num",
            |m: &CircleLikeRsp| { &m.like_num },
            |m: &mut CircleLikeRsp| { &mut m.like_num },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CircleLikeRsp>(
            "CircleLikeRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CircleLikeRsp {
    const NAME: &'static str = "CircleLikeRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                16 => {
                    self.like_num = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if self.like_num != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.like_num);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if self.like_num != 0 {
            os.write_uint32(2, self.like_num)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CircleLikeRsp {
        CircleLikeRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.like_num = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CircleLikeRsp {
        static instance: CircleLikeRsp = CircleLikeRsp {
            ret: 0,
            like_num: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CircleLikeRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CircleLikeRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CircleLikeRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CircleLikeRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserArticleNotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserArticleNotes {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserArticleNotes.logItems)
    pub logItems: ::std::vec::Vec<UserArticleLogItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserArticleNotes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserArticleNotes {
    fn default() -> &'a UserArticleNotes {
        <UserArticleNotes as ::protobuf::Message>::default_instance()
    }
}

impl UserArticleNotes {
    pub fn new() -> UserArticleNotes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logItems",
            |m: &UserArticleNotes| { &m.logItems },
            |m: &mut UserArticleNotes| { &mut m.logItems },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserArticleNotes>(
            "UserArticleNotes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserArticleNotes {
    const NAME: &'static str = "UserArticleNotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.logItems.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.logItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.logItems {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserArticleNotes {
        UserArticleNotes::new()
    }

    fn clear(&mut self) {
        self.logItems.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserArticleNotes {
        static instance: UserArticleNotes = UserArticleNotes {
            logItems: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserArticleNotes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserArticleNotes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserArticleNotes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserArticleNotes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserArticleLogItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserArticleLogItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserArticleLogItem.timestemp)
    pub timestemp: u32,
    // @@protoc_insertion_point(field:pbdef.UserArticleLogItem.user_name)
    pub user_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserArticleLogItem.user_head)
    pub user_head: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserArticleLogItem.action_type)
    pub action_type: u32,
    // @@protoc_insertion_point(field:pbdef.UserArticleLogItem.user_id)
    pub user_id: u64,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserArticleLogItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserArticleLogItem {
    fn default() -> &'a UserArticleLogItem {
        <UserArticleLogItem as ::protobuf::Message>::default_instance()
    }
}

impl UserArticleLogItem {
    pub fn new() -> UserArticleLogItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timestemp",
            |m: &UserArticleLogItem| { &m.timestemp },
            |m: &mut UserArticleLogItem| { &mut m.timestemp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_name",
            |m: &UserArticleLogItem| { &m.user_name },
            |m: &mut UserArticleLogItem| { &mut m.user_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_head",
            |m: &UserArticleLogItem| { &m.user_head },
            |m: &mut UserArticleLogItem| { &mut m.user_head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action_type",
            |m: &UserArticleLogItem| { &m.action_type },
            |m: &mut UserArticleLogItem| { &mut m.action_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &UserArticleLogItem| { &m.user_id },
            |m: &mut UserArticleLogItem| { &mut m.user_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserArticleLogItem>(
            "UserArticleLogItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserArticleLogItem {
    const NAME: &'static str = "UserArticleLogItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestemp = is.read_uint32()?;
                },
                18 => {
                    self.user_name = is.read_string()?;
                },
                26 => {
                    self.user_head = is.read_string()?;
                },
                32 => {
                    self.action_type = is.read_uint32()?;
                },
                40 => {
                    self.user_id = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.timestemp != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.timestemp);
        }
        if !self.user_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.user_name);
        }
        if !self.user_head.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.user_head);
        }
        if self.action_type != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.action_type);
        }
        if self.user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.user_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.timestemp != 0 {
            os.write_uint32(1, self.timestemp)?;
        }
        if !self.user_name.is_empty() {
            os.write_string(2, &self.user_name)?;
        }
        if !self.user_head.is_empty() {
            os.write_string(3, &self.user_head)?;
        }
        if self.action_type != 0 {
            os.write_uint32(4, self.action_type)?;
        }
        if self.user_id != 0 {
            os.write_uint64(5, self.user_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserArticleLogItem {
        UserArticleLogItem::new()
    }

    fn clear(&mut self) {
        self.timestemp = 0;
        self.user_name.clear();
        self.user_head.clear();
        self.action_type = 0;
        self.user_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserArticleLogItem {
        static instance: UserArticleLogItem = UserArticleLogItem {
            timestemp: 0,
            user_name: ::std::string::String::new(),
            user_head: ::std::string::String::new(),
            action_type: 0,
            user_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserArticleLogItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserArticleLogItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserArticleLogItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserArticleLogItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetUserArticleNotesReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetUserArticleNotesReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetUserArticleNotesReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserArticleNotesReq {
    fn default() -> &'a GetUserArticleNotesReq {
        <GetUserArticleNotesReq as ::protobuf::Message>::default_instance()
    }
}

impl GetUserArticleNotesReq {
    pub fn new() -> GetUserArticleNotesReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserArticleNotesReq>(
            "GetUserArticleNotesReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserArticleNotesReq {
    const NAME: &'static str = "GetUserArticleNotesReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserArticleNotesReq {
        GetUserArticleNotesReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserArticleNotesReq {
        static instance: GetUserArticleNotesReq = GetUserArticleNotesReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserArticleNotesReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserArticleNotesReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserArticleNotesReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserArticleNotesReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetUserArticleNotesRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetUserArticleNotesRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetUserArticleNotesRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.GetUserArticleNotesRsp.logItems)
    pub logItems: ::std::vec::Vec<UserArticleLogItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetUserArticleNotesRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetUserArticleNotesRsp {
    fn default() -> &'a GetUserArticleNotesRsp {
        <GetUserArticleNotesRsp as ::protobuf::Message>::default_instance()
    }
}

impl GetUserArticleNotesRsp {
    pub fn new() -> GetUserArticleNotesRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &GetUserArticleNotesRsp| { &m.ret },
            |m: &mut GetUserArticleNotesRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "logItems",
            |m: &GetUserArticleNotesRsp| { &m.logItems },
            |m: &mut GetUserArticleNotesRsp| { &mut m.logItems },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetUserArticleNotesRsp>(
            "GetUserArticleNotesRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetUserArticleNotesRsp {
    const NAME: &'static str = "GetUserArticleNotesRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.logItems.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.logItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.logItems {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetUserArticleNotesRsp {
        GetUserArticleNotesRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.logItems.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetUserArticleNotesRsp {
        static instance: GetUserArticleNotesRsp = GetUserArticleNotesRsp {
            ret: 0,
            logItems: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetUserArticleNotesRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetUserArticleNotesRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetUserArticleNotesRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetUserArticleNotesRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserArticleLogNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserArticleLogNotify {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserArticleLogNotify.logItems)
    pub logItems: ::protobuf::MessageField<UserArticleLogItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserArticleLogNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserArticleLogNotify {
    fn default() -> &'a UserArticleLogNotify {
        <UserArticleLogNotify as ::protobuf::Message>::default_instance()
    }
}

impl UserArticleLogNotify {
    pub fn new() -> UserArticleLogNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, UserArticleLogItem>(
            "logItems",
            |m: &UserArticleLogNotify| { &m.logItems },
            |m: &mut UserArticleLogNotify| { &mut m.logItems },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserArticleLogNotify>(
            "UserArticleLogNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserArticleLogNotify {
    const NAME: &'static str = "UserArticleLogNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.logItems)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.logItems.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.logItems.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserArticleLogNotify {
        UserArticleLogNotify::new()
    }

    fn clear(&mut self) {
        self.logItems.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserArticleLogNotify {
        static instance: UserArticleLogNotify = UserArticleLogNotify {
            logItems: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserArticleLogNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserArticleLogNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserArticleLogNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserArticleLogNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetCommentListsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCommentListsReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetCommentListsReq.article_id)
    pub article_id: u64,
    // @@protoc_insertion_point(field:pbdef.GetCommentListsReq.page)
    pub page: u32,
    // @@protoc_insertion_point(field:pbdef.GetCommentListsReq.limit)
    pub limit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetCommentListsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCommentListsReq {
    fn default() -> &'a GetCommentListsReq {
        <GetCommentListsReq as ::protobuf::Message>::default_instance()
    }
}

impl GetCommentListsReq {
    pub fn new() -> GetCommentListsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "article_id",
            |m: &GetCommentListsReq| { &m.article_id },
            |m: &mut GetCommentListsReq| { &mut m.article_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &GetCommentListsReq| { &m.page },
            |m: &mut GetCommentListsReq| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &GetCommentListsReq| { &m.limit },
            |m: &mut GetCommentListsReq| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCommentListsReq>(
            "GetCommentListsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCommentListsReq {
    const NAME: &'static str = "GetCommentListsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.article_id = is.read_uint64()?;
                },
                16 => {
                    self.page = is.read_uint32()?;
                },
                24 => {
                    self.limit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.article_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.article_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.page);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.article_id != 0 {
            os.write_uint64(1, self.article_id)?;
        }
        if self.page != 0 {
            os.write_uint32(2, self.page)?;
        }
        if self.limit != 0 {
            os.write_uint32(3, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCommentListsReq {
        GetCommentListsReq::new()
    }

    fn clear(&mut self) {
        self.article_id = 0;
        self.page = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCommentListsReq {
        static instance: GetCommentListsReq = GetCommentListsReq {
            article_id: 0,
            page: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCommentListsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCommentListsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCommentListsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCommentListsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetCommentListsRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetCommentListsRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetCommentListsRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.GetCommentListsRsp.lists)
    pub lists: ::std::vec::Vec<CommentItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetCommentListsRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetCommentListsRsp {
    fn default() -> &'a GetCommentListsRsp {
        <GetCommentListsRsp as ::protobuf::Message>::default_instance()
    }
}

impl GetCommentListsRsp {
    pub fn new() -> GetCommentListsRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &GetCommentListsRsp| { &m.ret },
            |m: &mut GetCommentListsRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &GetCommentListsRsp| { &m.lists },
            |m: &mut GetCommentListsRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetCommentListsRsp>(
            "GetCommentListsRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetCommentListsRsp {
    const NAME: &'static str = "GetCommentListsRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetCommentListsRsp {
        GetCommentListsRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetCommentListsRsp {
        static instance: GetCommentListsRsp = GetCommentListsRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetCommentListsRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetCommentListsRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetCommentListsRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetCommentListsRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetReplyListsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetReplyListsReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetReplyListsReq.article_id)
    pub article_id: u64,
    // @@protoc_insertion_point(field:pbdef.GetReplyListsReq.commetn_id)
    pub commetn_id: u64,
    // @@protoc_insertion_point(field:pbdef.GetReplyListsReq.page)
    pub page: u32,
    // @@protoc_insertion_point(field:pbdef.GetReplyListsReq.limit)
    pub limit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetReplyListsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetReplyListsReq {
    fn default() -> &'a GetReplyListsReq {
        <GetReplyListsReq as ::protobuf::Message>::default_instance()
    }
}

impl GetReplyListsReq {
    pub fn new() -> GetReplyListsReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "article_id",
            |m: &GetReplyListsReq| { &m.article_id },
            |m: &mut GetReplyListsReq| { &mut m.article_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "commetn_id",
            |m: &GetReplyListsReq| { &m.commetn_id },
            |m: &mut GetReplyListsReq| { &mut m.commetn_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "page",
            |m: &GetReplyListsReq| { &m.page },
            |m: &mut GetReplyListsReq| { &mut m.page },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &GetReplyListsReq| { &m.limit },
            |m: &mut GetReplyListsReq| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetReplyListsReq>(
            "GetReplyListsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetReplyListsReq {
    const NAME: &'static str = "GetReplyListsReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.article_id = is.read_uint64()?;
                },
                16 => {
                    self.commetn_id = is.read_uint64()?;
                },
                24 => {
                    self.page = is.read_uint32()?;
                },
                32 => {
                    self.limit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.article_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.article_id);
        }
        if self.commetn_id != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.commetn_id);
        }
        if self.page != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.page);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.article_id != 0 {
            os.write_uint64(1, self.article_id)?;
        }
        if self.commetn_id != 0 {
            os.write_uint64(2, self.commetn_id)?;
        }
        if self.page != 0 {
            os.write_uint32(3, self.page)?;
        }
        if self.limit != 0 {
            os.write_uint32(4, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetReplyListsReq {
        GetReplyListsReq::new()
    }

    fn clear(&mut self) {
        self.article_id = 0;
        self.commetn_id = 0;
        self.page = 0;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetReplyListsReq {
        static instance: GetReplyListsReq = GetReplyListsReq {
            article_id: 0,
            commetn_id: 0,
            page: 0,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetReplyListsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetReplyListsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetReplyListsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReplyListsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.GetReplyListsRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetReplyListsRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.GetReplyListsRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.GetReplyListsRsp.lists)
    pub lists: ::std::vec::Vec<CommentItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.GetReplyListsRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetReplyListsRsp {
    fn default() -> &'a GetReplyListsRsp {
        <GetReplyListsRsp as ::protobuf::Message>::default_instance()
    }
}

impl GetReplyListsRsp {
    pub fn new() -> GetReplyListsRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &GetReplyListsRsp| { &m.ret },
            |m: &mut GetReplyListsRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "lists",
            |m: &GetReplyListsRsp| { &m.lists },
            |m: &mut GetReplyListsRsp| { &mut m.lists },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetReplyListsRsp>(
            "GetReplyListsRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetReplyListsRsp {
    const NAME: &'static str = "GetReplyListsRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.lists.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.lists {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.lists {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetReplyListsRsp {
        GetReplyListsRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.lists.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetReplyListsRsp {
        static instance: GetReplyListsRsp = GetReplyListsRsp {
            ret: 0,
            lists: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetReplyListsRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetReplyListsRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetReplyListsRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReplyListsRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RemoveUserArticleNotesReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveUserArticleNotesReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RemoveUserArticleNotesReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveUserArticleNotesReq {
    fn default() -> &'a RemoveUserArticleNotesReq {
        <RemoveUserArticleNotesReq as ::protobuf::Message>::default_instance()
    }
}

impl RemoveUserArticleNotesReq {
    pub fn new() -> RemoveUserArticleNotesReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveUserArticleNotesReq>(
            "RemoveUserArticleNotesReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveUserArticleNotesReq {
    const NAME: &'static str = "RemoveUserArticleNotesReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveUserArticleNotesReq {
        RemoveUserArticleNotesReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveUserArticleNotesReq {
        static instance: RemoveUserArticleNotesReq = RemoveUserArticleNotesReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveUserArticleNotesReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveUserArticleNotesReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveUserArticleNotesReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveUserArticleNotesReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RemoveUserArticleNotesRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RemoveUserArticleNotesRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RemoveUserArticleNotesRsp.ret)
    pub ret: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RemoveUserArticleNotesRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoveUserArticleNotesRsp {
    fn default() -> &'a RemoveUserArticleNotesRsp {
        <RemoveUserArticleNotesRsp as ::protobuf::Message>::default_instance()
    }
}

impl RemoveUserArticleNotesRsp {
    pub fn new() -> RemoveUserArticleNotesRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &RemoveUserArticleNotesRsp| { &m.ret },
            |m: &mut RemoveUserArticleNotesRsp| { &mut m.ret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoveUserArticleNotesRsp>(
            "RemoveUserArticleNotesRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoveUserArticleNotesRsp {
    const NAME: &'static str = "RemoveUserArticleNotesRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoveUserArticleNotesRsp {
        RemoveUserArticleNotesRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoveUserArticleNotesRsp {
        static instance: RemoveUserArticleNotesRsp = RemoveUserArticleNotesRsp {
            ret: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoveUserArticleNotesRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoveUserArticleNotesRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoveUserArticleNotesRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoveUserArticleNotesRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pbdef.VIEW_AREA)
pub enum VIEW_AREA {
    // @@protoc_insertion_point(enum_value:pbdef.VIEW_AREA.T_NONE)
    T_NONE = 0,
    // @@protoc_insertion_point(enum_value:pbdef.VIEW_AREA.T_FRIEND)
    T_FRIEND = 1,
    // @@protoc_insertion_point(enum_value:pbdef.VIEW_AREA.T_FRIEND_CANNOT)
    T_FRIEND_CANNOT = 2,
    // @@protoc_insertion_point(enum_value:pbdef.VIEW_AREA.T_SELF)
    T_SELF = 3,
}

impl ::protobuf::Enum for VIEW_AREA {
    const NAME: &'static str = "VIEW_AREA";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VIEW_AREA> {
        match value {
            0 => ::std::option::Option::Some(VIEW_AREA::T_NONE),
            1 => ::std::option::Option::Some(VIEW_AREA::T_FRIEND),
            2 => ::std::option::Option::Some(VIEW_AREA::T_FRIEND_CANNOT),
            3 => ::std::option::Option::Some(VIEW_AREA::T_SELF),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VIEW_AREA> {
        match str {
            "T_NONE" => ::std::option::Option::Some(VIEW_AREA::T_NONE),
            "T_FRIEND" => ::std::option::Option::Some(VIEW_AREA::T_FRIEND),
            "T_FRIEND_CANNOT" => ::std::option::Option::Some(VIEW_AREA::T_FRIEND_CANNOT),
            "T_SELF" => ::std::option::Option::Some(VIEW_AREA::T_SELF),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VIEW_AREA] = &[
        VIEW_AREA::T_NONE,
        VIEW_AREA::T_FRIEND,
        VIEW_AREA::T_FRIEND_CANNOT,
        VIEW_AREA::T_SELF,
    ];
}

impl ::protobuf::EnumFull for VIEW_AREA {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VIEW_AREA").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VIEW_AREA {
    fn default() -> Self {
        VIEW_AREA::T_NONE
    }
}

impl VIEW_AREA {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VIEW_AREA>("VIEW_AREA")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pbdef.ACTION_TYPE)
pub enum ACTION_TYPE {
    // @@protoc_insertion_point(enum_value:pbdef.ACTION_TYPE.AT_NONE)
    AT_NONE = 0,
    // @@protoc_insertion_point(enum_value:pbdef.ACTION_TYPE.AT_COMMENT_PAI)
    AT_COMMENT_PAI = 1,
    // @@protoc_insertion_point(enum_value:pbdef.ACTION_TYPE.AT_COMMENT_COMMENT)
    AT_COMMENT_COMMENT = 2,
    // @@protoc_insertion_point(enum_value:pbdef.ACTION_TYPE.AT_DOLIKE_PAI)
    AT_DOLIKE_PAI = 3,
    // @@protoc_insertion_point(enum_value:pbdef.ACTION_TYPE.AT_DOLIKE_COMMENT)
    AT_DOLIKE_COMMENT = 4,
}

impl ::protobuf::Enum for ACTION_TYPE {
    const NAME: &'static str = "ACTION_TYPE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ACTION_TYPE> {
        match value {
            0 => ::std::option::Option::Some(ACTION_TYPE::AT_NONE),
            1 => ::std::option::Option::Some(ACTION_TYPE::AT_COMMENT_PAI),
            2 => ::std::option::Option::Some(ACTION_TYPE::AT_COMMENT_COMMENT),
            3 => ::std::option::Option::Some(ACTION_TYPE::AT_DOLIKE_PAI),
            4 => ::std::option::Option::Some(ACTION_TYPE::AT_DOLIKE_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ACTION_TYPE> {
        match str {
            "AT_NONE" => ::std::option::Option::Some(ACTION_TYPE::AT_NONE),
            "AT_COMMENT_PAI" => ::std::option::Option::Some(ACTION_TYPE::AT_COMMENT_PAI),
            "AT_COMMENT_COMMENT" => ::std::option::Option::Some(ACTION_TYPE::AT_COMMENT_COMMENT),
            "AT_DOLIKE_PAI" => ::std::option::Option::Some(ACTION_TYPE::AT_DOLIKE_PAI),
            "AT_DOLIKE_COMMENT" => ::std::option::Option::Some(ACTION_TYPE::AT_DOLIKE_COMMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ACTION_TYPE] = &[
        ACTION_TYPE::AT_NONE,
        ACTION_TYPE::AT_COMMENT_PAI,
        ACTION_TYPE::AT_COMMENT_COMMENT,
        ACTION_TYPE::AT_DOLIKE_PAI,
        ACTION_TYPE::AT_DOLIKE_COMMENT,
    ];
}

impl ::protobuf::EnumFull for ACTION_TYPE {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ACTION_TYPE").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ACTION_TYPE {
    fn default() -> Self {
        ACTION_TYPE::AT_NONE
    }
}

impl ACTION_TYPE {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ACTION_TYPE>("ACTION_TYPE")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cFriend.proto\x12\x05pbdef\x1a\x0eUserData.protoP\0\"\x96\x01\n\nFr\
    iendItem\x12\x1b\n\tfriend_id\x18\x01\x20\x01(\x04R\x08friendId\x12'\n\
    \x0ffriend_nickName\x18\x02\x20\x01(\tR\x0efriendNickName\x12\x1f\n\x0bf\
    riend_head\x18\x03\x20\x01(\tR\nfriendHead\x12!\n\x0cfriend_state\x18\
    \x04\x20\x01(\rR\x0bfriendState\"\x13\n\x11FriendsGetListReq\"Y\n\x11Fri\
    endsGetListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x122\n\x0bf\
    riend_list\x18\x02\x20\x03(\x0b2\x11.pbdef.FriendItemR\nfriendList\"3\n\
    \x10FriendsSearchReq\x12\x1f\n\x0bsearch_text\x18\x01\x20\x01(\tR\nsearc\
    hText\"e\n\x10FriendsSearchRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x12?\n\x12user_snapshot_list\x18\x02\x20\x03(\x0b2\x11.pbdef.Fri\
    endItemR\x10userSnapshotList\"M\n\x0fFriendsApplyReq\x12\x1b\n\tfriend_i\
    d\x18\x01\x20\x01(\x04R\x08friendId\x12\x1d\n\napply_text\x18\x02\x20\
    \x01(\tR\tapplyText\"#\n\x0fFriendsApplyRsp\x12\x10\n\x03ret\x18\x01\x20\
    \x01(\x05R\x03ret\"H\n\x12FriendsApplyNotify\x122\n\napply_user\x18\x01\
    \x20\x01(\x0b2\x13.pbdef.UserSnapshotR\tapplyUser\",\n\rFriendsDelReq\
    \x12\x1b\n\tfriend_id\x18\x01\x20\x01(\x04R\x08friendId\"!\n\rFriendsDel\
    Rsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"I\n\x14FriendsApplyRe\
    plyReq\x12\x1b\n\tfriend_id\x18\x01\x20\x01(\x04R\x08friendId\x12\x14\n\
    \x05agree\x18\x02\x20\x01(\x08R\x05agree\"(\n\x14FriendsApplyReplyRsp\
    \x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"]\n\x19FriendsMoveToBlac\
    kListReq\x12\x1b\n\tfriend_id\x18\x01\x20\x01(\x04R\x08friendId\x12#\n\
    \x0emove_to_or_out\x18\x02\x20\x01(\x08R\x0bmoveToOrOut\"-\n\x19FriendsM\
    oveToBlackListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"\x15\n\
    \x13FriendsApplyListReq\"j\n\x13FriendsApplyListRsp\x12\x10\n\x03ret\x18\
    \x01\x20\x01(\x05R\x03ret\x12A\n\x12user_snapshot_list\x18\x02\x20\x03(\
    \x0b2\x13.pbdef.UserSnapshotR\x10userSnapshotList\"\x8d\x01\n\x0fFriendG\
    roupItem\x12\x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\x12\x12\
    \n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04desc\x18\x03\x20\x01\
    (\tR\x04desc\x12\x12\n\x04head\x18\x04\x20\x01(\tR\x04head\x12#\n\rperso\
    n_number\x18\x05\x20\x01(\x05R\x0cpersonNumber\"S\n\x15FriendsGroupCreat\
    eReq\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04desc\x18\
    \x02\x20\x01(\tR\x04desc\x12\x12\n\x04head\x18\x03\x20\x01(\tR\x04head\"\
    D\n\x15FriendsGroupCreateRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03r\
    et\x12\x19\n\x08group_id\x18\x02\x20\x01(\x04R\x07groupId\"D\n\x15Friend\
    sGroupInviteReq\x12\x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\
    \x12\x10\n\x03uid\x18\x02\x20\x03(\x04R\x03uid\")\n\x15FriendsGroupInvit\
    eRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"N\n\x16FriendsHandle\
    InviteReq\x12\x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\x12\x19\
    \n\x08is_agree\x18\x02\x20\x01(\x08R\x07isAgree\"*\n\x16FriendsHandleInv\
    iteRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"1\n\x14FriendsGrou\
    pApplyReq\x12\x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\"(\n\
    \x14FriendsGroupApplyRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"\
    d\n\x1aFriendsHandleGroupApplyReq\x12\x19\n\x08group_id\x18\x01\x20\x01(\
    \x04R\x07groupId\x12\x10\n\x03uid\x18\x02\x20\x01(\x04R\x03uid\x12\x19\n\
    \x08is_agree\x18\x03\x20\x01(\x08R\x07isAgree\".\n\x1aFriendsHandleGroup\
    ApplyRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"\x1b\n\x19Friend\
    sGroupInviteListReq\"[\n\x19FriendsGroupInviteListRsp\x12\x10\n\x03ret\
    \x18\x01\x20\x01(\x05R\x03ret\x12,\n\x05lists\x18\x02\x20\x03(\x0b2\x16.\
    pbdef.FriendGroupItemR\x05lists\"5\n\x18FriendsGroupApplyListReq\x12\x19\
    \n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\"o\n\x18FriendsGroupAppl\
    yListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12A\n\x12user_sn\
    apshot_list\x18\x02\x20\x03(\x0b2\x13.pbdef.UserSnapshotR\x10userSnapsho\
    tList\"\x17\n\x15FriendsMyGroupListReq\"`\n\x15FriendsMyGroupListRsp\x12\
    \x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x125\n\ngroup_list\x18\x02\
    \x20\x03(\x0b2\x16.pbdef.FriendGroupItemR\tgroupList\"6\n\x19FriendsMyGr\
    oupUserListReq\x12\x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\"p\
    \n\x19FriendsMyGroupUserListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x12A\n\x12user_snapshot_list\x18\x02\x20\x03(\x0b2\x13.pbdef.Use\
    rSnapshotR\x10userSnapshotList\"J\n\x1bFriendsGroupChangeMasterReq\x12\
    \x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\x12\x10\n\x03uid\x18\
    \x02\x20\x01(\x04R\x03uid\"/\n\x1bFriendsGroupChangeMasterRsp\x12\x10\n\
    \x03ret\x18\x01\x20\x01(\x05R\x03ret\"E\n\x16FriendsGroupTickOutReq\x12\
    \x19\n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\x12\x10\n\x03uid\x18\
    \x02\x20\x01(\x04R\x03uid\"*\n\x16FriendsGroupTickOutRsp\x12\x10\n\x03re\
    t\x18\x01\x20\x01(\x05R\x03ret\"[\n\x18FriendsGroupsStopTalkReq\x12\x19\
    \n\x08group_id\x18\x01\x20\x01(\x04R\x07groupId\x12\x10\n\x03uid\x18\x02\
    \x20\x01(\x04R\x03uid\x12\x12\n\x04time\x18\x03\x20\x01(\rR\x04time\",\n\
    \x18FriendsGroupsStopTalkRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03r\
    et\"3\n\x15FriendsGroupSearchReq\x12\x1a\n\x08keywords\x18\x01\x20\x01(\
    \tR\x08keywords\"W\n\x15FriendsGroupSearchRsp\x12\x10\n\x03ret\x18\x01\
    \x20\x01(\x05R\x03ret\x12,\n\x05lists\x18\x02\x20\x03(\x0b2\x16.pbdef.Fr\
    iendGroupItemR\x05lists\"^\n\x0eSendChatMsgReq\x12\x19\n\x08msg_type\x18\
    \x01\x20\x01(\x05R\x07msgType\x12\x1f\n\x0brecivier_id\x18\x02\x20\x01(\
    \x04R\nrecivierId\x12\x10\n\x03msg\x18\x03\x20\x01(\tR\x03msg\"O\n\x0eSe\
    ndChatMsgRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12+\n\x07new\
    _msg\x18\x02\x20\x01(\x0b2\x12.pbdef.ChatMessageR\x06newMsg\"P\n\x14GetH\
    istoryMsgListReq\x12\x19\n\x08msg_type\x18\x01\x20\x01(\x05R\x07msgType\
    \x12\x1d\n\ntarget_uid\x18\x02\x20\x01(\x04R\ttargetUid\"Y\n\x14GetHisto\
    ryMsgListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12/\n\tmsg_l\
    ists\x18\x02\x20\x03(\x0b2\x12.pbdef.ChatMessageR\x08msgLists\"b\n\x11Ch\
    atMessageNotify\x12\x20\n\x0bchannelType\x18\x01\x20\x01(\rR\x0bchannelT\
    ype\x12+\n\x07new_msg\x18\x02\x20\x01(\x0b2\x12.pbdef.ChatMessageR\x06ne\
    wMsg\"\x96\x01\n\x0eCircleIssueReq\x12\x19\n\x08img_urls\x18\x01\x20\x01\
    (\tR\x07imgUrls\x12\x18\n\x07content\x18\x02\x20\x01(\tR\x07content\x12\
    \x1e\n\nvisibility\x18\x03\x20\x01(\rR\nvisibility\x12/\n\x08userData\
    \x18\x04\x20\x01(\x0b2\x13.pbdef.UserSnapshotR\x08userData\"\"\n\x0eCirc\
    leIssueRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"q\n\rCircleLis\
    tReq\x12\x17\n\x07user_id\x18\x01\x20\x01(\x04R\x06userId\x12\x12\n\x04p\
    age\x18\x02\x20\x01(\rR\x04page\x12\x14\n\x05limit\x18\x03\x20\x01(\rR\
    \x05limit\x12\x1d\n\nfriend_ids\x18\x04\x20\x03(\x04R\tfriendIds\"Q\n\rC\
    ircleListRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12.\n\x05lis\
    ts\x18\x02\x20\x03(\x0b2\x18.pbdef.CircleArticleItemR\x05lists\"\xed\x02\
    \n\x11CircleArticleItem\x12\x1d\n\narticle_id\x18\x01\x20\x01(\x04R\tart\
    icleId\x12\x1b\n\tuser_name\x18\x02\x20\x01(\tR\x08userName\x12\x1b\n\tu\
    ser_head\x18\x03\x20\x01(\tR\x08userHead\x12\x19\n\x08img_urls\x18\x04\
    \x20\x01(\tR\x07imgUrls\x12\x18\n\x07content\x18\x05\x20\x01(\tR\x07cont\
    ent\x12\x19\n\x08like_num\x18\x06\x20\x01(\rR\x07likeNum\x12\x1f\n\x0bco\
    mment_num\x18\x07\x20\x01(\rR\ncommentNum\x127\n\rcomment_lists\x18\x08\
    \x20\x03(\x0b2\x12.pbdef.CommentItemR\x0ccommentLists\x12\x1b\n\tself_li\
    ke\x18\t\x20\x01(\x08R\x08selfLike\x12\x1f\n\x0bcreate_time\x18\n\x20\
    \x01(\rR\ncreateTime\x12\x17\n\x07user_id\x18\x0b\x20\x01(\x04R\x06userI\
    d\"\xfd\x02\n\x0bCommentItem\x12\x1d\n\ncomment_id\x18\x01\x20\x01(\x04R\
    \tcommentId\x12\x18\n\x07content\x18\x02\x20\x01(\tR\x07content\x12\x1b\
    \n\tuser_name\x18\x03\x20\x01(\tR\x08userName\x12\x1b\n\tuser_head\x18\
    \x04\x20\x01(\tR\x08userHead\x12\x19\n\x08like_num\x18\x05\x20\x01(\rR\
    \x07likeNum\x12\x1b\n\treply_num\x18\x06\x20\x01(\rR\x08replyNum\x12\x1b\
    \n\tself_like\x18\x07\x20\x01(\x08R\x08selfLike\x12*\n\x06replys\x18\x08\
    \x20\x03(\x0b2\x12.pbdef.CommentItemR\x06replys\x12\x1f\n\x0bcreate_time\
    \x18\t\x20\x01(\rR\ncreateTime\x12\x17\n\x07user_id\x18\n\x20\x01(\x04R\
    \x06userId\x12\x1d\n\ntarget_uid\x18\x0b\x20\x01(\x04R\ttargetUid\x12!\n\
    \x0cplace_holder\x18\x14\x20\x01(\x08R\x0bplaceHolder\"0\n\x0fCircleDele\
    teReq\x12\x1d\n\narticle_id\x18\x01\x20\x01(\x04R\tarticleId\"#\n\x0fCir\
    cleDeleteRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\"\xce\x01\n\
    \x10CircleCommentReq\x12\x14\n\x05ctype\x18\x01\x20\x01(\rR\x05ctype\x12\
    \x1d\n\narticle_id\x18\x02\x20\x01(\x04R\tarticleId\x12\x1b\n\ttarget_id\
    \x18\x03\x20\x01(\x04R\x08targetId\x12\x18\n\x07content\x18\x04\x20\x01(\
    \tR\x07content\x12\x1d\n\ntarget_uid\x18\x05\x20\x01(\x04R\ttargetUid\
    \x12/\n\x08userData\x18\x06\x20\x01(\x0b2\x13.pbdef.UserSnapshotR\x08use\
    rData\"m\n\x10CircleCommentRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x12\x1f\n\x0bcomment_num\x18\x02\x20\x01(\rR\ncommentNum\x12&\n\
    \x04data\x18\x03\x20\x01(\x0b2\x12.pbdef.CommentItemR\x04data\"\xd2\x01\
    \n\rCircleLikeReq\x12\x1d\n\narticle_id\x18\x01\x20\x01(\x04R\tarticleId\
    \x12\x14\n\x05ctype\x18\x02\x20\x01(\rR\x05ctype\x12\x1b\n\ttarget_id\
    \x18\x03\x20\x01(\x04R\x08targetId\x12\x16\n\x06dolike\x18\x04\x20\x01(\
    \x08R\x06dolike\x12&\n\x0fbeliked_user_id\x18\x05\x20\x01(\x04R\rbeliked\
    UserId\x12/\n\x08userData\x18\x06\x20\x01(\x0b2\x13.pbdef.UserSnapshotR\
    \x08userData\"<\n\rCircleLikeRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x12\x19\n\x08like_num\x18\x02\x20\x01(\rR\x07likeNum\"I\n\x10Use\
    rArticleNotes\x125\n\x08logItems\x18\x01\x20\x03(\x0b2\x19.pbdef.UserArt\
    icleLogItemR\x08logItems\"\xa6\x01\n\x12UserArticleLogItem\x12\x1c\n\tti\
    mestemp\x18\x01\x20\x01(\rR\ttimestemp\x12\x1b\n\tuser_name\x18\x02\x20\
    \x01(\tR\x08userName\x12\x1b\n\tuser_head\x18\x03\x20\x01(\tR\x08userHea\
    d\x12\x1f\n\x0baction_type\x18\x04\x20\x01(\rR\nactionType\x12\x17\n\x07\
    user_id\x18\x05\x20\x01(\x04R\x06userId\"\x18\n\x16GetUserArticleNotesRe\
    q\"a\n\x16GetUserArticleNotesRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\
    \x03ret\x125\n\x08logItems\x18\x02\x20\x03(\x0b2\x19.pbdef.UserArticleLo\
    gItemR\x08logItems\"M\n\x14UserArticleLogNotify\x125\n\x08logItems\x18\
    \x01\x20\x01(\x0b2\x19.pbdef.UserArticleLogItemR\x08logItems\"]\n\x12Get\
    CommentListsReq\x12\x1d\n\narticle_id\x18\x01\x20\x01(\x04R\tarticleId\
    \x12\x12\n\x04page\x18\x02\x20\x01(\rR\x04page\x12\x14\n\x05limit\x18\
    \x03\x20\x01(\rR\x05limit\"P\n\x12GetCommentListsRsp\x12\x10\n\x03ret\
    \x18\x01\x20\x01(\x05R\x03ret\x12(\n\x05lists\x18\x02\x20\x03(\x0b2\x12.\
    pbdef.CommentItemR\x05lists\"z\n\x10GetReplyListsReq\x12\x1d\n\narticle_\
    id\x18\x01\x20\x01(\x04R\tarticleId\x12\x1d\n\ncommetn_id\x18\x02\x20\
    \x01(\x04R\tcommetnId\x12\x12\n\x04page\x18\x03\x20\x01(\rR\x04page\x12\
    \x14\n\x05limit\x18\x04\x20\x01(\rR\x05limit\"N\n\x10GetReplyListsRsp\
    \x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12(\n\x05lists\x18\x02\
    \x20\x03(\x0b2\x12.pbdef.CommentItemR\x05lists\"\x1b\n\x19RemoveUserArti\
    cleNotesReq\"-\n\x19RemoveUserArticleNotesRsp\x12\x10\n\x03ret\x18\x01\
    \x20\x01(\x05R\x03ret*F\n\tVIEW_AREA\x12\n\n\x06T_NONE\x10\0\x12\x0c\n\
    \x08T_FRIEND\x10\x01\x12\x13\n\x0fT_FRIEND_CANNOT\x10\x02\x12\n\n\x06T_S\
    ELF\x10\x03*p\n\x0bACTION_TYPE\x12\x0b\n\x07AT_NONE\x10\0\x12\x12\n\x0eA\
    T_COMMENT_PAI\x10\x01\x12\x16\n\x12AT_COMMENT_COMMENT\x10\x02\x12\x11\n\
    \rAT_DOLIKE_PAI\x10\x03\x12\x15\n\x11AT_DOLIKE_COMMENT\x10\x04b\x06proto\
    3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::UserData::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(71);
            messages.push(FriendItem::generated_message_descriptor_data());
            messages.push(FriendsGetListReq::generated_message_descriptor_data());
            messages.push(FriendsGetListRsp::generated_message_descriptor_data());
            messages.push(FriendsSearchReq::generated_message_descriptor_data());
            messages.push(FriendsSearchRsp::generated_message_descriptor_data());
            messages.push(FriendsApplyReq::generated_message_descriptor_data());
            messages.push(FriendsApplyRsp::generated_message_descriptor_data());
            messages.push(FriendsApplyNotify::generated_message_descriptor_data());
            messages.push(FriendsDelReq::generated_message_descriptor_data());
            messages.push(FriendsDelRsp::generated_message_descriptor_data());
            messages.push(FriendsApplyReplyReq::generated_message_descriptor_data());
            messages.push(FriendsApplyReplyRsp::generated_message_descriptor_data());
            messages.push(FriendsMoveToBlackListReq::generated_message_descriptor_data());
            messages.push(FriendsMoveToBlackListRsp::generated_message_descriptor_data());
            messages.push(FriendsApplyListReq::generated_message_descriptor_data());
            messages.push(FriendsApplyListRsp::generated_message_descriptor_data());
            messages.push(FriendGroupItem::generated_message_descriptor_data());
            messages.push(FriendsGroupCreateReq::generated_message_descriptor_data());
            messages.push(FriendsGroupCreateRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupInviteReq::generated_message_descriptor_data());
            messages.push(FriendsGroupInviteRsp::generated_message_descriptor_data());
            messages.push(FriendsHandleInviteReq::generated_message_descriptor_data());
            messages.push(FriendsHandleInviteRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupApplyReq::generated_message_descriptor_data());
            messages.push(FriendsGroupApplyRsp::generated_message_descriptor_data());
            messages.push(FriendsHandleGroupApplyReq::generated_message_descriptor_data());
            messages.push(FriendsHandleGroupApplyRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupInviteListReq::generated_message_descriptor_data());
            messages.push(FriendsGroupInviteListRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupApplyListReq::generated_message_descriptor_data());
            messages.push(FriendsGroupApplyListRsp::generated_message_descriptor_data());
            messages.push(FriendsMyGroupListReq::generated_message_descriptor_data());
            messages.push(FriendsMyGroupListRsp::generated_message_descriptor_data());
            messages.push(FriendsMyGroupUserListReq::generated_message_descriptor_data());
            messages.push(FriendsMyGroupUserListRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupChangeMasterReq::generated_message_descriptor_data());
            messages.push(FriendsGroupChangeMasterRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupTickOutReq::generated_message_descriptor_data());
            messages.push(FriendsGroupTickOutRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupsStopTalkReq::generated_message_descriptor_data());
            messages.push(FriendsGroupsStopTalkRsp::generated_message_descriptor_data());
            messages.push(FriendsGroupSearchReq::generated_message_descriptor_data());
            messages.push(FriendsGroupSearchRsp::generated_message_descriptor_data());
            messages.push(SendChatMsgReq::generated_message_descriptor_data());
            messages.push(SendChatMsgRsp::generated_message_descriptor_data());
            messages.push(GetHistoryMsgListReq::generated_message_descriptor_data());
            messages.push(GetHistoryMsgListRsp::generated_message_descriptor_data());
            messages.push(ChatMessageNotify::generated_message_descriptor_data());
            messages.push(CircleIssueReq::generated_message_descriptor_data());
            messages.push(CircleIssueRsp::generated_message_descriptor_data());
            messages.push(CircleListReq::generated_message_descriptor_data());
            messages.push(CircleListRsp::generated_message_descriptor_data());
            messages.push(CircleArticleItem::generated_message_descriptor_data());
            messages.push(CommentItem::generated_message_descriptor_data());
            messages.push(CircleDeleteReq::generated_message_descriptor_data());
            messages.push(CircleDeleteRsp::generated_message_descriptor_data());
            messages.push(CircleCommentReq::generated_message_descriptor_data());
            messages.push(CircleCommentRsp::generated_message_descriptor_data());
            messages.push(CircleLikeReq::generated_message_descriptor_data());
            messages.push(CircleLikeRsp::generated_message_descriptor_data());
            messages.push(UserArticleNotes::generated_message_descriptor_data());
            messages.push(UserArticleLogItem::generated_message_descriptor_data());
            messages.push(GetUserArticleNotesReq::generated_message_descriptor_data());
            messages.push(GetUserArticleNotesRsp::generated_message_descriptor_data());
            messages.push(UserArticleLogNotify::generated_message_descriptor_data());
            messages.push(GetCommentListsReq::generated_message_descriptor_data());
            messages.push(GetCommentListsRsp::generated_message_descriptor_data());
            messages.push(GetReplyListsReq::generated_message_descriptor_data());
            messages.push(GetReplyListsRsp::generated_message_descriptor_data());
            messages.push(RemoveUserArticleNotesReq::generated_message_descriptor_data());
            messages.push(RemoveUserArticleNotesRsp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(VIEW_AREA::generated_enum_descriptor_data());
            enums.push(ACTION_TYPE::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
