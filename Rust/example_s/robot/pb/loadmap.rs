// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `LoadMap.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:pbdef.MapPoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapPoint {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MapPoint.x)
    pub x: i32,
    // @@protoc_insertion_point(field:pbdef.MapPoint.y)
    pub y: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MapPoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapPoint {
    fn default() -> &'a MapPoint {
        <MapPoint as ::protobuf::Message>::default_instance()
    }
}

impl MapPoint {
    pub fn new() -> MapPoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &MapPoint| { &m.x },
            |m: &mut MapPoint| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &MapPoint| { &m.y },
            |m: &mut MapPoint| { &mut m.y },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapPoint>(
            "MapPoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapPoint {
    const NAME: &'static str = "MapPoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.x = is.read_int32()?;
                },
                16 => {
                    self.y = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.y);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0 {
            os.write_int32(1, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(2, self.y)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapPoint {
        MapPoint::new()
    }

    fn clear(&mut self) {
        self.x = 0;
        self.y = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapPoint {
        static instance: MapPoint = MapPoint {
            x: 0,
            y: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapPoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapPoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapPoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MapInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapInfo {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MapInfo.id)
    pub id: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.pid)
    pub pid: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.daxiao)
    pub daxiao: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfo.x)
    pub x: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.y)
    pub y: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.user_id)
    pub user_id: u64,
    // @@protoc_insertion_point(field:pbdef.MapInfo.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfo.url1)
    pub url1: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfo.forwork)
    pub forwork: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.public_flag)
    pub public_flag: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.public_name)
    pub public_name: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfo.open)
    pub open: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfo.canbuy)
    pub canbuy: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MapInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapInfo {
    fn default() -> &'a MapInfo {
        <MapInfo as ::protobuf::Message>::default_instance()
    }
}

impl MapInfo {
    pub fn new() -> MapInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MapInfo| { &m.id },
            |m: &mut MapInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pid",
            |m: &MapInfo| { &m.pid },
            |m: &mut MapInfo| { &mut m.pid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "daxiao",
            |m: &MapInfo| { &m.daxiao },
            |m: &mut MapInfo| { &mut m.daxiao },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &MapInfo| { &m.x },
            |m: &mut MapInfo| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &MapInfo| { &m.y },
            |m: &mut MapInfo| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &MapInfo| { &m.user_id },
            |m: &mut MapInfo| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &MapInfo| { &m.url },
            |m: &mut MapInfo| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url1",
            |m: &MapInfo| { &m.url1 },
            |m: &mut MapInfo| { &mut m.url1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "forwork",
            |m: &MapInfo| { &m.forwork },
            |m: &mut MapInfo| { &mut m.forwork },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_flag",
            |m: &MapInfo| { &m.public_flag },
            |m: &mut MapInfo| { &mut m.public_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_name",
            |m: &MapInfo| { &m.public_name },
            |m: &mut MapInfo| { &mut m.public_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "open",
            |m: &MapInfo| { &m.open },
            |m: &mut MapInfo| { &mut m.open },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "canbuy",
            |m: &MapInfo| { &m.canbuy },
            |m: &mut MapInfo| { &mut m.canbuy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapInfo>(
            "MapInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapInfo {
    const NAME: &'static str = "MapInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.pid = is.read_int32()?;
                },
                26 => {
                    self.daxiao = is.read_string()?;
                },
                32 => {
                    self.x = is.read_int32()?;
                },
                40 => {
                    self.y = is.read_int32()?;
                },
                48 => {
                    self.user_id = is.read_uint64()?;
                },
                58 => {
                    self.url = is.read_string()?;
                },
                66 => {
                    self.url1 = is.read_string()?;
                },
                72 => {
                    self.forwork = is.read_int32()?;
                },
                80 => {
                    self.public_flag = is.read_int32()?;
                },
                90 => {
                    self.public_name = is.read_string()?;
                },
                96 => {
                    self.open = is.read_int32()?;
                },
                104 => {
                    self.canbuy = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.pid != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.pid);
        }
        if !self.daxiao.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.daxiao);
        }
        if self.x != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.x);
        }
        if self.y != 0 {
            my_size += ::protobuf::rt::int32_size(5, self.y);
        }
        if self.user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.user_id);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.url);
        }
        if !self.url1.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.url1);
        }
        if self.forwork != 0 {
            my_size += ::protobuf::rt::int32_size(9, self.forwork);
        }
        if self.public_flag != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.public_flag);
        }
        if !self.public_name.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.public_name);
        }
        if self.open != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.open);
        }
        if self.canbuy != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.canbuy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.pid != 0 {
            os.write_int32(2, self.pid)?;
        }
        if !self.daxiao.is_empty() {
            os.write_string(3, &self.daxiao)?;
        }
        if self.x != 0 {
            os.write_int32(4, self.x)?;
        }
        if self.y != 0 {
            os.write_int32(5, self.y)?;
        }
        if self.user_id != 0 {
            os.write_uint64(6, self.user_id)?;
        }
        if !self.url.is_empty() {
            os.write_string(7, &self.url)?;
        }
        if !self.url1.is_empty() {
            os.write_string(8, &self.url1)?;
        }
        if self.forwork != 0 {
            os.write_int32(9, self.forwork)?;
        }
        if self.public_flag != 0 {
            os.write_int32(10, self.public_flag)?;
        }
        if !self.public_name.is_empty() {
            os.write_string(11, &self.public_name)?;
        }
        if self.open != 0 {
            os.write_int32(12, self.open)?;
        }
        if self.canbuy != 0 {
            os.write_int32(13, self.canbuy)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapInfo {
        MapInfo::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.pid = 0;
        self.daxiao.clear();
        self.x = 0;
        self.y = 0;
        self.user_id = 0;
        self.url.clear();
        self.url1.clear();
        self.forwork = 0;
        self.public_flag = 0;
        self.public_name.clear();
        self.open = 0;
        self.canbuy = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapInfo {
        static instance: MapInfo = MapInfo {
            id: 0,
            pid: 0,
            daxiao: ::std::string::String::new(),
            x: 0,
            y: 0,
            user_id: 0,
            url: ::std::string::String::new(),
            url1: ::std::string::String::new(),
            forwork: 0,
            public_flag: 0,
            public_name: ::std::string::String::new(),
            open: 0,
            canbuy: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.CostParam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CostParam {
    // message fields
    // @@protoc_insertion_point(field:pbdef.CostParam.JiFen)
    pub JiFen: f32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.CostParam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CostParam {
    fn default() -> &'a CostParam {
        <CostParam as ::protobuf::Message>::default_instance()
    }
}

impl CostParam {
    pub fn new() -> CostParam {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "JiFen",
            |m: &CostParam| { &m.JiFen },
            |m: &mut CostParam| { &mut m.JiFen },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CostParam>(
            "CostParam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CostParam {
    const NAME: &'static str = "CostParam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.JiFen = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.JiFen != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.JiFen != 0. {
            os.write_float(1, self.JiFen)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CostParam {
        CostParam::new()
    }

    fn clear(&mut self) {
        self.JiFen = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CostParam {
        static instance: CostParam = CostParam {
            JiFen: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CostParam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CostParam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CostParam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CostParam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.MapInfoDetail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MapInfoDetail {
    // message fields
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.enter)
    pub enter: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.weburl)
    pub weburl: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.price)
    pub price: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.canbuy)
    pub canbuy: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.buytime)
    pub buytime: i64,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.expiretime)
    pub expiretime: i64,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.nickname)
    pub nickname: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.landname)
    pub landname: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.priceJiFen)
    pub priceJiFen: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.edit)
    pub edit: bool,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.public_flag)
    pub public_flag: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.jianjie)
    pub jianjie: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.id)
    pub id: i32,
    // @@protoc_insertion_point(field:pbdef.MapInfoDetail.can_be_enter)
    pub can_be_enter: bool,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.MapInfoDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MapInfoDetail {
    fn default() -> &'a MapInfoDetail {
        <MapInfoDetail as ::protobuf::Message>::default_instance()
    }
}

impl MapInfoDetail {
    pub fn new() -> MapInfoDetail {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enter",
            |m: &MapInfoDetail| { &m.enter },
            |m: &mut MapInfoDetail| { &mut m.enter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "weburl",
            |m: &MapInfoDetail| { &m.weburl },
            |m: &mut MapInfoDetail| { &mut m.weburl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "price",
            |m: &MapInfoDetail| { &m.price },
            |m: &mut MapInfoDetail| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "canbuy",
            |m: &MapInfoDetail| { &m.canbuy },
            |m: &mut MapInfoDetail| { &mut m.canbuy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buytime",
            |m: &MapInfoDetail| { &m.buytime },
            |m: &mut MapInfoDetail| { &mut m.buytime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "expiretime",
            |m: &MapInfoDetail| { &m.expiretime },
            |m: &mut MapInfoDetail| { &mut m.expiretime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nickname",
            |m: &MapInfoDetail| { &m.nickname },
            |m: &mut MapInfoDetail| { &mut m.nickname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "landname",
            |m: &MapInfoDetail| { &m.landname },
            |m: &mut MapInfoDetail| { &mut m.landname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "priceJiFen",
            |m: &MapInfoDetail| { &m.priceJiFen },
            |m: &mut MapInfoDetail| { &mut m.priceJiFen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "edit",
            |m: &MapInfoDetail| { &m.edit },
            |m: &mut MapInfoDetail| { &mut m.edit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_flag",
            |m: &MapInfoDetail| { &m.public_flag },
            |m: &mut MapInfoDetail| { &mut m.public_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "jianjie",
            |m: &MapInfoDetail| { &m.jianjie },
            |m: &mut MapInfoDetail| { &mut m.jianjie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &MapInfoDetail| { &m.id },
            |m: &mut MapInfoDetail| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "can_be_enter",
            |m: &MapInfoDetail| { &m.can_be_enter },
            |m: &mut MapInfoDetail| { &mut m.can_be_enter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MapInfoDetail>(
            "MapInfoDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MapInfoDetail {
    const NAME: &'static str = "MapInfoDetail";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enter = is.read_int32()?;
                },
                18 => {
                    self.weburl = is.read_string()?;
                },
                26 => {
                    self.price = is.read_string()?;
                },
                32 => {
                    self.canbuy = is.read_int32()?;
                },
                40 => {
                    self.buytime = is.read_int64()?;
                },
                48 => {
                    self.expiretime = is.read_int64()?;
                },
                58 => {
                    self.nickname = is.read_string()?;
                },
                66 => {
                    self.landname = is.read_string()?;
                },
                74 => {
                    self.priceJiFen = is.read_string()?;
                },
                80 => {
                    self.edit = is.read_bool()?;
                },
                88 => {
                    self.public_flag = is.read_int32()?;
                },
                98 => {
                    self.jianjie = is.read_string()?;
                },
                104 => {
                    self.id = is.read_int32()?;
                },
                112 => {
                    self.can_be_enter = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.enter != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.enter);
        }
        if !self.weburl.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.weburl);
        }
        if !self.price.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.price);
        }
        if self.canbuy != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.canbuy);
        }
        if self.buytime != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.buytime);
        }
        if self.expiretime != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.expiretime);
        }
        if !self.nickname.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.nickname);
        }
        if !self.landname.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.landname);
        }
        if !self.priceJiFen.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.priceJiFen);
        }
        if self.edit != false {
            my_size += 1 + 1;
        }
        if self.public_flag != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.public_flag);
        }
        if !self.jianjie.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.jianjie);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(13, self.id);
        }
        if self.can_be_enter != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.enter != 0 {
            os.write_int32(1, self.enter)?;
        }
        if !self.weburl.is_empty() {
            os.write_string(2, &self.weburl)?;
        }
        if !self.price.is_empty() {
            os.write_string(3, &self.price)?;
        }
        if self.canbuy != 0 {
            os.write_int32(4, self.canbuy)?;
        }
        if self.buytime != 0 {
            os.write_int64(5, self.buytime)?;
        }
        if self.expiretime != 0 {
            os.write_int64(6, self.expiretime)?;
        }
        if !self.nickname.is_empty() {
            os.write_string(7, &self.nickname)?;
        }
        if !self.landname.is_empty() {
            os.write_string(8, &self.landname)?;
        }
        if !self.priceJiFen.is_empty() {
            os.write_string(9, &self.priceJiFen)?;
        }
        if self.edit != false {
            os.write_bool(10, self.edit)?;
        }
        if self.public_flag != 0 {
            os.write_int32(11, self.public_flag)?;
        }
        if !self.jianjie.is_empty() {
            os.write_string(12, &self.jianjie)?;
        }
        if self.id != 0 {
            os.write_int32(13, self.id)?;
        }
        if self.can_be_enter != false {
            os.write_bool(14, self.can_be_enter)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MapInfoDetail {
        MapInfoDetail::new()
    }

    fn clear(&mut self) {
        self.enter = 0;
        self.weburl.clear();
        self.price.clear();
        self.canbuy = 0;
        self.buytime = 0;
        self.expiretime = 0;
        self.nickname.clear();
        self.landname.clear();
        self.priceJiFen.clear();
        self.edit = false;
        self.public_flag = 0;
        self.jianjie.clear();
        self.id = 0;
        self.can_be_enter = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MapInfoDetail {
        static instance: MapInfoDetail = MapInfoDetail {
            enter: 0,
            weburl: ::std::string::String::new(),
            price: ::std::string::String::new(),
            canbuy: 0,
            buytime: 0,
            expiretime: 0,
            nickname: ::std::string::String::new(),
            landname: ::std::string::String::new(),
            priceJiFen: ::std::string::String::new(),
            edit: false,
            public_flag: 0,
            jianjie: ::std::string::String::new(),
            id: 0,
            can_be_enter: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MapInfoDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MapInfoDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MapInfoDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MapInfoDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadMapReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadMapReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoadMapReq.fromx)
    pub fromx: i32,
    // @@protoc_insertion_point(field:pbdef.LoadMapReq.fromy)
    pub fromy: i32,
    // @@protoc_insertion_point(field:pbdef.LoadMapReq.tox)
    pub tox: i32,
    // @@protoc_insertion_point(field:pbdef.LoadMapReq.toy)
    pub toy: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadMapReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadMapReq {
    fn default() -> &'a LoadMapReq {
        <LoadMapReq as ::protobuf::Message>::default_instance()
    }
}

impl LoadMapReq {
    pub fn new() -> LoadMapReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromx",
            |m: &LoadMapReq| { &m.fromx },
            |m: &mut LoadMapReq| { &mut m.fromx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fromy",
            |m: &LoadMapReq| { &m.fromy },
            |m: &mut LoadMapReq| { &mut m.fromy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tox",
            |m: &LoadMapReq| { &m.tox },
            |m: &mut LoadMapReq| { &mut m.tox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "toy",
            |m: &LoadMapReq| { &m.toy },
            |m: &mut LoadMapReq| { &mut m.toy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadMapReq>(
            "LoadMapReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadMapReq {
    const NAME: &'static str = "LoadMapReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fromx = is.read_int32()?;
                },
                16 => {
                    self.fromy = is.read_int32()?;
                },
                24 => {
                    self.tox = is.read_int32()?;
                },
                32 => {
                    self.toy = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.fromx != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.fromx);
        }
        if self.fromy != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.fromy);
        }
        if self.tox != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.tox);
        }
        if self.toy != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.toy);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.fromx != 0 {
            os.write_int32(1, self.fromx)?;
        }
        if self.fromy != 0 {
            os.write_int32(2, self.fromy)?;
        }
        if self.tox != 0 {
            os.write_int32(3, self.tox)?;
        }
        if self.toy != 0 {
            os.write_int32(4, self.toy)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadMapReq {
        LoadMapReq::new()
    }

    fn clear(&mut self) {
        self.fromx = 0;
        self.fromy = 0;
        self.tox = 0;
        self.toy = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadMapReq {
        static instance: LoadMapReq = LoadMapReq {
            fromx: 0,
            fromy: 0,
            tox: 0,
            toy: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadMapReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadMapReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadMapReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadMapReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.LoadMapRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoadMapRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoadMapRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.LoadMapRsp.infos)
    pub infos: ::std::vec::Vec<MapInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoadMapRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoadMapRsp {
    fn default() -> &'a LoadMapRsp {
        <LoadMapRsp as ::protobuf::Message>::default_instance()
    }
}

impl LoadMapRsp {
    pub fn new() -> LoadMapRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &LoadMapRsp| { &m.ret },
            |m: &mut LoadMapRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &LoadMapRsp| { &m.infos },
            |m: &mut LoadMapRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoadMapRsp>(
            "LoadMapRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoadMapRsp {
    const NAME: &'static str = "LoadMapRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoadMapRsp {
        LoadMapRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoadMapRsp {
        static instance: LoadMapRsp = LoadMapRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoadMapRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoadMapRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoadMapRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadMapRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.BuySceneReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BuySceneReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.BuySceneReq.point)
    pub point: ::protobuf::MessageField<MapPoint>,
    // @@protoc_insertion_point(field:pbdef.BuySceneReq.day)
    pub day: i32,
    // @@protoc_insertion_point(field:pbdef.BuySceneReq.paytype)
    pub paytype: i32,
    // @@protoc_insertion_point(field:pbdef.BuySceneReq.param)
    pub param: ::protobuf::MessageField<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.BuySceneReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuySceneReq {
    fn default() -> &'a BuySceneReq {
        <BuySceneReq as ::protobuf::Message>::default_instance()
    }
}

impl BuySceneReq {
    pub fn new() -> BuySceneReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapPoint>(
            "point",
            |m: &BuySceneReq| { &m.point },
            |m: &mut BuySceneReq| { &mut m.point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "day",
            |m: &BuySceneReq| { &m.day },
            |m: &mut BuySceneReq| { &mut m.day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paytype",
            |m: &BuySceneReq| { &m.paytype },
            |m: &mut BuySceneReq| { &mut m.paytype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::UserSnapshot>(
            "param",
            |m: &BuySceneReq| { &m.param },
            |m: &mut BuySceneReq| { &mut m.param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuySceneReq>(
            "BuySceneReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuySceneReq {
    const NAME: &'static str = "BuySceneReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.point)?;
                },
                16 => {
                    self.day = is.read_int32()?;
                },
                24 => {
                    self.paytype = is.read_int32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.param)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.day != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.day);
        }
        if self.paytype != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.paytype);
        }
        if let Some(v) = self.param.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.day != 0 {
            os.write_int32(2, self.day)?;
        }
        if self.paytype != 0 {
            os.write_int32(3, self.paytype)?;
        }
        if let Some(v) = self.param.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuySceneReq {
        BuySceneReq::new()
    }

    fn clear(&mut self) {
        self.point.clear();
        self.day = 0;
        self.paytype = 0;
        self.param.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuySceneReq {
        static instance: BuySceneReq = BuySceneReq {
            point: ::protobuf::MessageField::none(),
            day: 0,
            paytype: 0,
            param: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuySceneReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuySceneReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuySceneReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuySceneReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.BuySceneRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BuySceneRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.BuySceneRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.BuySceneRsp.wait_second)
    pub wait_second: i32,
    // @@protoc_insertion_point(field:pbdef.BuySceneRsp.order_no)
    pub order_no: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.BuySceneRsp.info)
    pub info: ::protobuf::MessageField<MapInfoDetail>,
    // @@protoc_insertion_point(field:pbdef.BuySceneRsp.map_info)
    pub map_info: ::protobuf::MessageField<MapInfo>,
    // @@protoc_insertion_point(field:pbdef.BuySceneRsp.param)
    pub param: ::protobuf::MessageField<CostParam>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.BuySceneRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BuySceneRsp {
    fn default() -> &'a BuySceneRsp {
        <BuySceneRsp as ::protobuf::Message>::default_instance()
    }
}

impl BuySceneRsp {
    pub fn new() -> BuySceneRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &BuySceneRsp| { &m.ret },
            |m: &mut BuySceneRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wait_second",
            |m: &BuySceneRsp| { &m.wait_second },
            |m: &mut BuySceneRsp| { &mut m.wait_second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "order_no",
            |m: &BuySceneRsp| { &m.order_no },
            |m: &mut BuySceneRsp| { &mut m.order_no },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapInfoDetail>(
            "info",
            |m: &BuySceneRsp| { &m.info },
            |m: &mut BuySceneRsp| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapInfo>(
            "map_info",
            |m: &BuySceneRsp| { &m.map_info },
            |m: &mut BuySceneRsp| { &mut m.map_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CostParam>(
            "param",
            |m: &BuySceneRsp| { &m.param },
            |m: &mut BuySceneRsp| { &mut m.param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BuySceneRsp>(
            "BuySceneRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BuySceneRsp {
    const NAME: &'static str = "BuySceneRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                16 => {
                    self.wait_second = is.read_int32()?;
                },
                26 => {
                    self.order_no = is.read_string()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.map_info)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.param)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if self.wait_second != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.wait_second);
        }
        if !self.order_no.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.order_no);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.param.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if self.wait_second != 0 {
            os.write_int32(2, self.wait_second)?;
        }
        if !self.order_no.is_empty() {
            os.write_string(3, &self.order_no)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.map_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.param.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BuySceneRsp {
        BuySceneRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.wait_second = 0;
        self.order_no.clear();
        self.info.clear();
        self.map_info.clear();
        self.param.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BuySceneRsp {
        static instance: BuySceneRsp = BuySceneRsp {
            ret: 0,
            wait_second: 0,
            order_no: ::std::string::String::new(),
            info: ::protobuf::MessageField::none(),
            map_info: ::protobuf::MessageField::none(),
            param: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BuySceneRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BuySceneRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BuySceneRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BuySceneRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.EditSceneReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EditSceneReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.point)
    pub point: ::protobuf::MessageField<MapPoint>,
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.jianjie)
    pub jianjie: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.url1)
    pub url1: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.weburl)
    pub weburl: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.enter)
    pub enter: i32,
    // @@protoc_insertion_point(field:pbdef.EditSceneReq.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.EditSceneReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EditSceneReq {
    fn default() -> &'a EditSceneReq {
        <EditSceneReq as ::protobuf::Message>::default_instance()
    }
}

impl EditSceneReq {
    pub fn new() -> EditSceneReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapPoint>(
            "point",
            |m: &EditSceneReq| { &m.point },
            |m: &mut EditSceneReq| { &mut m.point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "jianjie",
            |m: &EditSceneReq| { &m.jianjie },
            |m: &mut EditSceneReq| { &mut m.jianjie },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &EditSceneReq| { &m.url },
            |m: &mut EditSceneReq| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url1",
            |m: &EditSceneReq| { &m.url1 },
            |m: &mut EditSceneReq| { &mut m.url1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "weburl",
            |m: &EditSceneReq| { &m.weburl },
            |m: &mut EditSceneReq| { &mut m.weburl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enter",
            |m: &EditSceneReq| { &m.enter },
            |m: &mut EditSceneReq| { &mut m.enter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &EditSceneReq| { &m.name },
            |m: &mut EditSceneReq| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EditSceneReq>(
            "EditSceneReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EditSceneReq {
    const NAME: &'static str = "EditSceneReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.point)?;
                },
                18 => {
                    self.jianjie = is.read_string()?;
                },
                26 => {
                    self.url = is.read_string()?;
                },
                34 => {
                    self.url1 = is.read_string()?;
                },
                42 => {
                    self.weburl = is.read_string()?;
                },
                48 => {
                    self.enter = is.read_int32()?;
                },
                58 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.jianjie.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.jianjie);
        }
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.url);
        }
        if !self.url1.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.url1);
        }
        if !self.weburl.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.weburl);
        }
        if self.enter != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.enter);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.jianjie.is_empty() {
            os.write_string(2, &self.jianjie)?;
        }
        if !self.url.is_empty() {
            os.write_string(3, &self.url)?;
        }
        if !self.url1.is_empty() {
            os.write_string(4, &self.url1)?;
        }
        if !self.weburl.is_empty() {
            os.write_string(5, &self.weburl)?;
        }
        if self.enter != 0 {
            os.write_int32(6, self.enter)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EditSceneReq {
        EditSceneReq::new()
    }

    fn clear(&mut self) {
        self.point.clear();
        self.jianjie.clear();
        self.url.clear();
        self.url1.clear();
        self.weburl.clear();
        self.enter = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EditSceneReq {
        static instance: EditSceneReq = EditSceneReq {
            point: ::protobuf::MessageField::none(),
            jianjie: ::std::string::String::new(),
            url: ::std::string::String::new(),
            url1: ::std::string::String::new(),
            weburl: ::std::string::String::new(),
            enter: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EditSceneReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EditSceneReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EditSceneReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EditSceneReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.EditSceneRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EditSceneRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.EditSceneRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.EditSceneRsp.info)
    pub info: ::protobuf::MessageField<MapInfoDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.EditSceneRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EditSceneRsp {
    fn default() -> &'a EditSceneRsp {
        <EditSceneRsp as ::protobuf::Message>::default_instance()
    }
}

impl EditSceneRsp {
    pub fn new() -> EditSceneRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &EditSceneRsp| { &m.ret },
            |m: &mut EditSceneRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapInfoDetail>(
            "info",
            |m: &EditSceneRsp| { &m.info },
            |m: &mut EditSceneRsp| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EditSceneRsp>(
            "EditSceneRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EditSceneRsp {
    const NAME: &'static str = "EditSceneRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EditSceneRsp {
        EditSceneRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EditSceneRsp {
        static instance: EditSceneRsp = EditSceneRsp {
            ret: 0,
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EditSceneRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EditSceneRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EditSceneRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EditSceneRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ChooseSceneReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChooseSceneReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ChooseSceneReq.ctype)
    pub ctype: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ChooseSceneReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChooseSceneReq {
    fn default() -> &'a ChooseSceneReq {
        <ChooseSceneReq as ::protobuf::Message>::default_instance()
    }
}

impl ChooseSceneReq {
    pub fn new() -> ChooseSceneReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ctype",
            |m: &ChooseSceneReq| { &m.ctype },
            |m: &mut ChooseSceneReq| { &mut m.ctype },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChooseSceneReq>(
            "ChooseSceneReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChooseSceneReq {
    const NAME: &'static str = "ChooseSceneReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctype = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ctype != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ctype);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ctype != 0 {
            os.write_int32(1, self.ctype)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChooseSceneReq {
        ChooseSceneReq::new()
    }

    fn clear(&mut self) {
        self.ctype = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChooseSceneReq {
        static instance: ChooseSceneReq = ChooseSceneReq {
            ctype: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChooseSceneReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChooseSceneReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChooseSceneReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChooseSceneReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ChooseSceneRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChooseSceneRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ChooseSceneRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.ChooseSceneRsp.infos)
    pub infos: ::std::vec::Vec<MapInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ChooseSceneRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChooseSceneRsp {
    fn default() -> &'a ChooseSceneRsp {
        <ChooseSceneRsp as ::protobuf::Message>::default_instance()
    }
}

impl ChooseSceneRsp {
    pub fn new() -> ChooseSceneRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &ChooseSceneRsp| { &m.ret },
            |m: &mut ChooseSceneRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "infos",
            |m: &ChooseSceneRsp| { &m.infos },
            |m: &mut ChooseSceneRsp| { &mut m.infos },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChooseSceneRsp>(
            "ChooseSceneRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChooseSceneRsp {
    const NAME: &'static str = "ChooseSceneRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.infos.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.infos {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChooseSceneRsp {
        ChooseSceneRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.infos.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChooseSceneRsp {
        static instance: ChooseSceneRsp = ChooseSceneRsp {
            ret: 0,
            infos: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChooseSceneRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChooseSceneRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChooseSceneRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChooseSceneRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SceneDetailReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneDetailReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SceneDetailReq.point)
    pub point: ::protobuf::MessageField<MapPoint>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SceneDetailReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneDetailReq {
    fn default() -> &'a SceneDetailReq {
        <SceneDetailReq as ::protobuf::Message>::default_instance()
    }
}

impl SceneDetailReq {
    pub fn new() -> SceneDetailReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapPoint>(
            "point",
            |m: &SceneDetailReq| { &m.point },
            |m: &mut SceneDetailReq| { &mut m.point },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneDetailReq>(
            "SceneDetailReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneDetailReq {
    const NAME: &'static str = "SceneDetailReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.point)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneDetailReq {
        SceneDetailReq::new()
    }

    fn clear(&mut self) {
        self.point.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneDetailReq {
        static instance: SceneDetailReq = SceneDetailReq {
            point: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneDetailReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneDetailReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneDetailReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneDetailReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SceneDetailRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneDetailRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SceneDetailRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.SceneDetailRsp.info)
    pub info: ::protobuf::MessageField<MapInfoDetail>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SceneDetailRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneDetailRsp {
    fn default() -> &'a SceneDetailRsp {
        <SceneDetailRsp as ::protobuf::Message>::default_instance()
    }
}

impl SceneDetailRsp {
    pub fn new() -> SceneDetailRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &SceneDetailRsp| { &m.ret },
            |m: &mut SceneDetailRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapInfoDetail>(
            "info",
            |m: &SceneDetailRsp| { &m.info },
            |m: &mut SceneDetailRsp| { &mut m.info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneDetailRsp>(
            "SceneDetailRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneDetailRsp {
    const NAME: &'static str = "SceneDetailRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneDetailRsp {
        SceneDetailRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneDetailRsp {
        static instance: SceneDetailRsp = SceneDetailRsp {
            ret: 0,
            info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneDetailRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneDetailRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneDetailRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneDetailRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SceneRenewReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneRenewReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SceneRenewReq.point)
    pub point: ::protobuf::MessageField<MapPoint>,
    // @@protoc_insertion_point(field:pbdef.SceneRenewReq.day)
    pub day: i32,
    // @@protoc_insertion_point(field:pbdef.SceneRenewReq.paytype)
    pub paytype: i32,
    // @@protoc_insertion_point(field:pbdef.SceneRenewReq.param)
    pub param: ::protobuf::MessageField<super::UserData::UserSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SceneRenewReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneRenewReq {
    fn default() -> &'a SceneRenewReq {
        <SceneRenewReq as ::protobuf::Message>::default_instance()
    }
}

impl SceneRenewReq {
    pub fn new() -> SceneRenewReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapPoint>(
            "point",
            |m: &SceneRenewReq| { &m.point },
            |m: &mut SceneRenewReq| { &mut m.point },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "day",
            |m: &SceneRenewReq| { &m.day },
            |m: &mut SceneRenewReq| { &mut m.day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paytype",
            |m: &SceneRenewReq| { &m.paytype },
            |m: &mut SceneRenewReq| { &mut m.paytype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::UserData::UserSnapshot>(
            "param",
            |m: &SceneRenewReq| { &m.param },
            |m: &mut SceneRenewReq| { &mut m.param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneRenewReq>(
            "SceneRenewReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneRenewReq {
    const NAME: &'static str = "SceneRenewReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.point)?;
                },
                16 => {
                    self.day = is.read_int32()?;
                },
                24 => {
                    self.paytype = is.read_int32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.param)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.point.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.day != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.day);
        }
        if self.paytype != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.paytype);
        }
        if let Some(v) = self.param.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.point.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.day != 0 {
            os.write_int32(2, self.day)?;
        }
        if self.paytype != 0 {
            os.write_int32(3, self.paytype)?;
        }
        if let Some(v) = self.param.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneRenewReq {
        SceneRenewReq::new()
    }

    fn clear(&mut self) {
        self.point.clear();
        self.day = 0;
        self.paytype = 0;
        self.param.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneRenewReq {
        static instance: SceneRenewReq = SceneRenewReq {
            point: ::protobuf::MessageField::none(),
            day: 0,
            paytype: 0,
            param: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneRenewReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneRenewReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneRenewReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneRenewReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SceneRenewRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneRenewRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SceneRenewRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.SceneRenewRsp.info)
    pub info: ::protobuf::MessageField<MapInfoDetail>,
    // @@protoc_insertion_point(field:pbdef.SceneRenewRsp.map_info)
    pub map_info: ::protobuf::MessageField<MapInfo>,
    // @@protoc_insertion_point(field:pbdef.SceneRenewRsp.param)
    pub param: ::protobuf::MessageField<CostParam>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SceneRenewRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneRenewRsp {
    fn default() -> &'a SceneRenewRsp {
        <SceneRenewRsp as ::protobuf::Message>::default_instance()
    }
}

impl SceneRenewRsp {
    pub fn new() -> SceneRenewRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &SceneRenewRsp| { &m.ret },
            |m: &mut SceneRenewRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapInfoDetail>(
            "info",
            |m: &SceneRenewRsp| { &m.info },
            |m: &mut SceneRenewRsp| { &mut m.info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, MapInfo>(
            "map_info",
            |m: &SceneRenewRsp| { &m.map_info },
            |m: &mut SceneRenewRsp| { &mut m.map_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CostParam>(
            "param",
            |m: &SceneRenewRsp| { &m.param },
            |m: &mut SceneRenewRsp| { &mut m.param },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneRenewRsp>(
            "SceneRenewRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneRenewRsp {
    const NAME: &'static str = "SceneRenewRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.info)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.map_info)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.param)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if let Some(v) = self.info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.param.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if let Some(v) = self.info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.map_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.param.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneRenewRsp {
        SceneRenewRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.info.clear();
        self.map_info.clear();
        self.param.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneRenewRsp {
        static instance: SceneRenewRsp = SceneRenewRsp {
            ret: 0,
            info: ::protobuf::MessageField::none(),
            map_info: ::protobuf::MessageField::none(),
            param: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneRenewRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneRenewRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneRenewRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneRenewRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ChooseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChooseItem {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ChooseItem.showName)
    pub showName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ChooseItem.key)
    pub key: i32,
    // @@protoc_insertion_point(field:pbdef.ChooseItem.sub)
    pub sub: ::std::vec::Vec<ChooseItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ChooseItem.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChooseItem {
    fn default() -> &'a ChooseItem {
        <ChooseItem as ::protobuf::Message>::default_instance()
    }
}

impl ChooseItem {
    pub fn new() -> ChooseItem {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "showName",
            |m: &ChooseItem| { &m.showName },
            |m: &mut ChooseItem| { &mut m.showName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ChooseItem| { &m.key },
            |m: &mut ChooseItem| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sub",
            |m: &ChooseItem| { &m.sub },
            |m: &mut ChooseItem| { &mut m.sub },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChooseItem>(
            "ChooseItem",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChooseItem {
    const NAME: &'static str = "ChooseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.showName = is.read_string()?;
                },
                16 => {
                    self.key = is.read_int32()?;
                },
                26 => {
                    self.sub.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.showName.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.showName);
        }
        if self.key != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.key);
        }
        for value in &self.sub {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.showName.is_empty() {
            os.write_string(1, &self.showName)?;
        }
        if self.key != 0 {
            os.write_int32(2, self.key)?;
        }
        for v in &self.sub {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChooseItem {
        ChooseItem::new()
    }

    fn clear(&mut self) {
        self.showName.clear();
        self.key = 0;
        self.sub.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChooseItem {
        static instance: ChooseItem = ChooseItem {
            showName: ::std::string::String::new(),
            key: 0,
            sub: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChooseItem {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChooseItem").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChooseItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChooseItem {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SceneChooseListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneChooseListReq {
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SceneChooseListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneChooseListReq {
    fn default() -> &'a SceneChooseListReq {
        <SceneChooseListReq as ::protobuf::Message>::default_instance()
    }
}

impl SceneChooseListReq {
    pub fn new() -> SceneChooseListReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneChooseListReq>(
            "SceneChooseListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneChooseListReq {
    const NAME: &'static str = "SceneChooseListReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneChooseListReq {
        SceneChooseListReq::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneChooseListReq {
        static instance: SceneChooseListReq = SceneChooseListReq {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneChooseListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneChooseListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneChooseListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneChooseListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.SceneChooseListRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SceneChooseListRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.SceneChooseListRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.SceneChooseListRsp.items)
    pub items: ::std::vec::Vec<ChooseItem>,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.SceneChooseListRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SceneChooseListRsp {
    fn default() -> &'a SceneChooseListRsp {
        <SceneChooseListRsp as ::protobuf::Message>::default_instance()
    }
}

impl SceneChooseListRsp {
    pub fn new() -> SceneChooseListRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &SceneChooseListRsp| { &m.ret },
            |m: &mut SceneChooseListRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "items",
            |m: &SceneChooseListRsp| { &m.items },
            |m: &mut SceneChooseListRsp| { &mut m.items },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SceneChooseListRsp>(
            "SceneChooseListRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SceneChooseListRsp {
    const NAME: &'static str = "SceneChooseListRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                18 => {
                    self.items.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        for v in &self.items {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SceneChooseListRsp {
        SceneChooseListRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SceneChooseListRsp {
        static instance: SceneChooseListRsp = SceneChooseListRsp {
            ret: 0,
            items: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SceneChooseListRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SceneChooseListRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SceneChooseListRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SceneChooseListRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.EnterSceneReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnterSceneReq {
    // message fields
    // @@protoc_insertion_point(field:pbdef.EnterSceneReq.id)
    pub id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.EnterSceneReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnterSceneReq {
    fn default() -> &'a EnterSceneReq {
        <EnterSceneReq as ::protobuf::Message>::default_instance()
    }
}

impl EnterSceneReq {
    pub fn new() -> EnterSceneReq {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &EnterSceneReq| { &m.id },
            |m: &mut EnterSceneReq| { &mut m.id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnterSceneReq>(
            "EnterSceneReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnterSceneReq {
    const NAME: &'static str = "EnterSceneReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnterSceneReq {
        EnterSceneReq::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnterSceneReq {
        static instance: EnterSceneReq = EnterSceneReq {
            id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnterSceneReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnterSceneReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnterSceneReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnterSceneReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.EnterSceneRsp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnterSceneRsp {
    // message fields
    // @@protoc_insertion_point(field:pbdef.EnterSceneRsp.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.EnterSceneRsp.is_enter)
    pub is_enter: bool,
    // @@protoc_insertion_point(field:pbdef.EnterSceneRsp.landname)
    pub landname: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.EnterSceneRsp.str_id)
    pub str_id: i32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.EnterSceneRsp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnterSceneRsp {
    fn default() -> &'a EnterSceneRsp {
        <EnterSceneRsp as ::protobuf::Message>::default_instance()
    }
}

impl EnterSceneRsp {
    pub fn new() -> EnterSceneRsp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &EnterSceneRsp| { &m.ret },
            |m: &mut EnterSceneRsp| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_enter",
            |m: &EnterSceneRsp| { &m.is_enter },
            |m: &mut EnterSceneRsp| { &mut m.is_enter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "landname",
            |m: &EnterSceneRsp| { &m.landname },
            |m: &mut EnterSceneRsp| { &mut m.landname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "str_id",
            |m: &EnterSceneRsp| { &m.str_id },
            |m: &mut EnterSceneRsp| { &mut m.str_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EnterSceneRsp>(
            "EnterSceneRsp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EnterSceneRsp {
    const NAME: &'static str = "EnterSceneRsp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                16 => {
                    self.is_enter = is.read_bool()?;
                },
                26 => {
                    self.landname = is.read_string()?;
                },
                32 => {
                    self.str_id = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if self.is_enter != false {
            my_size += 1 + 1;
        }
        if !self.landname.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.landname);
        }
        if self.str_id != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.str_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if self.is_enter != false {
            os.write_bool(2, self.is_enter)?;
        }
        if !self.landname.is_empty() {
            os.write_string(3, &self.landname)?;
        }
        if self.str_id != 0 {
            os.write_int32(4, self.str_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnterSceneRsp {
        EnterSceneRsp::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.is_enter = false;
        self.landname.clear();
        self.str_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnterSceneRsp {
        static instance: EnterSceneRsp = EnterSceneRsp {
            ret: 0,
            is_enter: false,
            landname: ::std::string::String::new(),
            str_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EnterSceneRsp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnterSceneRsp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnterSceneRsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnterSceneRsp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rLoadMap.proto\x12\x05pbdef\x1a\x10BaseDefine.proto\x1a\x0eUserData.p\
    rotoP\0P\x01\"&\n\x08MapPoint\x12\x0c\n\x01x\x18\x01\x20\x01(\x05R\x01x\
    \x12\x0c\n\x01y\x18\x02\x20\x01(\x05R\x01y\"\xa6\x02\n\x07MapInfo\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x10\n\x03pid\x18\x02\x20\
    \x01(\x05R\x03pid\x12\x16\n\x06daxiao\x18\x03\x20\x01(\tR\x06daxiao\x12\
    \x0c\n\x01x\x18\x04\x20\x01(\x05R\x01x\x12\x0c\n\x01y\x18\x05\x20\x01(\
    \x05R\x01y\x12\x17\n\x07user_id\x18\x06\x20\x01(\x04R\x06userId\x12\x10\
    \n\x03url\x18\x07\x20\x01(\tR\x03url\x12\x12\n\x04url1\x18\x08\x20\x01(\
    \tR\x04url1\x12\x18\n\x07forwork\x18\t\x20\x01(\x05R\x07forwork\x12\x1f\
    \n\x0bpublic_flag\x18\n\x20\x01(\x05R\npublicFlag\x12\x1f\n\x0bpublic_na\
    me\x18\x0b\x20\x01(\tR\npublicName\x12\x12\n\x04open\x18\x0c\x20\x01(\
    \x05R\x04open\x12\x16\n\x06canbuy\x18\r\x20\x01(\x05R\x06canbuy\"!\n\tCo\
    stParam\x12\x14\n\x05JiFen\x18\x01\x20\x01(\x02R\x05JiFen\"\xfe\x02\n\rM\
    apInfoDetail\x12\x14\n\x05enter\x18\x01\x20\x01(\x05R\x05enter\x12\x16\n\
    \x06weburl\x18\x02\x20\x01(\tR\x06weburl\x12\x14\n\x05price\x18\x03\x20\
    \x01(\tR\x05price\x12\x16\n\x06canbuy\x18\x04\x20\x01(\x05R\x06canbuy\
    \x12\x18\n\x07buytime\x18\x05\x20\x01(\x03R\x07buytime\x12\x1e\n\nexpire\
    time\x18\x06\x20\x01(\x03R\nexpiretime\x12\x1a\n\x08nickname\x18\x07\x20\
    \x01(\tR\x08nickname\x12\x1a\n\x08landname\x18\x08\x20\x01(\tR\x08landna\
    me\x12\x1e\n\npriceJiFen\x18\t\x20\x01(\tR\npriceJiFen\x12\x12\n\x04edit\
    \x18\n\x20\x01(\x08R\x04edit\x12\x1f\n\x0bpublic_flag\x18\x0b\x20\x01(\
    \x05R\npublicFlag\x12\x18\n\x07jianjie\x18\x0c\x20\x01(\tR\x07jianjie\
    \x12\x0e\n\x02id\x18\r\x20\x01(\x05R\x02id\x12\x20\n\x0ccan_be_enter\x18\
    \x0e\x20\x01(\x08R\ncanBeEnter\"\\\n\nLoadMapReq\x12\x14\n\x05fromx\x18\
    \x01\x20\x01(\x05R\x05fromx\x12\x14\n\x05fromy\x18\x02\x20\x01(\x05R\x05\
    fromy\x12\x10\n\x03tox\x18\x03\x20\x01(\x05R\x03tox\x12\x10\n\x03toy\x18\
    \x04\x20\x01(\x05R\x03toy\"D\n\nLoadMapRsp\x12\x10\n\x03ret\x18\x01\x20\
    \x01(\x05R\x03ret\x12$\n\x05infos\x18\x02\x20\x03(\x0b2\x0e.pbdef.MapInf\
    oR\x05infos\"\x8b\x01\n\x0bBuySceneReq\x12%\n\x05point\x18\x01\x20\x01(\
    \x0b2\x0f.pbdef.MapPointR\x05point\x12\x10\n\x03day\x18\x02\x20\x01(\x05\
    R\x03day\x12\x18\n\x07paytype\x18\x03\x20\x01(\x05R\x07paytype\x12)\n\
    \x05param\x18\x04\x20\x01(\x0b2\x13.pbdef.UserSnapshotR\x05param\"\xd8\
    \x01\n\x0bBuySceneRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\
    \x1f\n\x0bwait_second\x18\x02\x20\x01(\x05R\nwaitSecond\x12\x19\n\x08ord\
    er_no\x18\x03\x20\x01(\tR\x07orderNo\x12(\n\x04info\x18\x04\x20\x01(\x0b\
    2\x14.pbdef.MapInfoDetailR\x04info\x12)\n\x08map_info\x18\x05\x20\x01(\
    \x0b2\x0e.pbdef.MapInfoR\x07mapInfo\x12&\n\x05param\x18\x06\x20\x01(\x0b\
    2\x10.pbdef.CostParamR\x05param\"\xb7\x01\n\x0cEditSceneReq\x12%\n\x05po\
    int\x18\x01\x20\x01(\x0b2\x0f.pbdef.MapPointR\x05point\x12\x18\n\x07jian\
    jie\x18\x02\x20\x01(\tR\x07jianjie\x12\x10\n\x03url\x18\x03\x20\x01(\tR\
    \x03url\x12\x12\n\x04url1\x18\x04\x20\x01(\tR\x04url1\x12\x16\n\x06webur\
    l\x18\x05\x20\x01(\tR\x06weburl\x12\x14\n\x05enter\x18\x06\x20\x01(\x05R\
    \x05enter\x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\"J\n\x0cEditScen\
    eRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12(\n\x04info\x18\
    \x02\x20\x01(\x0b2\x14.pbdef.MapInfoDetailR\x04info\"&\n\x0eChooseSceneR\
    eq\x12\x14\n\x05ctype\x18\x01\x20\x01(\x05R\x05ctype\"H\n\x0eChooseScene\
    Rsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12$\n\x05infos\x18\
    \x02\x20\x03(\x0b2\x0e.pbdef.MapInfoR\x05infos\"7\n\x0eSceneDetailReq\
    \x12%\n\x05point\x18\x01\x20\x01(\x0b2\x0f.pbdef.MapPointR\x05point\"L\n\
    \x0eSceneDetailRsp\x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12(\n\
    \x04info\x18\x02\x20\x01(\x0b2\x14.pbdef.MapInfoDetailR\x04info\"\x8d\
    \x01\n\rSceneRenewReq\x12%\n\x05point\x18\x01\x20\x01(\x0b2\x0f.pbdef.Ma\
    pPointR\x05point\x12\x10\n\x03day\x18\x02\x20\x01(\x05R\x03day\x12\x18\n\
    \x07paytype\x18\x03\x20\x01(\x05R\x07paytype\x12)\n\x05param\x18\x04\x20\
    \x01(\x0b2\x13.pbdef.UserSnapshotR\x05param\"\x9e\x01\n\rSceneRenewRsp\
    \x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12(\n\x04info\x18\x02\
    \x20\x01(\x0b2\x14.pbdef.MapInfoDetailR\x04info\x12)\n\x08map_info\x18\
    \x03\x20\x01(\x0b2\x0e.pbdef.MapInfoR\x07mapInfo\x12&\n\x05param\x18\x04\
    \x20\x01(\x0b2\x10.pbdef.CostParamR\x05param\"_\n\nChooseItem\x12\x1a\n\
    \x08showName\x18\x01\x20\x01(\tR\x08showName\x12\x10\n\x03key\x18\x02\
    \x20\x01(\x05R\x03key\x12#\n\x03sub\x18\x03\x20\x03(\x0b2\x11.pbdef.Choo\
    seItemR\x03sub\"\x14\n\x12SceneChooseListReq\"O\n\x12SceneChooseListRsp\
    \x12\x10\n\x03ret\x18\x01\x20\x01(\x05R\x03ret\x12'\n\x05items\x18\x02\
    \x20\x03(\x0b2\x11.pbdef.ChooseItemR\x05items\"\x1f\n\rEnterSceneReq\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\"o\n\rEnterSceneRsp\x12\x10\n\
    \x03ret\x18\x01\x20\x01(\x05R\x03ret\x12\x19\n\x08is_enter\x18\x02\x20\
    \x01(\x08R\x07isEnter\x12\x1a\n\x08landname\x18\x03\x20\x01(\tR\x08landn\
    ame\x12\x15\n\x06str_id\x18\x04\x20\x01(\x05R\x05strIdb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(2);
            deps.push(super::BaseDefine::file_descriptor().clone());
            deps.push(super::UserData::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(21);
            messages.push(MapPoint::generated_message_descriptor_data());
            messages.push(MapInfo::generated_message_descriptor_data());
            messages.push(CostParam::generated_message_descriptor_data());
            messages.push(MapInfoDetail::generated_message_descriptor_data());
            messages.push(LoadMapReq::generated_message_descriptor_data());
            messages.push(LoadMapRsp::generated_message_descriptor_data());
            messages.push(BuySceneReq::generated_message_descriptor_data());
            messages.push(BuySceneRsp::generated_message_descriptor_data());
            messages.push(EditSceneReq::generated_message_descriptor_data());
            messages.push(EditSceneRsp::generated_message_descriptor_data());
            messages.push(ChooseSceneReq::generated_message_descriptor_data());
            messages.push(ChooseSceneRsp::generated_message_descriptor_data());
            messages.push(SceneDetailReq::generated_message_descriptor_data());
            messages.push(SceneDetailRsp::generated_message_descriptor_data());
            messages.push(SceneRenewReq::generated_message_descriptor_data());
            messages.push(SceneRenewRsp::generated_message_descriptor_data());
            messages.push(ChooseItem::generated_message_descriptor_data());
            messages.push(SceneChooseListReq::generated_message_descriptor_data());
            messages.push(SceneChooseListRsp::generated_message_descriptor_data());
            messages.push(EnterSceneReq::generated_message_descriptor_data());
            messages.push(EnterSceneRsp::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
