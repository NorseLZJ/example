// This file is generated by rust-protobuf 3.3.0. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `UserData.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_3_0;

// @@protoc_insertion_point(message:pbdef.LoginPlatformData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LoginPlatformData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.LoginPlatformData.uid)
    pub uid: u64,
    // @@protoc_insertion_point(field:pbdef.LoginPlatformData.acount)
    pub acount: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.LoginPlatformData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LoginPlatformData {
    fn default() -> &'a LoginPlatformData {
        <LoginPlatformData as ::protobuf::Message>::default_instance()
    }
}

impl LoginPlatformData {
    pub fn new() -> LoginPlatformData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &LoginPlatformData| { &m.uid },
            |m: &mut LoginPlatformData| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "acount",
            |m: &LoginPlatformData| { &m.acount },
            |m: &mut LoginPlatformData| { &mut m.acount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LoginPlatformData>(
            "LoginPlatformData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LoginPlatformData {
    const NAME: &'static str = "LoginPlatformData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uid = is.read_uint64()?;
                },
                18 => {
                    self.acount = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.uid);
        }
        if !self.acount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.acount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.uid != 0 {
            os.write_uint64(1, self.uid)?;
        }
        if !self.acount.is_empty() {
            os.write_string(2, &self.acount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LoginPlatformData {
        LoginPlatformData::new()
    }

    fn clear(&mut self) {
        self.uid = 0;
        self.acount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LoginPlatformData {
        static instance: LoginPlatformData = LoginPlatformData {
            uid: 0,
            acount: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LoginPlatformData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LoginPlatformData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LoginPlatformData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoginPlatformData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserSnapshot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserSnapshot {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.user_id)
    pub user_id: u64,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.PhoneNumber)
    pub PhoneNumber: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.HeadPrtraits)
    pub HeadPrtraits: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.NickName)
    pub NickName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.StatusId)
    pub StatusId: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.Money)
    pub Money: f32,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.Email)
    pub Email: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.mapShops)
    pub mapShops: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.balance)
    pub balance: f32,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.autograph)
    pub autograph: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.realnametype)
    pub realnametype: i32,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.sis_cur_svrid)
    pub sis_cur_svrid: u32,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.php_uid)
    pub php_uid: i32,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.accessToken)
    pub accessToken: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.token_expire)
    pub token_expire: u32,
    // @@protoc_insertion_point(field:pbdef.UserSnapshot.login_acount)
    pub login_acount: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserSnapshot.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserSnapshot {
    fn default() -> &'a UserSnapshot {
        <UserSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl UserSnapshot {
    pub fn new() -> UserSnapshot {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_id",
            |m: &UserSnapshot| { &m.user_id },
            |m: &mut UserSnapshot| { &mut m.user_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "PhoneNumber",
            |m: &UserSnapshot| { &m.PhoneNumber },
            |m: &mut UserSnapshot| { &mut m.PhoneNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "HeadPrtraits",
            |m: &UserSnapshot| { &m.HeadPrtraits },
            |m: &mut UserSnapshot| { &mut m.HeadPrtraits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "NickName",
            |m: &UserSnapshot| { &m.NickName },
            |m: &mut UserSnapshot| { &mut m.NickName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "StatusId",
            |m: &UserSnapshot| { &m.StatusId },
            |m: &mut UserSnapshot| { &mut m.StatusId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Money",
            |m: &UserSnapshot| { &m.Money },
            |m: &mut UserSnapshot| { &mut m.Money },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Email",
            |m: &UserSnapshot| { &m.Email },
            |m: &mut UserSnapshot| { &mut m.Email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mapShops",
            |m: &UserSnapshot| { &m.mapShops },
            |m: &mut UserSnapshot| { &mut m.mapShops },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "balance",
            |m: &UserSnapshot| { &m.balance },
            |m: &mut UserSnapshot| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "autograph",
            |m: &UserSnapshot| { &m.autograph },
            |m: &mut UserSnapshot| { &mut m.autograph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realnametype",
            |m: &UserSnapshot| { &m.realnametype },
            |m: &mut UserSnapshot| { &mut m.realnametype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sis_cur_svrid",
            |m: &UserSnapshot| { &m.sis_cur_svrid },
            |m: &mut UserSnapshot| { &mut m.sis_cur_svrid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "php_uid",
            |m: &UserSnapshot| { &m.php_uid },
            |m: &mut UserSnapshot| { &mut m.php_uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accessToken",
            |m: &UserSnapshot| { &m.accessToken },
            |m: &mut UserSnapshot| { &mut m.accessToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "token_expire",
            |m: &UserSnapshot| { &m.token_expire },
            |m: &mut UserSnapshot| { &mut m.token_expire },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "login_acount",
            |m: &UserSnapshot| { &m.login_acount },
            |m: &mut UserSnapshot| { &mut m.login_acount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserSnapshot>(
            "UserSnapshot",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserSnapshot {
    const NAME: &'static str = "UserSnapshot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_id = is.read_uint64()?;
                },
                18 => {
                    self.PhoneNumber = is.read_string()?;
                },
                26 => {
                    self.HeadPrtraits = is.read_string()?;
                },
                34 => {
                    self.NickName = is.read_string()?;
                },
                42 => {
                    self.StatusId = is.read_string()?;
                },
                53 => {
                    self.Money = is.read_float()?;
                },
                58 => {
                    self.Email = is.read_string()?;
                },
                66 => {
                    self.mapShops = is.read_string()?;
                },
                77 => {
                    self.balance = is.read_float()?;
                },
                122 => {
                    self.autograph = is.read_string()?;
                },
                128 => {
                    self.realnametype = is.read_int32()?;
                },
                80 => {
                    self.sis_cur_svrid = is.read_uint32()?;
                },
                88 => {
                    self.php_uid = is.read_int32()?;
                },
                98 => {
                    self.accessToken = is.read_string()?;
                },
                104 => {
                    self.token_expire = is.read_uint32()?;
                },
                114 => {
                    self.login_acount = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.user_id != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.user_id);
        }
        if !self.PhoneNumber.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.PhoneNumber);
        }
        if !self.HeadPrtraits.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.HeadPrtraits);
        }
        if !self.NickName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.NickName);
        }
        if !self.StatusId.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.StatusId);
        }
        if self.Money != 0. {
            my_size += 1 + 4;
        }
        if !self.Email.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.Email);
        }
        if !self.mapShops.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.mapShops);
        }
        if self.balance != 0. {
            my_size += 1 + 4;
        }
        if !self.autograph.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.autograph);
        }
        if self.realnametype != 0 {
            my_size += ::protobuf::rt::int32_size(16, self.realnametype);
        }
        if self.sis_cur_svrid != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.sis_cur_svrid);
        }
        if self.php_uid != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.php_uid);
        }
        if !self.accessToken.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.accessToken);
        }
        if self.token_expire != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.token_expire);
        }
        if !self.login_acount.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.login_acount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.user_id != 0 {
            os.write_uint64(1, self.user_id)?;
        }
        if !self.PhoneNumber.is_empty() {
            os.write_string(2, &self.PhoneNumber)?;
        }
        if !self.HeadPrtraits.is_empty() {
            os.write_string(3, &self.HeadPrtraits)?;
        }
        if !self.NickName.is_empty() {
            os.write_string(4, &self.NickName)?;
        }
        if !self.StatusId.is_empty() {
            os.write_string(5, &self.StatusId)?;
        }
        if self.Money != 0. {
            os.write_float(6, self.Money)?;
        }
        if !self.Email.is_empty() {
            os.write_string(7, &self.Email)?;
        }
        if !self.mapShops.is_empty() {
            os.write_string(8, &self.mapShops)?;
        }
        if self.balance != 0. {
            os.write_float(9, self.balance)?;
        }
        if !self.autograph.is_empty() {
            os.write_string(15, &self.autograph)?;
        }
        if self.realnametype != 0 {
            os.write_int32(16, self.realnametype)?;
        }
        if self.sis_cur_svrid != 0 {
            os.write_uint32(10, self.sis_cur_svrid)?;
        }
        if self.php_uid != 0 {
            os.write_int32(11, self.php_uid)?;
        }
        if !self.accessToken.is_empty() {
            os.write_string(12, &self.accessToken)?;
        }
        if self.token_expire != 0 {
            os.write_uint32(13, self.token_expire)?;
        }
        if !self.login_acount.is_empty() {
            os.write_string(14, &self.login_acount)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserSnapshot {
        UserSnapshot::new()
    }

    fn clear(&mut self) {
        self.user_id = 0;
        self.PhoneNumber.clear();
        self.HeadPrtraits.clear();
        self.NickName.clear();
        self.StatusId.clear();
        self.Money = 0.;
        self.Email.clear();
        self.mapShops.clear();
        self.balance = 0.;
        self.autograph.clear();
        self.realnametype = 0;
        self.sis_cur_svrid = 0;
        self.php_uid = 0;
        self.accessToken.clear();
        self.token_expire = 0;
        self.login_acount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserSnapshot {
        static instance: UserSnapshot = UserSnapshot {
            user_id: 0,
            PhoneNumber: ::std::string::String::new(),
            HeadPrtraits: ::std::string::String::new(),
            NickName: ::std::string::String::new(),
            StatusId: ::std::string::String::new(),
            Money: 0.,
            Email: ::std::string::String::new(),
            mapShops: ::std::string::String::new(),
            balance: 0.,
            autograph: ::std::string::String::new(),
            realnametype: 0,
            sis_cur_svrid: 0,
            php_uid: 0,
            accessToken: ::std::string::String::new(),
            token_expire: 0,
            login_acount: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserSnapshot {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserSnapshot").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserSnapshot {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.UserAllData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UserAllData {
    // message fields
    // @@protoc_insertion_point(field:pbdef.UserAllData.userId)
    pub userId: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.phoneNumber)
    pub phoneNumber: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.mailbox)
    pub mailbox: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.headPrtraits)
    pub headPrtraits: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.nickName)
    pub nickName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.passwd)
    pub passwd: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.tradePassWord)
    pub tradePassWord: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.autograph)
    pub autograph: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.balance)
    pub balance: f32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.alipay)
    pub alipay: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.alipayname)
    pub alipayname: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.realnametype)
    pub realnametype: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.createTime)
    pub createTime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.statusId)
    pub statusId: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.address)
    pub address: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.privatekey)
    pub privatekey: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.whitelist)
    pub whitelist: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.realname)
    pub realname: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.realno)
    pub realno: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.invitationId)
    pub invitationId: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.invitationcount)
    pub invitationcount: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.szcount)
    pub szcount: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.sztime)
    pub sztime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.iscreater)
    pub iscreater: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.money)
    pub money: f32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.email)
    pub email: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.invitationCode)
    pub invitationCode: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.lotterytimes)
    pub lotterytimes: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.buycard)
    pub buycard: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.ustype)
    pub ustype: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.tudicard)
    pub tudicard: i32,
    // @@protoc_insertion_point(field:pbdef.UserAllData.updateTime)
    pub updateTime: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.UserAllData.mapShops)
    pub mapShops: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.UserAllData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UserAllData {
    fn default() -> &'a UserAllData {
        <UserAllData as ::protobuf::Message>::default_instance()
    }
}

impl UserAllData {
    pub fn new() -> UserAllData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(33);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "userId",
            |m: &UserAllData| { &m.userId },
            |m: &mut UserAllData| { &mut m.userId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "phoneNumber",
            |m: &UserAllData| { &m.phoneNumber },
            |m: &mut UserAllData| { &mut m.phoneNumber },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mailbox",
            |m: &UserAllData| { &m.mailbox },
            |m: &mut UserAllData| { &mut m.mailbox },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "headPrtraits",
            |m: &UserAllData| { &m.headPrtraits },
            |m: &mut UserAllData| { &mut m.headPrtraits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "nickName",
            |m: &UserAllData| { &m.nickName },
            |m: &mut UserAllData| { &mut m.nickName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "passwd",
            |m: &UserAllData| { &m.passwd },
            |m: &mut UserAllData| { &mut m.passwd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tradePassWord",
            |m: &UserAllData| { &m.tradePassWord },
            |m: &mut UserAllData| { &mut m.tradePassWord },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "autograph",
            |m: &UserAllData| { &m.autograph },
            |m: &mut UserAllData| { &mut m.autograph },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "balance",
            |m: &UserAllData| { &m.balance },
            |m: &mut UserAllData| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alipay",
            |m: &UserAllData| { &m.alipay },
            |m: &mut UserAllData| { &mut m.alipay },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "alipayname",
            |m: &UserAllData| { &m.alipayname },
            |m: &mut UserAllData| { &mut m.alipayname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realnametype",
            |m: &UserAllData| { &m.realnametype },
            |m: &mut UserAllData| { &mut m.realnametype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "createTime",
            |m: &UserAllData| { &m.createTime },
            |m: &mut UserAllData| { &mut m.createTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "statusId",
            |m: &UserAllData| { &m.statusId },
            |m: &mut UserAllData| { &mut m.statusId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &UserAllData| { &m.address },
            |m: &mut UserAllData| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "privatekey",
            |m: &UserAllData| { &m.privatekey },
            |m: &mut UserAllData| { &mut m.privatekey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "whitelist",
            |m: &UserAllData| { &m.whitelist },
            |m: &mut UserAllData| { &mut m.whitelist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realname",
            |m: &UserAllData| { &m.realname },
            |m: &mut UserAllData| { &mut m.realname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "realno",
            |m: &UserAllData| { &m.realno },
            |m: &mut UserAllData| { &mut m.realno },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invitationId",
            |m: &UserAllData| { &m.invitationId },
            |m: &mut UserAllData| { &mut m.invitationId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invitationcount",
            |m: &UserAllData| { &m.invitationcount },
            |m: &mut UserAllData| { &mut m.invitationcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "szcount",
            |m: &UserAllData| { &m.szcount },
            |m: &mut UserAllData| { &mut m.szcount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sztime",
            |m: &UserAllData| { &m.sztime },
            |m: &mut UserAllData| { &mut m.sztime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "iscreater",
            |m: &UserAllData| { &m.iscreater },
            |m: &mut UserAllData| { &mut m.iscreater },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "money",
            |m: &UserAllData| { &m.money },
            |m: &mut UserAllData| { &mut m.money },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "email",
            |m: &UserAllData| { &m.email },
            |m: &mut UserAllData| { &mut m.email },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invitationCode",
            |m: &UserAllData| { &m.invitationCode },
            |m: &mut UserAllData| { &mut m.invitationCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "lotterytimes",
            |m: &UserAllData| { &m.lotterytimes },
            |m: &mut UserAllData| { &mut m.lotterytimes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "buycard",
            |m: &UserAllData| { &m.buycard },
            |m: &mut UserAllData| { &mut m.buycard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ustype",
            |m: &UserAllData| { &m.ustype },
            |m: &mut UserAllData| { &mut m.ustype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tudicard",
            |m: &UserAllData| { &m.tudicard },
            |m: &mut UserAllData| { &mut m.tudicard },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "updateTime",
            |m: &UserAllData| { &m.updateTime },
            |m: &mut UserAllData| { &mut m.updateTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mapShops",
            |m: &UserAllData| { &m.mapShops },
            |m: &mut UserAllData| { &mut m.mapShops },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UserAllData>(
            "UserAllData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UserAllData {
    const NAME: &'static str = "UserAllData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = is.read_int32()?;
                },
                18 => {
                    self.phoneNumber = is.read_string()?;
                },
                26 => {
                    self.mailbox = is.read_string()?;
                },
                34 => {
                    self.headPrtraits = is.read_string()?;
                },
                42 => {
                    self.nickName = is.read_string()?;
                },
                50 => {
                    self.passwd = is.read_string()?;
                },
                58 => {
                    self.tradePassWord = is.read_string()?;
                },
                66 => {
                    self.autograph = is.read_string()?;
                },
                77 => {
                    self.balance = is.read_float()?;
                },
                82 => {
                    self.alipay = is.read_string()?;
                },
                90 => {
                    self.alipayname = is.read_string()?;
                },
                96 => {
                    self.realnametype = is.read_int32()?;
                },
                106 => {
                    self.createTime = is.read_string()?;
                },
                114 => {
                    self.statusId = is.read_string()?;
                },
                122 => {
                    self.address = is.read_string()?;
                },
                130 => {
                    self.privatekey = is.read_string()?;
                },
                136 => {
                    self.whitelist = is.read_int32()?;
                },
                146 => {
                    self.realname = is.read_string()?;
                },
                154 => {
                    self.realno = is.read_string()?;
                },
                160 => {
                    self.invitationId = is.read_int32()?;
                },
                168 => {
                    self.invitationcount = is.read_int32()?;
                },
                176 => {
                    self.szcount = is.read_int32()?;
                },
                186 => {
                    self.sztime = is.read_string()?;
                },
                192 => {
                    self.iscreater = is.read_int32()?;
                },
                205 => {
                    self.money = is.read_float()?;
                },
                210 => {
                    self.email = is.read_string()?;
                },
                218 => {
                    self.invitationCode = is.read_string()?;
                },
                224 => {
                    self.lotterytimes = is.read_int32()?;
                },
                232 => {
                    self.buycard = is.read_int32()?;
                },
                240 => {
                    self.ustype = is.read_int32()?;
                },
                248 => {
                    self.tudicard = is.read_int32()?;
                },
                258 => {
                    self.updateTime = is.read_string()?;
                },
                266 => {
                    self.mapShops = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.userId != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.userId);
        }
        if !self.phoneNumber.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.phoneNumber);
        }
        if !self.mailbox.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mailbox);
        }
        if !self.headPrtraits.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.headPrtraits);
        }
        if !self.nickName.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.nickName);
        }
        if !self.passwd.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.passwd);
        }
        if !self.tradePassWord.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.tradePassWord);
        }
        if !self.autograph.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.autograph);
        }
        if self.balance != 0. {
            my_size += 1 + 4;
        }
        if !self.alipay.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.alipay);
        }
        if !self.alipayname.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.alipayname);
        }
        if self.realnametype != 0 {
            my_size += ::protobuf::rt::int32_size(12, self.realnametype);
        }
        if !self.createTime.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.createTime);
        }
        if !self.statusId.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.statusId);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.address);
        }
        if !self.privatekey.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.privatekey);
        }
        if self.whitelist != 0 {
            my_size += ::protobuf::rt::int32_size(17, self.whitelist);
        }
        if !self.realname.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.realname);
        }
        if !self.realno.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.realno);
        }
        if self.invitationId != 0 {
            my_size += ::protobuf::rt::int32_size(20, self.invitationId);
        }
        if self.invitationcount != 0 {
            my_size += ::protobuf::rt::int32_size(21, self.invitationcount);
        }
        if self.szcount != 0 {
            my_size += ::protobuf::rt::int32_size(22, self.szcount);
        }
        if !self.sztime.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.sztime);
        }
        if self.iscreater != 0 {
            my_size += ::protobuf::rt::int32_size(24, self.iscreater);
        }
        if self.money != 0. {
            my_size += 2 + 4;
        }
        if !self.email.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.email);
        }
        if !self.invitationCode.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.invitationCode);
        }
        if self.lotterytimes != 0 {
            my_size += ::protobuf::rt::int32_size(28, self.lotterytimes);
        }
        if self.buycard != 0 {
            my_size += ::protobuf::rt::int32_size(29, self.buycard);
        }
        if self.ustype != 0 {
            my_size += ::protobuf::rt::int32_size(30, self.ustype);
        }
        if self.tudicard != 0 {
            my_size += ::protobuf::rt::int32_size(31, self.tudicard);
        }
        if !self.updateTime.is_empty() {
            my_size += ::protobuf::rt::string_size(32, &self.updateTime);
        }
        if !self.mapShops.is_empty() {
            my_size += ::protobuf::rt::string_size(33, &self.mapShops);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.userId != 0 {
            os.write_int32(1, self.userId)?;
        }
        if !self.phoneNumber.is_empty() {
            os.write_string(2, &self.phoneNumber)?;
        }
        if !self.mailbox.is_empty() {
            os.write_string(3, &self.mailbox)?;
        }
        if !self.headPrtraits.is_empty() {
            os.write_string(4, &self.headPrtraits)?;
        }
        if !self.nickName.is_empty() {
            os.write_string(5, &self.nickName)?;
        }
        if !self.passwd.is_empty() {
            os.write_string(6, &self.passwd)?;
        }
        if !self.tradePassWord.is_empty() {
            os.write_string(7, &self.tradePassWord)?;
        }
        if !self.autograph.is_empty() {
            os.write_string(8, &self.autograph)?;
        }
        if self.balance != 0. {
            os.write_float(9, self.balance)?;
        }
        if !self.alipay.is_empty() {
            os.write_string(10, &self.alipay)?;
        }
        if !self.alipayname.is_empty() {
            os.write_string(11, &self.alipayname)?;
        }
        if self.realnametype != 0 {
            os.write_int32(12, self.realnametype)?;
        }
        if !self.createTime.is_empty() {
            os.write_string(13, &self.createTime)?;
        }
        if !self.statusId.is_empty() {
            os.write_string(14, &self.statusId)?;
        }
        if !self.address.is_empty() {
            os.write_string(15, &self.address)?;
        }
        if !self.privatekey.is_empty() {
            os.write_string(16, &self.privatekey)?;
        }
        if self.whitelist != 0 {
            os.write_int32(17, self.whitelist)?;
        }
        if !self.realname.is_empty() {
            os.write_string(18, &self.realname)?;
        }
        if !self.realno.is_empty() {
            os.write_string(19, &self.realno)?;
        }
        if self.invitationId != 0 {
            os.write_int32(20, self.invitationId)?;
        }
        if self.invitationcount != 0 {
            os.write_int32(21, self.invitationcount)?;
        }
        if self.szcount != 0 {
            os.write_int32(22, self.szcount)?;
        }
        if !self.sztime.is_empty() {
            os.write_string(23, &self.sztime)?;
        }
        if self.iscreater != 0 {
            os.write_int32(24, self.iscreater)?;
        }
        if self.money != 0. {
            os.write_float(25, self.money)?;
        }
        if !self.email.is_empty() {
            os.write_string(26, &self.email)?;
        }
        if !self.invitationCode.is_empty() {
            os.write_string(27, &self.invitationCode)?;
        }
        if self.lotterytimes != 0 {
            os.write_int32(28, self.lotterytimes)?;
        }
        if self.buycard != 0 {
            os.write_int32(29, self.buycard)?;
        }
        if self.ustype != 0 {
            os.write_int32(30, self.ustype)?;
        }
        if self.tudicard != 0 {
            os.write_int32(31, self.tudicard)?;
        }
        if !self.updateTime.is_empty() {
            os.write_string(32, &self.updateTime)?;
        }
        if !self.mapShops.is_empty() {
            os.write_string(33, &self.mapShops)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UserAllData {
        UserAllData::new()
    }

    fn clear(&mut self) {
        self.userId = 0;
        self.phoneNumber.clear();
        self.mailbox.clear();
        self.headPrtraits.clear();
        self.nickName.clear();
        self.passwd.clear();
        self.tradePassWord.clear();
        self.autograph.clear();
        self.balance = 0.;
        self.alipay.clear();
        self.alipayname.clear();
        self.realnametype = 0;
        self.createTime.clear();
        self.statusId.clear();
        self.address.clear();
        self.privatekey.clear();
        self.whitelist = 0;
        self.realname.clear();
        self.realno.clear();
        self.invitationId = 0;
        self.invitationcount = 0;
        self.szcount = 0;
        self.sztime.clear();
        self.iscreater = 0;
        self.money = 0.;
        self.email.clear();
        self.invitationCode.clear();
        self.lotterytimes = 0;
        self.buycard = 0;
        self.ustype = 0;
        self.tudicard = 0;
        self.updateTime.clear();
        self.mapShops.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UserAllData {
        static instance: UserAllData = UserAllData {
            userId: 0,
            phoneNumber: ::std::string::String::new(),
            mailbox: ::std::string::String::new(),
            headPrtraits: ::std::string::String::new(),
            nickName: ::std::string::String::new(),
            passwd: ::std::string::String::new(),
            tradePassWord: ::std::string::String::new(),
            autograph: ::std::string::String::new(),
            balance: 0.,
            alipay: ::std::string::String::new(),
            alipayname: ::std::string::String::new(),
            realnametype: 0,
            createTime: ::std::string::String::new(),
            statusId: ::std::string::String::new(),
            address: ::std::string::String::new(),
            privatekey: ::std::string::String::new(),
            whitelist: 0,
            realname: ::std::string::String::new(),
            realno: ::std::string::String::new(),
            invitationId: 0,
            invitationcount: 0,
            szcount: 0,
            sztime: ::std::string::String::new(),
            iscreater: 0,
            money: 0.,
            email: ::std::string::String::new(),
            invitationCode: ::std::string::String::new(),
            lotterytimes: 0,
            buycard: 0,
            ustype: 0,
            tudicard: 0,
            updateTime: ::std::string::String::new(),
            mapShops: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UserAllData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UserAllData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UserAllData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UserAllData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.ChatMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ChatMessage {
    // message fields
    // @@protoc_insertion_point(field:pbdef.ChatMessage.SenderUid)
    pub SenderUid: u64,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.SenderName)
    pub SenderName: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.SendTime)
    pub SendTime: u64,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.MessageType)
    pub MessageType: u32,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.Message)
    pub Message: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.Head)
    pub Head: ::std::string::String,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.Reciver)
    pub Reciver: u64,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.LastSendTime)
    pub LastSendTime: u64,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.SisId)
    pub SisId: u64,
    // @@protoc_insertion_point(field:pbdef.ChatMessage.Flag)
    pub Flag: u32,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.ChatMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ChatMessage {
    fn default() -> &'a ChatMessage {
        <ChatMessage as ::protobuf::Message>::default_instance()
    }
}

impl ChatMessage {
    pub fn new() -> ChatMessage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SenderUid",
            |m: &ChatMessage| { &m.SenderUid },
            |m: &mut ChatMessage| { &mut m.SenderUid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SenderName",
            |m: &ChatMessage| { &m.SenderName },
            |m: &mut ChatMessage| { &mut m.SenderName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SendTime",
            |m: &ChatMessage| { &m.SendTime },
            |m: &mut ChatMessage| { &mut m.SendTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "MessageType",
            |m: &ChatMessage| { &m.MessageType },
            |m: &mut ChatMessage| { &mut m.MessageType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Message",
            |m: &ChatMessage| { &m.Message },
            |m: &mut ChatMessage| { &mut m.Message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Head",
            |m: &ChatMessage| { &m.Head },
            |m: &mut ChatMessage| { &mut m.Head },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Reciver",
            |m: &ChatMessage| { &m.Reciver },
            |m: &mut ChatMessage| { &mut m.Reciver },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "LastSendTime",
            |m: &ChatMessage| { &m.LastSendTime },
            |m: &mut ChatMessage| { &mut m.LastSendTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "SisId",
            |m: &ChatMessage| { &m.SisId },
            |m: &mut ChatMessage| { &mut m.SisId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "Flag",
            |m: &ChatMessage| { &m.Flag },
            |m: &mut ChatMessage| { &mut m.Flag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ChatMessage>(
            "ChatMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ChatMessage {
    const NAME: &'static str = "ChatMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.SenderUid = is.read_uint64()?;
                },
                18 => {
                    self.SenderName = is.read_string()?;
                },
                24 => {
                    self.SendTime = is.read_uint64()?;
                },
                32 => {
                    self.MessageType = is.read_uint32()?;
                },
                42 => {
                    self.Message = is.read_string()?;
                },
                50 => {
                    self.Head = is.read_string()?;
                },
                56 => {
                    self.Reciver = is.read_uint64()?;
                },
                64 => {
                    self.LastSendTime = is.read_uint64()?;
                },
                72 => {
                    self.SisId = is.read_uint64()?;
                },
                80 => {
                    self.Flag = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.SenderUid != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.SenderUid);
        }
        if !self.SenderName.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.SenderName);
        }
        if self.SendTime != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.SendTime);
        }
        if self.MessageType != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.MessageType);
        }
        if !self.Message.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.Message);
        }
        if !self.Head.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.Head);
        }
        if self.Reciver != 0 {
            my_size += ::protobuf::rt::uint64_size(7, self.Reciver);
        }
        if self.LastSendTime != 0 {
            my_size += ::protobuf::rt::uint64_size(8, self.LastSendTime);
        }
        if self.SisId != 0 {
            my_size += ::protobuf::rt::uint64_size(9, self.SisId);
        }
        if self.Flag != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.Flag);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.SenderUid != 0 {
            os.write_uint64(1, self.SenderUid)?;
        }
        if !self.SenderName.is_empty() {
            os.write_string(2, &self.SenderName)?;
        }
        if self.SendTime != 0 {
            os.write_uint64(3, self.SendTime)?;
        }
        if self.MessageType != 0 {
            os.write_uint32(4, self.MessageType)?;
        }
        if !self.Message.is_empty() {
            os.write_string(5, &self.Message)?;
        }
        if !self.Head.is_empty() {
            os.write_string(6, &self.Head)?;
        }
        if self.Reciver != 0 {
            os.write_uint64(7, self.Reciver)?;
        }
        if self.LastSendTime != 0 {
            os.write_uint64(8, self.LastSendTime)?;
        }
        if self.SisId != 0 {
            os.write_uint64(9, self.SisId)?;
        }
        if self.Flag != 0 {
            os.write_uint32(10, self.Flag)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ChatMessage {
        ChatMessage::new()
    }

    fn clear(&mut self) {
        self.SenderUid = 0;
        self.SenderName.clear();
        self.SendTime = 0;
        self.MessageType = 0;
        self.Message.clear();
        self.Head.clear();
        self.Reciver = 0;
        self.LastSendTime = 0;
        self.SisId = 0;
        self.Flag = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ChatMessage {
        static instance: ChatMessage = ChatMessage {
            SenderUid: 0,
            SenderName: ::std::string::String::new(),
            SendTime: 0,
            MessageType: 0,
            Message: ::std::string::String::new(),
            Head: ::std::string::String::new(),
            Reciver: 0,
            LastSendTime: 0,
            SisId: 0,
            Flag: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ChatMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ChatMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ChatMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChatMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:pbdef.RechargeResultNotify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct RechargeResultNotify {
    // message fields
    // @@protoc_insertion_point(field:pbdef.RechargeResultNotify.ret)
    pub ret: i32,
    // @@protoc_insertion_point(field:pbdef.RechargeResultNotify.recharge_type)
    pub recharge_type: u32,
    // @@protoc_insertion_point(field:pbdef.RechargeResultNotify.recharge_id)
    pub recharge_id: u32,
    // @@protoc_insertion_point(field:pbdef.RechargeResultNotify.result_bool_0)
    pub result_bool_0: bool,
    // @@protoc_insertion_point(field:pbdef.RechargeResultNotify.rechargeCost)
    pub rechargeCost: u32,
    // @@protoc_insertion_point(field:pbdef.RechargeResultNotify.cpOrderid)
    pub cpOrderid: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:pbdef.RechargeResultNotify.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RechargeResultNotify {
    fn default() -> &'a RechargeResultNotify {
        <RechargeResultNotify as ::protobuf::Message>::default_instance()
    }
}

impl RechargeResultNotify {
    pub fn new() -> RechargeResultNotify {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ret",
            |m: &RechargeResultNotify| { &m.ret },
            |m: &mut RechargeResultNotify| { &mut m.ret },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recharge_type",
            |m: &RechargeResultNotify| { &m.recharge_type },
            |m: &mut RechargeResultNotify| { &mut m.recharge_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "recharge_id",
            |m: &RechargeResultNotify| { &m.recharge_id },
            |m: &mut RechargeResultNotify| { &mut m.recharge_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "result_bool_0",
            |m: &RechargeResultNotify| { &m.result_bool_0 },
            |m: &mut RechargeResultNotify| { &mut m.result_bool_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rechargeCost",
            |m: &RechargeResultNotify| { &m.rechargeCost },
            |m: &mut RechargeResultNotify| { &mut m.rechargeCost },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cpOrderid",
            |m: &RechargeResultNotify| { &m.cpOrderid },
            |m: &mut RechargeResultNotify| { &mut m.cpOrderid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RechargeResultNotify>(
            "RechargeResultNotify",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RechargeResultNotify {
    const NAME: &'static str = "RechargeResultNotify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ret = is.read_int32()?;
                },
                16 => {
                    self.recharge_type = is.read_uint32()?;
                },
                24 => {
                    self.recharge_id = is.read_uint32()?;
                },
                40 => {
                    self.result_bool_0 = is.read_bool()?;
                },
                48 => {
                    self.rechargeCost = is.read_uint32()?;
                },
                58 => {
                    self.cpOrderid = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ret != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.ret);
        }
        if self.recharge_type != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.recharge_type);
        }
        if self.recharge_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.recharge_id);
        }
        if self.result_bool_0 != false {
            my_size += 1 + 1;
        }
        if self.rechargeCost != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.rechargeCost);
        }
        if !self.cpOrderid.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.cpOrderid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ret != 0 {
            os.write_int32(1, self.ret)?;
        }
        if self.recharge_type != 0 {
            os.write_uint32(2, self.recharge_type)?;
        }
        if self.recharge_id != 0 {
            os.write_uint32(3, self.recharge_id)?;
        }
        if self.result_bool_0 != false {
            os.write_bool(5, self.result_bool_0)?;
        }
        if self.rechargeCost != 0 {
            os.write_uint32(6, self.rechargeCost)?;
        }
        if !self.cpOrderid.is_empty() {
            os.write_string(7, &self.cpOrderid)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RechargeResultNotify {
        RechargeResultNotify::new()
    }

    fn clear(&mut self) {
        self.ret = 0;
        self.recharge_type = 0;
        self.recharge_id = 0;
        self.result_bool_0 = false;
        self.rechargeCost = 0;
        self.cpOrderid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RechargeResultNotify {
        static instance: RechargeResultNotify = RechargeResultNotify {
            ret: 0,
            recharge_type: 0,
            recharge_id: 0,
            result_bool_0: false,
            rechargeCost: 0,
            cpOrderid: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RechargeResultNotify {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RechargeResultNotify").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RechargeResultNotify {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RechargeResultNotify {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:pbdef.LoginPlatform)
pub enum LoginPlatform {
    // @@protoc_insertion_point(enum_value:pbdef.LoginPlatform.None)
    None = 0,
    // @@protoc_insertion_point(enum_value:pbdef.LoginPlatform.Debug)
    Debug = 1,
    // @@protoc_insertion_point(enum_value:pbdef.LoginPlatform.Guest)
    Guest = 2,
    // @@protoc_insertion_point(enum_value:pbdef.LoginPlatform.UnionAccount)
    UnionAccount = 3,
    // @@protoc_insertion_point(enum_value:pbdef.LoginPlatform.WeChat)
    WeChat = 4,
    // @@protoc_insertion_point(enum_value:pbdef.LoginPlatform.QQ)
    QQ = 5,
}

impl ::protobuf::Enum for LoginPlatform {
    const NAME: &'static str = "LoginPlatform";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LoginPlatform> {
        match value {
            0 => ::std::option::Option::Some(LoginPlatform::None),
            1 => ::std::option::Option::Some(LoginPlatform::Debug),
            2 => ::std::option::Option::Some(LoginPlatform::Guest),
            3 => ::std::option::Option::Some(LoginPlatform::UnionAccount),
            4 => ::std::option::Option::Some(LoginPlatform::WeChat),
            5 => ::std::option::Option::Some(LoginPlatform::QQ),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LoginPlatform> {
        match str {
            "None" => ::std::option::Option::Some(LoginPlatform::None),
            "Debug" => ::std::option::Option::Some(LoginPlatform::Debug),
            "Guest" => ::std::option::Option::Some(LoginPlatform::Guest),
            "UnionAccount" => ::std::option::Option::Some(LoginPlatform::UnionAccount),
            "WeChat" => ::std::option::Option::Some(LoginPlatform::WeChat),
            "QQ" => ::std::option::Option::Some(LoginPlatform::QQ),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LoginPlatform] = &[
        LoginPlatform::None,
        LoginPlatform::Debug,
        LoginPlatform::Guest,
        LoginPlatform::UnionAccount,
        LoginPlatform::WeChat,
        LoginPlatform::QQ,
    ];
}

impl ::protobuf::EnumFull for LoginPlatform {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LoginPlatform").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LoginPlatform {
    fn default() -> Self {
        LoginPlatform::None
    }
}

impl LoginPlatform {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LoginPlatform>("LoginPlatform")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eUserData.proto\x12\x05pbdef\x1a\x10BaseDefine.protoP\0\"=\n\x11Log\
    inPlatformData\x12\x10\n\x03uid\x18\x01\x20\x01(\x04R\x03uid\x12\x16\n\
    \x06acount\x18\x02\x20\x01(\tR\x06acount\"\xee\x03\n\x0cUserSnapshot\x12\
    \x17\n\x07user_id\x18\x01\x20\x01(\x04R\x06userId\x12\x20\n\x0bPhoneNumb\
    er\x18\x02\x20\x01(\tR\x0bPhoneNumber\x12\"\n\x0cHeadPrtraits\x18\x03\
    \x20\x01(\tR\x0cHeadPrtraits\x12\x1a\n\x08NickName\x18\x04\x20\x01(\tR\
    \x08NickName\x12\x1a\n\x08StatusId\x18\x05\x20\x01(\tR\x08StatusId\x12\
    \x14\n\x05Money\x18\x06\x20\x01(\x02R\x05Money\x12\x14\n\x05Email\x18\
    \x07\x20\x01(\tR\x05Email\x12\x1a\n\x08mapShops\x18\x08\x20\x01(\tR\x08m\
    apShops\x12\x18\n\x07balance\x18\t\x20\x01(\x02R\x07balance\x12\x1c\n\ta\
    utograph\x18\x0f\x20\x01(\tR\tautograph\x12\"\n\x0crealnametype\x18\x10\
    \x20\x01(\x05R\x0crealnametype\x12\"\n\rsis_cur_svrid\x18\n\x20\x01(\rR\
    \x0bsisCurSvrid\x12\x17\n\x07php_uid\x18\x0b\x20\x01(\x05R\x06phpUid\x12\
    \x20\n\x0baccessToken\x18\x0c\x20\x01(\tR\x0baccessToken\x12!\n\x0ctoken\
    _expire\x18\r\x20\x01(\rR\x0btokenExpire\x12!\n\x0clogin_acount\x18\x0e\
    \x20\x01(\tR\x0bloginAcount\"\xdb\x07\n\x0bUserAllData\x12\x16\n\x06user\
    Id\x18\x01\x20\x01(\x05R\x06userId\x12\x20\n\x0bphoneNumber\x18\x02\x20\
    \x01(\tR\x0bphoneNumber\x12\x18\n\x07mailbox\x18\x03\x20\x01(\tR\x07mail\
    box\x12\"\n\x0cheadPrtraits\x18\x04\x20\x01(\tR\x0cheadPrtraits\x12\x1a\
    \n\x08nickName\x18\x05\x20\x01(\tR\x08nickName\x12\x16\n\x06passwd\x18\
    \x06\x20\x01(\tR\x06passwd\x12$\n\rtradePassWord\x18\x07\x20\x01(\tR\rtr\
    adePassWord\x12\x1c\n\tautograph\x18\x08\x20\x01(\tR\tautograph\x12\x18\
    \n\x07balance\x18\t\x20\x01(\x02R\x07balance\x12\x16\n\x06alipay\x18\n\
    \x20\x01(\tR\x06alipay\x12\x1e\n\nalipayname\x18\x0b\x20\x01(\tR\nalipay\
    name\x12\"\n\x0crealnametype\x18\x0c\x20\x01(\x05R\x0crealnametype\x12\
    \x1e\n\ncreateTime\x18\r\x20\x01(\tR\ncreateTime\x12\x1a\n\x08statusId\
    \x18\x0e\x20\x01(\tR\x08statusId\x12\x18\n\x07address\x18\x0f\x20\x01(\t\
    R\x07address\x12\x1e\n\nprivatekey\x18\x10\x20\x01(\tR\nprivatekey\x12\
    \x1c\n\twhitelist\x18\x11\x20\x01(\x05R\twhitelist\x12\x1a\n\x08realname\
    \x18\x12\x20\x01(\tR\x08realname\x12\x16\n\x06realno\x18\x13\x20\x01(\tR\
    \x06realno\x12\"\n\x0cinvitationId\x18\x14\x20\x01(\x05R\x0cinvitationId\
    \x12(\n\x0finvitationcount\x18\x15\x20\x01(\x05R\x0finvitationcount\x12\
    \x18\n\x07szcount\x18\x16\x20\x01(\x05R\x07szcount\x12\x16\n\x06sztime\
    \x18\x17\x20\x01(\tR\x06sztime\x12\x1c\n\tiscreater\x18\x18\x20\x01(\x05\
    R\tiscreater\x12\x14\n\x05money\x18\x19\x20\x01(\x02R\x05money\x12\x14\n\
    \x05email\x18\x1a\x20\x01(\tR\x05email\x12&\n\x0einvitationCode\x18\x1b\
    \x20\x01(\tR\x0einvitationCode\x12\"\n\x0clotterytimes\x18\x1c\x20\x01(\
    \x05R\x0clotterytimes\x12\x18\n\x07buycard\x18\x1d\x20\x01(\x05R\x07buyc\
    ard\x12\x16\n\x06ustype\x18\x1e\x20\x01(\x05R\x06ustype\x12\x1a\n\x08tud\
    icard\x18\x1f\x20\x01(\x05R\x08tudicard\x12\x1e\n\nupdateTime\x18\x20\
    \x20\x01(\tR\nupdateTime\x12\x1a\n\x08mapShops\x18!\x20\x01(\tR\x08mapSh\
    ops\"\x9f\x02\n\x0bChatMessage\x12\x1c\n\tSenderUid\x18\x01\x20\x01(\x04\
    R\tSenderUid\x12\x1e\n\nSenderName\x18\x02\x20\x01(\tR\nSenderName\x12\
    \x1a\n\x08SendTime\x18\x03\x20\x01(\x04R\x08SendTime\x12\x20\n\x0bMessag\
    eType\x18\x04\x20\x01(\rR\x0bMessageType\x12\x18\n\x07Message\x18\x05\
    \x20\x01(\tR\x07Message\x12\x12\n\x04Head\x18\x06\x20\x01(\tR\x04Head\
    \x12\x18\n\x07Reciver\x18\x07\x20\x01(\x04R\x07Reciver\x12\"\n\x0cLastSe\
    ndTime\x18\x08\x20\x01(\x04R\x0cLastSendTime\x12\x14\n\x05SisId\x18\t\
    \x20\x01(\x04R\x05SisId\x12\x12\n\x04Flag\x18\n\x20\x01(\rR\x04Flag\"\
    \xd4\x01\n\x14RechargeResultNotify\x12\x10\n\x03ret\x18\x01\x20\x01(\x05\
    R\x03ret\x12#\n\rrecharge_type\x18\x02\x20\x01(\rR\x0crechargeType\x12\
    \x1f\n\x0brecharge_id\x18\x03\x20\x01(\rR\nrechargeId\x12\"\n\rresult_bo\
    ol_0\x18\x05\x20\x01(\x08R\x0bresultBool0\x12\"\n\x0crechargeCost\x18\
    \x06\x20\x01(\rR\x0crechargeCost\x12\x1c\n\tcpOrderid\x18\x07\x20\x01(\t\
    R\tcpOrderid*U\n\rLoginPlatform\x12\x08\n\x04None\x10\0\x12\t\n\x05Debug\
    \x10\x01\x12\t\n\x05Guest\x10\x02\x12\x10\n\x0cUnionAccount\x10\x03\x12\
    \n\n\x06WeChat\x10\x04\x12\x06\n\x02QQ\x10\x05b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::BaseDefine::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(5);
            messages.push(LoginPlatformData::generated_message_descriptor_data());
            messages.push(UserSnapshot::generated_message_descriptor_data());
            messages.push(UserAllData::generated_message_descriptor_data());
            messages.push(ChatMessage::generated_message_descriptor_data());
            messages.push(RechargeResultNotify::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(LoginPlatform::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
